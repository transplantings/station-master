<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Station Master: Terminal Velocity VIII</title>
    <style>
        /* FONTS */
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Montserrat:wght@800&family=Russo+One&family=Satisfy&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier Prime', monospace; user-select: none; }

        /* --- INTRO SPLASH (FIRST LOAD) --- */
        #intro-splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 1; transition: opacity 2s ease-out;
        }
        .intro-text {
            font-family: 'Satisfy', cursive;
            font-size: 42px; color: #eee;
            margin-bottom: 40px;
            text-align: center;
            padding: 0 20px;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        .dot { animation: blink-dot 1.4s infinite both; }
        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes blink-dot {
            0% { opacity: 0; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes flash-white {
            0% { border-color: #444; color: #888; box-shadow: 0 0 0 #000; }
            50% { border-color: #fff; color: #fff; box-shadow: 0 0 15px #fff; }
            100% { border-color: #444; color: #888; box-shadow: 0 0 0 #000; }
        }

        #intro-btn {
            background: #111; color: #888; border: 2px solid #444;
            padding: 15px 40px; font-family: 'Montserrat', sans-serif;
            font-size: 18px; letter-spacing: 2px; text-transform: uppercase;
            cursor: pointer; transition: 0.3s;
            animation: flash-white 2.5s infinite;
        }
        #intro-btn:hover {
            background: #eee; color: #000; border-color: #fff; animation: none;
        }

        /* --- READY OVERLAY (GAME START) --- */
        #ready-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(200, 190, 170, 0.15); /* Warmer fog */
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 150; display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #ready-msg {
            font-family: 'Montserrat', sans-serif; font-size: 30px; color: #fff;
            text-shadow: 0 0 10px #000; letter-spacing: 5px; margin-bottom: 30px;
            text-transform: uppercase; border-bottom: 2px solid #00FF00; padding-bottom: 10px;
        }
        #ready-btn {
            background: rgba(0, 0, 0, 0.8); color: #00FF00; border: 2px solid #00FF00;
            padding: 20px 60px; font-family: 'Russo One', sans-serif; font-size: 24px;
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #ready-btn:hover { background: #00FF00; color: #000; box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }

        /* --- RETURN OVERLAY (MENU RESTART) --- */
        #return-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 50, 50, 0.9); /* Grey overlay */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            z-index: 250; /* Above menu but below intro */
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #return-msg {
            font-family: 'Montserrat', sans-serif; font-size: 30px; color: #fff;
            text-shadow: 0 0 10px #000; letter-spacing: 5px; margin-bottom: 30px;
            text-transform: uppercase; border-bottom: 2px solid #FFCC00; padding-bottom: 10px;
        }
        #return-btn {
            background: rgba(0, 0, 0, 0.8); color: #FFCC00; border: 2px solid #FFCC00;
            padding: 20px 60px; font-family: 'Russo One', sans-serif; font-size: 24px;
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #return-btn:hover { background: #FFCC00; color: #000; box-shadow: 0 0 40px rgba(255, 204, 0, 0.8); }


        /* --- VISUAL FX --- */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 15%, #000 60%);
            pointer-events: none; display: none; z-index: 10;
        }

        #blood-screen-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90; overflow: hidden; display: none;
        }
        .drip {
            position: absolute; top: -150px; width: 15px; background: #8a0303;
            border-radius: 0 0 15px 15px; opacity: 0.9; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            pointer-events: none; z-index: 11; transition: all 0.2s;
        }
        #crosshair.zoomed { 
            border-color: #00FF00; width: 200px; height: 200px; border-width: 1px; border-radius: 0;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><line x1="100" y1="0" x2="100" y2="200" stroke="%2300FF00" stroke-width="1"/><line x1="0" y1="100" x2="200" y2="100" stroke="%2300FF00" stroke-width="1"/></svg>');
        }

        /* --- UI --- */
        #top-ui-container {
            position: absolute; top: 0; left: 0; width: 100%; z-index: 20;
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #top-ui-container.minimized {
            transform: translateY(-92%); 
        }

        #top-ui {
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 90%, transparent 100%);
            padding: 10px 30px 20px 30px; display: flex; justify-content: space-between; align-items: flex-start;
            color: #00FF00; font-family: 'Montserrat', sans-serif; letter-spacing: 2px; font-size: 14px;
            text-shadow: 0 0 5px #00FF00; position: relative;
        }
        
        #ui-toggle-btn {
            position: absolute; bottom: -24px; left: 0; 
            background: rgba(0,0,0,0.8); color: #00FF00; border: 1px solid #005500; border-top: none; border-left: none;
            padding: 4px 15px; cursor: pointer; font-size: 10px; border-radius: 0 0 10px 0;
            text-shadow: 0 0 5px #00FF00; pointer-events: auto; display: flex; align-items: center; gap: 5px;
            font-family: 'Montserrat', sans-serif; letter-spacing: 1px;
        }
        #ui-toggle-btn:hover { background: #002200; }
        .arrow-icon { font-size: 14px; font-weight: bold; }

        /* TIMER FIXED */
        #fixed-timer-container {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            z-index: 25; pointer-events: none; display: none;
        }
        #timer-ui {
            font-family: 'Courier Prime', monospace; font-size: 24px; color: #FF0000;
            text-shadow: 0 0 10px #FF0000; border: 2px solid #550000;
            background: rgba(0,0,0,0.8); padding: 5px 15px; font-weight: bold;
        }

        .key-hint { color: #fff; background: rgba(0,255,0,0.2); padding: 2px 6px; border: 1px solid #00FF00; font-size: 11px; margin: 0 5px; }

        /* CUSTOM SLIDER STYLING */
        .vol-control { font-size: 10px; display: flex; align-items: center; margin-bottom: 8px; justify-content: flex-end; }
        .vol-label { width: 20px; text-align: center; margin-right: 5px; color: #888; font-size: 14px; }
        .vol-btn { color: #555; font-size: 12px; margin: 0 5px; font-weight: bold; cursor: pointer;}
        .vol-btn:hover { color: #fff; }
        
        input[type=range].tech-slider {
            -webkit-appearance: none; width: 140px; background: transparent; cursor: pointer; /* Extended width */
        }
        input[type=range].tech-slider:focus { outline: none; }
        input[type=range].tech-slider::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border: 1px solid #555;
        }
        input[type=range].tech-slider::-webkit-slider-thumb {
            height: 12px; width: 6px; background: #00FF00; cursor: pointer;
            -webkit-appearance: none; margin-top: -5px; box-shadow: 0 0 5px #00FF00;
        }

        #phone-overlay {
            position: absolute; bottom: -200px; right: 30px; width: 350px;
            background: rgba(10,10,10,0.95); border-left: 5px solid #FFCC00; 
            padding: 20px; color: white; box-shadow: 0 10px 40px rgba(0,0,0,1);
            transition: bottom 0.6s cubic-bezier(0.22, 1, 0.36, 1); z-index: 50;
        }
        .intel-header { font-family: 'Montserrat', sans-serif; font-size: 10px; color: #FFCC00; letter-spacing: 3px; margin-bottom: 5px; }
        .intel-body { font-size: 22px; font-weight: bold; color: #fff; font-family: 'Courier Prime', monospace; }

        /* --- MENUS --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }
        #matrix-canvas { position: absolute; top: 0; left: 0; z-index: 0; opacity: 0.25; }
        #chalk-outlines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.2; pointer-events: none; }
        .chalk-body {
            position: absolute; width: 100px; height: 180px;
            border: 2px dashed #fff; border-radius: 30% 30% 0 0; opacity: 0.6;
        }
        .chalk-body::after { content:''; position:absolute; top: -30px; left:25px; width:50px; height:50px; border: 2px dashed #fff; border-radius:50%; }

        .dossier {
            width: 700px; padding: 40px; background: #e8e4c9; color: #111; /* Beige/Sand */
            box-shadow: 0 0 100px rgba(0,0,0,1); transform: rotate(-0.5deg); position: relative;
            border: 1px solid #999; z-index: 5;
        }
        .stamp {
            position: absolute; top: 30px; right: 30px;
            border: 5px solid #C00; color: #C00; font-family: 'Montserrat', sans-serif;
            font-size: 40px; font-weight: 900; padding: 5px 20px;
            transform: rotate(12deg) scale(3); opacity: 0; mix-blend-mode: multiply;
            /* Default state hidden for animation */
            pointer-events: none;
        }

        /* STAMP ANIMATION */
        @keyframes stamp-slam {
            0% { opacity: 0; transform: rotate(12deg) scale(3); }
            70% { opacity: 0.8; transform: rotate(12deg) scale(0.9); }
            100% { opacity: 0.8; transform: rotate(12deg) scale(1.0); }
        }
        .stamp.slammed {
            animation: stamp-slam 0.4s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes sheen { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
        h1 { 
            font-family: 'Montserrat', sans-serif; font-size: 40px; margin: 0 0 10px 0; 
            text-transform: uppercase; letter-spacing: -2px; border-bottom: 4px solid #111; 
            position: relative; overflow: hidden;
            background: linear-gradient(90deg, #111 0%, #111 45%, #555 50%, #111 55%, #111 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: sheen 3s infinite linear;
        }
        
        .mission-brief {
            background: #d3cba8; padding: 15px; border-left: 5px solid #111; /* Darker Sand */
            font-family: 'Courier Prime', monospace; font-size: 13px; margin: 15px 0; line-height: 1.4;
        }

        .streak-box {
            position: absolute; top: -20px; left: -20px; background: #000; color: #FFCC00;
            padding: 10px 20px; border: 2px solid #FFCC00; font-family: 'Montserrat', sans-serif;
            font-weight: bold; transform: rotate(-5deg); box-shadow: 5px 5px 0 rgba(0,0,0,0.5);
        }

        .leaderboard-box {
            position: absolute; top: 15%; right: -280px; transform: rotate(2deg);
            width: 250px; background: #111; border: 1px solid #444; color: #00FF00;
            padding: 20px; font-family: 'Montserrat', sans-serif;
            background-image: linear-gradient(0deg, transparent 24%, rgba(0, 255, 0, .05) 25%, rgba(0, 255, 0, .05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .05) 75%, rgba(0, 255, 0, .05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(0, 255, 0, .05) 25%, rgba(0, 255, 0, .05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .05) 75%, rgba(0, 255, 0, .05) 76%, transparent 77%, transparent);
            background-size: 30px 30px; box-shadow: -10px 10px 30px rgba(0,0,0,0.8);
        }
        
        .stats-box {
            position: absolute; top: 60%; right: -300px; transform: rotate(-1deg);
            width: 270px; background: #000; border: 2px solid #fff; color: #fff;
            padding: 15px; font-family: 'Courier Prime', monospace;
            box-shadow: -10px 10px 30px rgba(0,0,0,0.8);
        }
        .stats-title { text-align: center; border-bottom: 1px dashed #fff; margin-bottom: 10px; font-weight: bold; letter-spacing: 2px; }
        .stats-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; }
        .stats-val { font-weight: bold; color: #FFCC00; }
        .reset-btn-small { margin-top:10px; width: 100%; background: #222; border: 1px solid #555; color: #777; font-size: 10px; padding: 5px; cursor: pointer; }
        .reset-btn-small:hover { background: #500; color: #fff; border-color: #f00; }

        .lb-title { border-bottom: 2px solid #00FF00; font-size: 14px; letter-spacing: 2px; margin-bottom: 10px; padding-bottom: 5px; }
        .lb-row { display: flex; justify-content: space-between; font-family: 'Courier Prime', monospace; font-size: 12px; margin-bottom: 6px; color: #fff; }
        .lb-rank { color: #555; margin-right: 10px; }
        .lb-name { color: #00FF00; margin-right: 5px; }
        .lb-time { color: #FFCC00; font-weight: bold; }

        #award-text {
            font-family: 'Russo One', sans-serif; font-size: 32px; color: #444;
            margin-top: 10px; text-transform: uppercase; letter-spacing: 2px;
            background: linear-gradient(45deg, #998800, #FFDD00, #998800);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2); font-style: italic;
        }

        .settings-box {
            background: #333; color: #fff; padding: 15px; margin-top: 15px;
            border: 1px solid #555; font-family: 'Montserrat', sans-serif;
        }
        .slider-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .slider-row label { font-size: 12px; letter-spacing: 1px; width: 150px; }
        .slider-row input[type=range] { flex-grow: 1; margin: 0 15px; cursor: pointer; }
        .slider-row span { font-weight: bold; color: #FFCC00; width: 30px; text-align: right; }
        
        .chk-group { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .chk-label { font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: #ccc; }
        .chk-label input:checked + span { color: #00FF00; text-shadow: 0 0 5px #00FF00; font-weight: bold; }

        .preset-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .preset-btn {
            flex: 1; background: #222; color: #888; border: 1px solid #444;
            font-size: 10px; padding: 5px; cursor: pointer; font-family: 'Montserrat', sans-serif;
            letter-spacing: 1px; transition: 0.2s;
        }
        .preset-btn:hover { background: #444; color: #fff; border-color: #888; }
        
        /* CLASSY DIFFICULTY BUTTON STYLES */
        #btn-easy { border-bottom: 2px solid #00AA00; }
        #btn-easy:hover { background: #002200; color: #00FF00; border-color: #00FF00; }
        
        #btn-med { border-bottom: 2px solid #AA6600; }
        #btn-med:hover { background: #221100; color: #FFAA00; border-color: #FFAA00; }
        
        #btn-hard { border-bottom: 2px solid #AA0000; }
        #btn-hard:hover { background: #220000; color: #FF0000; border-color: #FF0000; }

        .btn-row { display: flex; gap: 15px; margin-top: 15px; }
        
        @keyframes pulse-btn {
            0% { box-shadow: 0 0 0 0 rgba(200, 0, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(200, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(200, 0, 0, 0); }
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner {
            border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid #fff;
            border-radius: 50%; width: 20px; height: 20px;
            animation: spin 1s linear infinite; margin: 0 auto;
        }

        button.action-btn {
            width: 100%; background: #111; color: white; border: none; padding: 15px;
            font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 16px;
            text-transform: uppercase; letter-spacing: 2px; cursor: pointer; transition: 0.3s;
            animation: pulse-btn 2s infinite; height: 50px;
        }
        button.action-btn:hover { background: #C00; transform: scale(1.02); animation: none; }
        button.action-btn.clicked {
            animation: none; transform: scale(0.95); background: #333; box-shadow: inset 0 0 10px #000; border: 1px solid #555;
        }

        button.sec-btn { background: #222; border: 1px solid #444; color: #aaa; animation: none; }
        button.sec-btn:hover { background: #004400; color: #fff; border-color: #00FF00; }
        
        #restart-ui { position: absolute; bottom: 20px; left: 20px; z-index: 60; }
        #restart-btn { background: #333; color: #aaa; border: 1px solid #555; padding: 10px; font-family: sans-serif; font-size: 10px; cursor: pointer; text-transform: uppercase; }
        #restart-btn:hover { background: #C00; color: #fff; border-color: #C00; }

        /* HIGH SCORE MODAL */
        #high-score-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .hs-content {
            background: #111; border: 2px solid #555; padding: 40px;
            text-align: center; font-family: 'Courier Prime', monospace;
            box-shadow: 0 0 50px #000; border-top: 5px solid #00FF00;
        }
        .hs-title { font-size: 24px; color: #00FF00; margin-bottom: 20px; font-weight: bold; font-family: 'Montserrat', sans-serif; letter-spacing: 2px;}
        #new-record-time { font-family: 'Russo One', sans-serif; font-size: 40px; color: #FFCC00; margin-bottom: 20px; }
        #hs-input {
            background: #222; border: 2px solid #00FF00; color: #fff;
            font-size: 40px; text-transform: uppercase; text-align: center;
            width: 200px; padding: 10px; font-family: 'Courier Prime', monospace;
            margin: 20px 0; letter-spacing: 10px;
        }
        #hs-input:focus { outline: none; background: #003300; }

        /* CUSTOM CONFIRM MODAL */
        #confirm-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 300;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .confirm-box {
            background: #111; border: 2px solid #FFCC00; padding: 30px; width: 400px;
            text-align: center; font-family: 'Montserrat', sans-serif; color: #fff;
            box-shadow: 0 0 40px rgba(255, 204, 0, 0.2);
            position: relative;
        }
        .confirm-title { font-size: 20px; color: #FFCC00; border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 20px; letter-spacing: 2px; }
        .confirm-msg { font-size: 14px; margin-bottom: 30px; font-family: 'Courier Prime', monospace; color: #ccc; line-height: 1.5; }
        .confirm-btn-row { display: flex; gap: 20px; justify-content: center; }
        .conf-btn { padding: 10px 20px; font-family: 'Montserrat', sans-serif; font-weight: bold; cursor: pointer; border: 1px solid #444; transition: 0.2s; font-size: 12px; }
        .btn-yes { background: #300; color: #f55; border-color: #500; }
        .btn-yes:hover { background: #f00; color: #fff; }
        .btn-no { background: #222; color: #aaa; }
        .btn-no:hover { background: #444; color: #fff; }
        .warning-stripe {
            position: absolute; top: -10px; left: -10px; background: #FFCC00; color: #000;
            font-size: 10px; padding: 5px; font-weight: bold; transform: rotate(-5deg); border: 2px solid #000;
        }


        /* VERTICAL MENU SLIDER */
        #menu-vol-container {
            position: absolute; top: 50%; left: -70px;
            transform: translateY(-50%) rotate(-90deg);
            display: flex; align-items: center; gap: 10px;
            background: #111; padding: 8px; border: 1px solid #444;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.8); z-index: 6;
        }
        #menu-vol-container label { font-size: 9px; color: #888; letter-spacing: 2px; font-family: 'Montserrat', sans-serif; }
        input[type=range].vertical-slider {
            -webkit-appearance: none; width: 80px; background: transparent; cursor: pointer;
        }
        input[type=range].vertical-slider:focus { outline: none; }
        input[type=range].vertical-slider::-webkit-slider-runnable-track { width: 100%; height: 2px; background: #555; }
        input[type=range].vertical-slider::-webkit-slider-thumb {
            height: 10px; width: 10px; background: #00FF00; cursor: pointer;
            -webkit-appearance: none; margin-top: -4px; border-radius: 50%;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <audio id="sfx-ambience" loop>
        <source src="ambience.mp3" type="audio/mp3">
    </audio>
    <audio id="menu-bgm" loop>
        <source src="menumusic.mp3" type="audio/mp3">
    </audio>

    <div id="intro-splash">
        <div class="intro-text">
            So... are you ready to die for your country<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>
        </div>
        <button id="intro-btn" onclick="enterGame()">Yes I am</button>
    </div>

    <div id="ready-overlay">
        <div id="ready-msg">Area Secure</div>
        <button id="ready-btn" onclick="confirmReady()">I'm Ready</button>
    </div>

    <div id="return-overlay">
        <div id="return-msg">System Rebooted</div>
        <button id="return-btn" onclick="confirmReturn()">Resume Operation</button>
    </div>

    <div id="confirm-modal">
        <div class="confirm-box">
            <div class="warning-stripe">IRREVERSIBLE</div>
            <div class="confirm-title">SYSTEM PURGE</div>
            <div class="confirm-msg">
                Are you sure you want to wipe all field reports and leaderboard data?
                <br><br>
                <span style="color:#f55;">THIS ACTION CANNOT BE UNDONE.</span>
            </div>
            <div class="confirm-btn-row">
                <button class="conf-btn btn-yes" onclick="performReset()">CONFIRM PURGE</button>
                <button class="conf-btn btn-no" onclick="closeConfirm()">CANCEL</button>
            </div>
        </div>
    </div>

    <div id="top-ui-container" class="minimized">
        <div id="top-ui">
            <div style="margin-top:10px;">
                <span class="key-hint">WASD</span> AIM 
                <span class="key-hint">SPACE</span> ZOOM 
                <span class="key-hint">F</span> FIRE
            </div>
            <div style="display:flex; align-items:center; gap:20px;">
                <div style="display:flex; flex-direction: column; align-items: flex-end;">
                    <div class="vol-control" id="vol-music-container">
                        <span class="vol-label">&#9834;</span>
                        <span class="vol-btn" onclick="nextTrack()">[>>]</span>
                        <span class="vol-btn">[-]</span>
                        <input type="range" id="vol-music-slider" class="tech-slider" min="0" max="1" step="0.02" value="0.3">
                        <span class="vol-btn">[+]</span>
                    </div>
                    <div class="vol-control" id="vol-sfx-container">
                        <span class="vol-label">SFX</span>
                        <span class="vol-btn">[-]</span>
                        <input type="range" id="vol-sfx-slider" class="tech-slider" min="0" max="1" step="0.02" value="0.8">
                        <span class="vol-btn">[+]</span>
                    </div>
                </div>
                <div style="font-size:16px;">UNIT: 00-WATCHMAN</div>
            </div>
            <button id="ui-toggle-btn" onclick="toggleTopUI()">
                <span class="arrow-icon" id="toggle-icon">^</span>
                <span id="toggle-text">OPEN MENU</span>
            </button>
        </div>
    </div>

    <div id="fixed-timer-container">
        <div id="timer-ui">00.000</div>
    </div>

    <div id="scope-overlay"></div>
    <div id="crosshair"></div>
    <div id="blood-screen-container"></div>
    
    <div id="phone-overlay">
        <div class="intel-header">INCOMING TRANSMISSION</div>
        <div class="intel-body" id="phone-text">CONNECTING...</div>
    </div>
    
    <div id="high-score-modal">
        <div class="hs-content">
            <div class="hs-title">RECORD BREAKER</div>
            <div id="new-record-time">00.000s</div>
            <div style="font-size:12px; color:#aaa;">ENTER INITIALS:</div>
            <input type="text" id="hs-input" maxlength="3" placeholder="___">
            <br>
            <button class="action-btn" style="width:auto; padding:10px 30px; margin-top:20px;" onclick="submitScore()">SUBMIT</button>
        </div>
    </div>

    <div id="menu">
        <canvas id="matrix-canvas"></canvas>
        <div id="chalk-outlines"></div>
        
        <div class="dossier" id="start-dossier">
            <div id="menu-vol-container">
                <label>MENU AUDIO</label>
                <input type="range" id="slide-menu-vol" class="vertical-slider" min="0" max="1" step="0.1" value="0.5" oninput="updateMenuVol()">
            </div>

            <div class="leaderboard-box">
                <div class="lb-title">TOP 5 AGENTS (SPEED)</div>
                <div id="lb-content"></div>
            </div>

            <div class="stats-box">
                <div class="stats-title">FIELD REPORT</div>
                <div class="stats-row"><span>TARGET COURIERS</span> <span class="stats-val" id="stat-target">0</span></div>
                <div class="stats-row"><span>DECOYS HIT</span> <span class="stats-val" id="stat-decoy">0</span></div>
                <div class="stats-row"><span>BYSTANDERS HIT</span> <span class="stats-val" id="stat-civ">0</span></div>
                <div class="stats-row"><span>ABORTS</span> <span class="stats-val" id="stat-abort">0</span></div>
                <button class="reset-btn-small" onclick="resetAllData()">[ RESET DATA / LEADERBOARD ]</button>
            </div>

            <div class="streak-box" id="menu-streak-box">STREAK: <span id="streak-display">0</span></div>
            <div class="stamp" style="opacity:0.8; transform: rotate(12deg) scale(1);">TOP SECRET</div>
            <h1>Operation: Terminus</h1>
            
            <div class="mission-brief">
                <p>> <strong>THE SITUATION:</strong> Multiple subjects carrying <span style="background:#FF0; color:#000; padding:0 2px;">YELLOW PACKAGES</span> have entered the concourse.</p>
                <p>> <strong>THE TARGET:</strong> Only <strong>ONE</strong> is heading to the correct train. The rest are decoys or shoppers.</p>
                <p>> <strong>EXECUTION:</strong> Wait for INTEL. Check the BOARD (Randomized). Eliminate the courier boarding the CORRECT train.</p>
            </div>

            <div class="settings-box">
                <div class="preset-row">
                    <button id="btn-easy" class="preset-btn" onclick="setDifficulty('EASY')">EASY</button>
                    <button id="btn-med" class="preset-btn" onclick="setDifficulty('MEDIUM')">MEDIUM</button>
                    <button id="btn-hard" class="preset-btn" onclick="setDifficulty('HARD')">HARD</button>
                </div>
                <div class="slider-row">
                    <label>CROWD DENSITY</label>
                    <input type="range" id="slide-crowd" min="117" max="499" value="80" oninput="updateUI()">
                    <span id="val-crowd">80</span>
                </div>
                <div class="slider-row">
                    <label>PACKAGE HOLDERS</label>
                    <input type="range" id="slide-pkg" min="2" max="99" value="4" oninput="updateUI()">
                    <span id="val-pkg">4</span>
                </div>
                <hr style="border-color:#555; margin:15px 0;">
                <div class="slider-row">
                    <label>AUDIO CONFIG</label>
                    <div class="chk-group">
                        <label class="chk-label">
                            <input type="checkbox" id="chk-music" checked onchange="updateUI()"> 
                            <span>GAME MUSIC</span>
                        </label>
                        <label class="chk-label">
                            <input type="checkbox" id="chk-random-pl" onchange="updateUI()"> 
                            <span>RANDOM PLAYLIST</span>
                        </label>
                        <label class="chk-label">
                            <input type="checkbox" id="chk-sfx" checked onchange="updateUI()"> 
                            <span>AMBIENCE</span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="btn-row">
                <button id="btn-fun" class="action-btn" onclick="initiateGame('STREAK', this)">PLAY FOR FUN</button>
                <button id="btn-speed" class="action-btn sec-btn" onclick="initiateGame('TIMED', this)">PLAY FOR SPEED</button>
            </div>
        </div>

        <div class="dossier" id="end-dossier" style="display:none; text-align:center;">
            <div class="stamp" id="end-stamp">CLEARED</div>
            <h1 id="outcome-title">REPORT</h1>
            <div id="award-text"></div>
            <p id="outcome-desc" style="font-size:18px; font-weight:bold;">...</p>
            <div style="margin-top:30px; text-align:right;">
                <button class="action-btn" style="width:auto; padding:15px 40px;" onclick="reloadWithFade()">NEW ASSIGNMENT >></button>
            </div>
        </div>
    </div>
    
    <div id="restart-ui">
        <button id="restart-btn" onclick="abortMission()">ABORT / RESTART</button>
    </div>

<script>
    // --- GITHUB PAGES FIX: Use lowercase filenames for compatibility ---
    const MUSIC_TRACKS = ['music1.mp3', 'music2.mp3', 'music3.mp3', 'music4.mp3', 'music5.mp3'];

    // DESTINATIONS
    const DESTINATIONS = [
        "OXFORD", "BRISTOL", "CARDIFF", "YORK", "DOVER", "BATH", "LEEDS", "RYE", 
        "SOUTHAMPTON", "BRIGHTON", "PORTSMOUTH", "EXETER", "BOURNEMOUTH",
        "SEVENOAKS", "LITTLE CROWLEY", "HASTINGS", "EASTBOURNE", "MARGATE", "RAMSGATE", "WORTHING"
    ];
    const NORTHERN = ["GLASGOW", "EDINBURGH", "ABERDEEN", "INVERNESS", "NEWCASTLE", "DURHAM", "MANCHESTER", "LIVERPOOL"];

    // COMB FACTS & REVIEWS (TVGoHome Style)
    const COMB_TRIVIA = [
        "FACT: The first comb was made of frozen butter.",
        "REVIEW: 'It combed my soup perfectly.' - G. Ramsey",
        "FACT: Napoleon used a comb to signal retreat.",
        "REVIEW: 'Too pointy. 1 star.' - Anon",
        "FACT: Combs were illegal in Devon until 1984.",
        "REVIEW: 'My hamster loves the grip.' - P. Daniels",
        "FACT: A comb cannot float in mercury.",
        "REVIEW: 'Don't shop at COMBS, terrible service.' - Jeff in Stoke",
        "FACT: In 1204, a comb was elected Mayor of Norwich.",
        "REVIEW: 'It smells of old trams.' - B. Johnson",
        "FACT: The moon is shaped like a very old comb.",
        "REVIEW: 'Instructions unclear, combed my toaster.'",
        "FACT: Queen Victoria owned 400 invisible combs.",
        "REVIEW: 'Does not work on bald eagles.' - USA_Fan",
        "FACT: Comb technology peaked in the Bronze Age.",
        "REVIEW: 'Refund refused. Sad.' - Karen1975",
        "FACT: 'Comb' is short for 'Combustable'.",
        "REVIEW: 'Perfect for scratching my car.' - D. Clarkson",
        "FACT: Every 3rd comb sold is haunted.",
        "REVIEW: 'It whispers to me at night.' - SpookySteve",
        "FACT: Combs can be used as primitive radios.",
        "REVIEW: 'Only picks up Radio 4.' - T. May",
        "FACT: A comb has never killed a swan.",
        "REVIEW: 'Too many teeth, not enough gum.'",
        "FACT: The collective noun for combs is a 'Tangle'.",
        "REVIEW: 'Made of cheese? No. Disappointed.'",
        "FACT: Julius Caesar invented the parting.",
        "REVIEW: 'Sticky. Why is it sticky?'",
        "FACT: Combs are banned in space.",
        "REVIEW: 'Arrived broken. Fixed with tape. 3/10'",
        "FACT: The world's largest comb is in Wigan.",
        "REVIEW: 'Not suitable for heavy gravel.'",
        "FACT: Ancient Greeks combed their salads.",
        "REVIEW: 'Expensive for a piece of plastic.'",
        "FACT: A comb a day keeps the barber away.",
        "REVIEW: 'My cat ate it.'",
        "FACT: Combs were once currency in Wales.",
        "REVIEW: 'Too loud when dropped.'",
        "FACT: The plastic comb was invented by accident.",
        "REVIEW: 'Does not comb thoughts. False advertising.'",
        "FACT: Vikings used combs to navigate.",
        "REVIEW: 'Slippery when wet.'",
        "FACT: A comb has 42 teeth on average.",
        "REVIEW: 'Lost it immediately.'",
        "FACT: Combs are afraid of heights.",
        "REVIEW: 'Color did not match my aura.'",
        "FACT: You can play a comb like a kazoo.",
        "REVIEW: 'Tastes like purple.'",
        "FACT: The Titanic had a dedicated comb room.",
        "REVIEW: 'Too shiny.'",
        "FACT: Combs were originally square.",
        "REVIEW: 'Not round enough.'",
        "FACT: A broken comb signifies rain.",
        "REVIEW: 'It bit me.'",
        "FACT: Combs dissolve in vinegar.",
        "REVIEW: 'Why is it vibrating?'",
        "FACT: The Queen combs her corgis daily.",
        "REVIEW: 'Good for scraping toast.'",
        "FACT: Combs are 90% air.",
        "REVIEW: 'Heavier than it looks.'",
        "FACT: Never lend a comb to a ghost.",
        "REVIEW: 'It glows in the dark. Helpful.'",
        "FACT: Combs can survive a nuclear blast.",
        "REVIEW: 'My dog hates it.'",
        "FACT: The word 'Comb' is 4 letters long.",
        "REVIEW: 'I ordered a brush. This is a comb.'",
        "FACT: Combs amplify silence.",
        "REVIEW: 'Works on llamas.'",
        "FACT: There is no such thing as a left-handed comb.",
        "REVIEW: 'I am left handed. It exploded.'",
        "FACT: Combs are magnetic to socks.",
        "REVIEW: 'Found in my soup.'",
        "FACT: A comb is a ladder for fleas.",
        "REVIEW: 'Too extravagant.'",
        "FACT: Combs are allergic to jazz.",
        "REVIEW: 'It sings.'",
        "FACT: A comb is just a skeleton of a brush.",
        "REVIEW: 'Too boney.'",
        "FACT: Combs hate water.",
        "REVIEW: 'It sank.'",
        "FACT: Every comb has a name.",
        "REVIEW: 'Mine is called Steve.'",
        "FACT: Combs can feel love.",
        "REVIEW: 'It judged me.'",
        "FACT: A comb is a mirror for hair.",
        "REVIEW: 'Too reflective.'",
        "FACT: Combs are older than time.",
        "REVIEW: 'Dusty.'",
        "FACT: A comb is a key to a lock of hair.",
        "REVIEW: 'Did not unlock my door.'",
        "FACT: Combs are strictly non-edible.",
        "REVIEW: 'Crunchy.'",
        "FACT: A comb is a saw for air.",
        "REVIEW: 'Too sharp.'"
    ];

    // WIN PHRASES
    const ADJECTIVES = ["Lethal", "Silent", "Phantom", "Shadow", "Iron", "Cold", "Patient", "Surgical", "Ghost", "Vengeful", "Invisible", "Swift", "Precise", "Deadly", "Golden", "Silver", "Ruthless", "Calm"];
    const NOUNS = ["Assassin", "Spirit", "Agent", "Hunter", "Spectre", "Wolf", "Eagle", "Viper", "Operator", "Sniper", "Watchman", "Sentinel", "Wraith", "Reaper", "Soldier", "Professional"];
    const WIN_TITLES = ["LEGENDARY", "STUNNING", "CLINICAL", "EXEMPLARY", "GODLIKE", "PERFECT", "FLAWLESS", "MASTERFUL", "ELITE"];

    const C = {
        sky: 0x88CCFF, floor: 0x999999, platform: 0x333333,
        clothes: [0x111111, 0x222222, 0x001133, 0x332211, 0xDDDDDD],
        spyColor: 0x777777, workerColor: 0xFFFF00,
        packageColor: 0xCCFF00, trainColors: [0xEEEEEE, 0x444444, 0x003366]
    };

    let scene, camera, renderer, raycaster;
    let clock = new THREE.Clock();
    
    // States: MENU, READY_CHECK, MINGLE, RUSH, BLEEDING, INPUT_SCORE, SCREEN_EFFECT, ENDED
    let gameState = 'MENU'; 
    let gameMode = 'STREAK'; 
    let gameTime = 0;
    let bleedTimer = 0;
    
    // Timed Mode Logic
    let timerRunning = false;
    let timerStartTime = 0;
    let finalTime = 0;
    
    // Objects
    let civilians = [];
    let bullets = [];
    let bloodPuddles = [];
    let pigeons = [];
    let confetti = [];
    let particles = []; 
    let looseItems = [];
    let statuePos = null; 
    let jamboni = null; // The cleaner vehicle
    let shopStaff = []; // The shopkeepers
    
    // Logic
    let targetObj = null; 
    let targetTown = "";
    let targetPlatform = -1; 
    let isInitializing = false; // Prevent double init
    let boardDataGenerated = false; // Prevent board redraw loop
    
    let boardCanvas, boardCtx, boardTexture;
    let nextPigeonTime = 5;
    let stripeTexture;
    let marbleTexture; // Light grey marble texture
    let bloodSpawned = false;
    let obstacles = []; // Global obstacles for collision

    // New Arrays for Train Sequence
    let trains = [];
    let newsTickerOffset = 0;
    let newsTickerActive = false;
    let trainsDeparted = false; // State flag
    let tickerContent = ""; // Dynamic content

    // Settings & Persistence
    let SETTING_CROWD = 80;
    let SETTING_PACKAGES = 4;
    let KILL_STREAK = 0;
    let LEADERBOARD = []; 
    
    let SETTING_MUSIC_ON = true;
    let SETTING_SFX_ON = true;
    // UPDATED DEFAULTS handled in loadSettings
    let SETTING_MUSIC_VOL = 0.3;
    let SETTING_SFX_VOL = 0.8;
    let SETTING_MENU_VOL = 0.5;
    let SETTING_RANDOM_PL = false;
    
    let STATS = { target:0, decoy:0, civ:0, abort:0 };

    // Audio Globals
    let currentMusicIdx = 0;
    let activeMusicAudio = null;
    let fadeInterval = null;
    let menuMusicStarted = false;
    
    let sfxStartTimeout = null;
    let musicStartTimeout = null;

    let resultIsWin = false;
    let resultReason = "";
    let victimRef = null;

    let isZoomed = false;
    let pitch = -0.4, yaw = 0;
    const keyState = {};

    function loadSettings() {
        if(localStorage.getItem('sm_crowd')) SETTING_CROWD = parseInt(localStorage.getItem('sm_crowd'));
        if(localStorage.getItem('sm_pkg')) SETTING_PACKAGES = parseInt(localStorage.getItem('sm_pkg'));
        if(localStorage.getItem('sm_streak')) KILL_STREAK = parseInt(localStorage.getItem('sm_streak'));
        if(localStorage.getItem('sm_leaderboard')) {
            try { 
                let raw = JSON.parse(localStorage.getItem('sm_leaderboard'));
                if(raw.length > 0 && typeof raw[0] === 'number') {
                    LEADERBOARD = raw.map(t => ({name: 'AGT', time: t}));
                } else {
                    LEADERBOARD = raw;
                }
            } catch(e){ LEADERBOARD=[]; }
        }
        if(localStorage.getItem('sm_stats')) {
            try { STATS = JSON.parse(localStorage.getItem('sm_stats')); } catch(e){ STATS={target:0, decoy:0, civ:0, abort:0}; }
        }
        
        if(localStorage.getItem('sm_music_on') !== null) SETTING_MUSIC_ON = (localStorage.getItem('sm_music_on') === 'true');
        if(localStorage.getItem('sm_sfx_on') !== null) SETTING_SFX_ON = (localStorage.getItem('sm_sfx_on') === 'true');
        if(localStorage.getItem('sm_random_pl') !== null) SETTING_RANDOM_PL = (localStorage.getItem('sm_random_pl') === 'true');
        
        // NEW DEFAULT VOLUME LOGIC (80% SFX, 30% Music if not set)
        if(localStorage.getItem('sm_music_vol')) {
            SETTING_MUSIC_VOL = parseFloat(localStorage.getItem('sm_music_vol'));
        } else {
            SETTING_MUSIC_VOL = 0.3;
        }

        if(localStorage.getItem('sm_sfx_vol')) {
            SETTING_SFX_VOL = parseFloat(localStorage.getItem('sm_sfx_vol'));
        } else {
            SETTING_SFX_VOL = 0.8;
        }

        if(localStorage.getItem('sm_menu_vol')) SETTING_MENU_VOL = parseFloat(localStorage.getItem('sm_menu_vol'));

        document.getElementById('slide-crowd').value = SETTING_CROWD;
        document.getElementById('slide-pkg').value = SETTING_PACKAGES;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        document.getElementById('streak-display').innerText = KILL_STREAK;
        document.getElementById('chk-music').checked = SETTING_MUSIC_ON;
        document.getElementById('chk-sfx').checked = SETTING_SFX_ON;
        document.getElementById('chk-random-pl').checked = SETTING_RANDOM_PL;
        document.getElementById('vol-music-slider').value = SETTING_MUSIC_VOL;
        document.getElementById('vol-sfx-slider').value = SETTING_SFX_VOL;
        document.getElementById('slide-menu-vol').value = SETTING_MENU_VOL;

        updateMenuVisuals();
        renderLeaderboard();
        renderStats();
    }

    function renderLeaderboard() {
        const lbDiv = document.getElementById('lb-content');
        lbDiv.innerHTML = '';
        const sorted = LEADERBOARD.sort((a,b) => a.time - b.time).slice(0, 5);
        for(let i=0; i<5; i++) {
            const entry = sorted[i];
            const timeStr = entry ? entry.time.toFixed(3) + "s" : "---";
            const nameStr = entry ? entry.name : "---";
            const row = document.createElement('div');
            row.className = 'lb-row';
            row.innerHTML = `<span class="lb-rank">${i+1}.</span> <span class="lb-name">${nameStr}</span> <span class="lb-time">${timeStr}</span>`;
            lbDiv.appendChild(row);
        }
    }

    function renderStats() {
        document.getElementById('stat-target').innerText = STATS.target;
        document.getElementById('stat-decoy').innerText = STATS.decoy;
        document.getElementById('stat-civ').innerText = STATS.civ;
        document.getElementById('stat-abort').innerText = STATS.abort;
    }

    function updateMenuVisuals() {
        const container = document.getElementById('chalk-outlines');
        container.innerHTML = '';
        const count = Math.min(KILL_STREAK, 20); 
        for(let i=0; i<count; i++) {
            const el = document.createElement('div');
            el.className = 'chalk-body';
            el.style.left = (Math.random() * 90) + '%';
            el.style.top = (Math.random() * 80) + '%';
            el.style.transform = `rotate(${Math.random()*360}deg) scale(${0.5 + Math.random()*0.5})`;
            container.appendChild(el);
        }
    }

    function saveSettings() {
        localStorage.setItem('sm_crowd', SETTING_CROWD);
        localStorage.setItem('sm_pkg', SETTING_PACKAGES);
        localStorage.setItem('sm_streak', KILL_STREAK);
        localStorage.setItem('sm_leaderboard', JSON.stringify(LEADERBOARD));
        localStorage.setItem('sm_stats', JSON.stringify(STATS));
        localStorage.setItem('sm_music_on', SETTING_MUSIC_ON);
        localStorage.setItem('sm_sfx_on', SETTING_SFX_ON);
        localStorage.setItem('sm_random_pl', SETTING_RANDOM_PL);
        localStorage.setItem('sm_music_vol', SETTING_MUSIC_VOL);
        localStorage.setItem('sm_sfx_vol', SETTING_SFX_VOL);
        localStorage.setItem('sm_menu_vol', SETTING_MENU_VOL);
    }

    function resetAllData() {
        // Show Custom Modal instead of window.confirm
        document.getElementById('confirm-modal').style.display = 'flex';
    }
    
    function closeConfirm() {
        document.getElementById('confirm-modal').style.display = 'none';
    }
    
    function performReset() {
        LEADERBOARD = [];
        STATS = { target:0, decoy:0, civ:0, abort:0 };
        KILL_STREAK = 0;
        saveSettings();
        loadSettings();
        closeConfirm();
    }

    function setDifficulty(level) {
        if(level === 'EASY') { SETTING_CROWD = 134; SETTING_PACKAGES = 2; }
        else if(level === 'MEDIUM') { SETTING_CROWD = 227; SETTING_PACKAGES = 17; }
        else if(level === 'HARD') { SETTING_CROWD = 420; SETTING_PACKAGES = 70; }
        document.getElementById('slide-crowd').value = SETTING_CROWD;
        document.getElementById('slide-pkg').value = SETTING_PACKAGES;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        saveSettings();
    }

    function updateUI() {
        SETTING_CROWD = document.getElementById('slide-crowd').value;
        SETTING_PACKAGES = document.getElementById('slide-pkg').value;
        SETTING_MUSIC_ON = document.getElementById('chk-music').checked;
        SETTING_SFX_ON = document.getElementById('chk-sfx').checked;
        SETTING_RANDOM_PL = document.getElementById('chk-random-pl').checked;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        saveSettings(); 
    }

    function updateMenuVol() {
        SETTING_MENU_VOL = parseFloat(document.getElementById('slide-menu-vol').value);
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) menuBgm.volume = SETTING_MENU_VOL;
        saveSettings();
    }

    function generateCodeName() {
        const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
        const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
        return `"${adj} ${noun}"`;
    }

    function toggleTopUI() {
        const ui = document.getElementById('top-ui-container');
        const icon = document.getElementById('toggle-icon');
        const text = document.getElementById('toggle-text');
        ui.classList.toggle('minimized');
        const isMin = ui.classList.contains('minimized');
        icon.innerText = isMin ? '^' : 'v';
        text.innerText = isMin ? 'OPEN MENU' : 'HIDE MENU';
    }

    // --- AUDIO SYSTEM ---

    function startMenuMusicTimer() {
        const seenIntro = sessionStorage.getItem('sm_intro_seen');
        if(seenIntro) {
            document.getElementById('intro-splash').style.display = 'none';
            // NEW: Instead of auto-playing (which browsers block on reload), show return overlay
            document.getElementById('return-overlay').style.display = 'flex';
        }
    }

    // NEW: Handle return click to start music
    function confirmReturn() {
        document.getElementById('return-overlay').style.display = 'none';
        
        if(gameState === 'MENU' && !menuMusicStarted) {
            const menuBgm = document.getElementById('menu-bgm');
            menuBgm.currentTime = Math.random() * 60; 
            menuBgm.volume = 0;
            menuBgm.play().then(() => {
                menuMusicStarted = true;
                fadeInAudio(menuBgm, SETTING_MENU_VOL, 3000);
            }).catch(e=>console.log("Menu music fail",e));
        }
    }

    function enterGame() {
        sessionStorage.setItem('sm_intro_seen', 'true');
        const splash = document.getElementById('intro-splash');
        splash.style.opacity = '0';
        setTimeout(() => splash.style.display = 'none', 2000);
        const menuBgm = document.getElementById('menu-bgm');
        menuBgm.currentTime = 0;
        menuBgm.volume = 0;
        menuBgm.play().then(() => {
            menuMusicStarted = true;
            fadeInAudio(menuBgm, SETTING_MENU_VOL, 3000);
        });
    }

    function initiateGame(mode, btn) {
        if(isInitializing) return; // Prevent double trigger
        isInitializing = true;

        if(btn) {
            btn.classList.add('clicked');
            btn.innerHTML = '<div class="spinner"></div>';
        }
        
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) {
            fadeOutAudio(menuBgm, 2800, () => {
                menuBgm.pause();
                menuMusicStarted = false;
            });
        }
        
        // Wait for fade then show Ready Screen
        setTimeout(() => {
            prepareGameEnv(mode);
        }, 3000);
    }

    function reloadWithFade() {
        if(activeMusicAudio && !activeMusicAudio.paused) fadeOutAudio(activeMusicAudio, 1700, null);
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) fadeOutAudio(menuBgm, 1700, null);
        setTimeout(() => location.reload(), 1700);
    }

    function playMusic() {
        if(!SETTING_MUSIC_ON) return;
        
        if(activeMusicAudio) {
            activeMusicAudio.pause();
            activeMusicAudio.src = ""; // Clean ref
            activeMusicAudio = null;
        }

        let idx = 0;
        if(SETTING_RANDOM_PL) idx = Math.floor(Math.random() * MUSIC_TRACKS.length);
        else idx = currentMusicIdx % MUSIC_TRACKS.length;
        currentMusicIdx = idx;

        const trackName = MUSIC_TRACKS[idx];
        activeMusicAudio = new Audio(trackName);
        activeMusicAudio.loop = true;
        
        // Random start time logic
        activeMusicAudio.addEventListener('loadedmetadata', () => {
             const dur = activeMusicAudio.duration || 100;
             activeMusicAudio.currentTime = Math.random() * (Math.min(dur, 60)); 
        });
        
        activeMusicAudio.volume = 0; 
        activeMusicAudio.play().then(() => {
            fadeInAudio(activeMusicAudio, SETTING_MUSIC_VOL, 4000);
        }).catch(e => console.log("Music failed to play", e));
    }

    function nextTrack() {
        if(!activeMusicAudio) return;
        currentMusicIdx++;
        playMusic();
    }

    function fadeInAudio(audioEl, targetVol, duration) {
        if(fadeInterval) clearInterval(fadeInterval);
        const stepTime = 100;
        const stepVol = targetVol / (duration / stepTime);
        const fInt = setInterval(() => {
            if(!audioEl || audioEl.paused) { clearInterval(fInt); return; }
            let newVol = audioEl.volume + stepVol;
            if(newVol >= targetVol) { newVol = targetVol; clearInterval(fInt); }
            audioEl.volume = newVol;
        }, stepTime);
    }

    function fadeOutAudio(audioEl, duration, callback) {
        const stepTime = 50;
        const startVol = audioEl.volume;
        const stepVol = startVol / (duration / stepTime);
        const fInt = setInterval(() => {
            if(!audioEl) { clearInterval(fInt); return; }
            let newVol = audioEl.volume - stepVol;
            if(newVol <= 0) {
                newVol = 0; audioEl.volume = 0; clearInterval(fInt);
                if(callback) callback();
            } else { audioEl.volume = newVol; }
        }, stepTime);
    }

    // --- MATRIX EFFECT ---
    const matCanvas = document.getElementById('matrix-canvas');
    const matCtx = matCanvas.getContext('2d');
    const matrixWords = ["SNIPER", "YELLOW", "PACKAGE", "COURIER", "FLOWERS", "PLATFORM", "HASTINGS", "DISAVOW", "TERMINUS", "WATCHMAN", "TARGET", "DECOY", "BYSTANDER", "MISSION", "INTEL", "BOARD", "TRAIN", "DEPARTURE", "STATION", "PROTOCOL", "SILENCER", "SCOPE", "ZOOM", "VELOCITY", "AGENT", "SUSPECT", "IDENTIFY", "ELIMINATE", "CLEARED", "FAILED", "ABORT", "TIME", "SPEED", "RECORD", "NORTHERN", "SOUTHERN", "RAIL", "TICKET", "GATE", "LUGGAGE", "BRIEFCASE"];
    let matColumns = [];
    const matFontSize = 12;

    function initMatrix() {
        matCanvas.width = window.innerWidth;
        matCanvas.height = window.innerHeight;
        const colCount = Math.floor(matCanvas.width / matFontSize);
        matColumns = [];
        for(let x=0; x<colCount; x++) {
            matColumns.push({ y: Math.random() * matCanvas.height, word: matrixWords[Math.floor(Math.random() * matrixWords.length)], wordIdx: 0, speed: 1 + Math.random() * 2 });
        }
    }

    function drawMatrix() {
        if(gameState !== 'MENU' && gameState !== 'ENDED') return;
        
        // Slower background if ENDED screen
        const bgSpeedMult = (gameState === 'ENDED') ? 0.85 : 1.0;

        matCtx.fillStyle = 'rgba(0, 0, 0, 0.08)'; matCtx.fillRect(0, 0, matCanvas.width, matCanvas.height);
        matCtx.font = matFontSize + 'px monospace';
        for(let i=0; i<matColumns.length; i++) {
            const col = matColumns[i];
            const shade = Math.floor(50 + Math.random() * 200);
            matCtx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
            const char = col.word[col.wordIdx % col.word.length];
            matCtx.fillText(char, i * matFontSize, col.y);
            col.y += (col.speed * bgSpeedMult); // Apply speed mult
            if(Math.floor(col.y) % 20 < 2) col.wordIdx++;
            if(col.y > matCanvas.height && Math.random() > 0.98) {
                col.y = 0; col.wordIdx = 0; col.word = matrixWords[Math.floor(Math.random() * matrixWords.length)];
            }
        }
    }

    // --- THREE JS INIT ---
    function init() {
        loadSettings();
        startMenuMusicTimer();
        initMatrix();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x111111, 0.002);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
        camera.position.set(0, 50, 130);
        camera.rotation.order = "YXZ";

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();

        const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
        const sun = new THREE.SpotLight(0xffddaa, 1.5);
        sun.position.set(50, 150, 50); sun.angle = 0.8; sun.penumbra = 0.5; sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        stripeTexture = createStripeTexture();
        marbleTexture = createMarbleTexture();
        buildStation();

        document.getElementById('hs-input').addEventListener('keydown', function(e) {
            if(e.key === 'Enter') submitScore();
        });

        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));
        window.addEventListener('resize', onResize);

        const sliderMusic = document.getElementById('vol-music-slider');
        sliderMusic.addEventListener('input', function() { 
            SETTING_MUSIC_VOL = parseFloat(this.value); 
            if(activeMusicAudio) activeMusicAudio.volume = SETTING_MUSIC_VOL;
            saveSettings(); 
        });

        const sliderSFX = document.getElementById('vol-sfx-slider');
        const sfx = document.getElementById('sfx-ambience');
        sliderSFX.addEventListener('input', function() { 
            SETTING_SFX_VOL = parseFloat(this.value);
            sfx.volume = SETTING_SFX_VOL;
            saveSettings(); 
        });

        animate();
    }

    function handleKey(e, isDown) {
        // Prevent default browser actions for game keys to avoid scrolling/interactions
        if(isDown && (e.code === 'Space' || e.code === 'KeyF' || e.code === 'Enter')) {
            // e.preventDefault(); // Optional, but good for Space (scrolling)
        }

        const key = e.key.toLowerCase();
        keyState[key] = isDown; 
        keyState[e.code] = isDown;
        
        if(isDown && (gameState === 'MINGLE' || gameState === 'RUSH')) {
            if(e.code === 'Space') toggleZoom();
            // FIX: Check for 'f' OR 'F' via toLowerCase, or use e.code 'KeyF'
            if(key === 'f' || e.code === 'KeyF' || e.code === 'Enter') fire();
        }
    }

    function createStripeTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFD700'; ctx.fillRect(0,0,64,64);
        ctx.fillStyle = '#000000';
        for(let i=0; i<64; i+=8) ctx.fillRect(0, i, 64, 4);
        return new THREE.CanvasTexture(canvas);
    }
    
    function createCrossHatchTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Base: Grey/Metallic
        ctx.fillStyle = '#99AAAA'; 
        ctx.fillRect(0,0,256,256);
        
        ctx.strokeStyle = '#667788';
        ctx.lineWidth = 4;
        
        // Diagonals 1
        for(let i=-256; i<512; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i+256, 256);
            ctx.stroke();
        }
        
        // Diagonals 2
        for(let i=-256; i<512; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i, 256);
            ctx.lineTo(i+256, 0);
            ctx.stroke();
        }
        
        // Subtle variations
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        for(let i=0; i<10; i++) {
            ctx.fillRect(Math.random()*200, Math.random()*200, 50, 50);
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    function createMarbleTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        // Base light grey - LIGHTER NOW
        ctx.fillStyle = '#F0F0F0'; 
        ctx.fillRect(0,0,256,256);
        // Veins
        ctx.strokeStyle = '#CCCCCC'; 
        ctx.lineWidth = 2;
        for(let i=0; i<20; i++) {
            ctx.beginPath(); 
            ctx.moveTo(Math.random()*256, Math.random()*256);
            ctx.bezierCurveTo(Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(canvas);
    }

    function createGratedTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#445566'; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = '#000000';
        for(let i=0; i<512; i+=32) ctx.fillRect(i, 0, 8, 512); 
        for(let i=0; i<512; i+=32) ctx.fillRect(0, i, 512, 8); 
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 4); 
        return tex;
    }

    function createBlock(w, h, d, col, x, y, z, parent, tex) {
        const mat = tex ? new THREE.MeshLambertMaterial({map: tex, transparent:true}) : new THREE.MeshLambertMaterial({color: col});
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
        mesh.position.set(x,y,z); mesh.castShadow = true; mesh.receiveShadow = true;
        if(parent) parent.add(mesh); else scene.add(mesh);
        return mesh;
    }
    
    function createShrub(x, z) {
        const grp = new THREE.Group();
        grp.position.set(x, 0, z);
        
        // Pot
        const potGeo = new THREE.CylinderGeometry(2.5, 2, 3, 16);
        const pot = new THREE.Mesh(potGeo, new THREE.MeshLambertMaterial({color: 0x8B4513})); // Brown
        pot.position.y = 1.5;
        grp.add(pot);
        
        // Plant
        const isTree = Math.random() > 0.5;
        if (isTree) {
            // Small Tree
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 6, 8), new THREE.MeshLambertMaterial({color: 0x553311}));
            trunk.position.y = 4.5;
            grp.add(trunk);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(3.5), new THREE.MeshLambertMaterial({color: 0x228B22}));
            leaves.position.y = 8;
            grp.add(leaves);
        } else {
            // Bush
            const bush = new THREE.Mesh(new THREE.DodecahedronGeometry(3), new THREE.MeshLambertMaterial({color: 0x006400}));
            bush.position.y = 3.5;
            grp.add(bush);
        }
        
        // Add obstacle so people walk around it
        obstacles.push({x: x, z: z, r: 3.5});
        scene.add(grp);
    }

    function createEnvironment() {
        const grassGeo = new THREE.PlaneGeometry(800, 800);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x1a2e12 }); 
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2; grass.position.set(0, -3.0, -200); grass.receiveShadow = true; scene.add(grass);
        for(let i = 0; i < 60; i++) {
            const treeGroup = new THREE.Group();
            const tx = (Math.random() - 0.5) * 600; const tz = -180 - (Math.random() * 300); 
            const trunkH = 5 + Math.random() * 5;
            createBlock(1.5, trunkH, 1.5, 0x3d2817, 0, trunkH/2, 0, treeGroup);
            const leavesH = 10 + Math.random() * 10;
            const leafGeo = new THREE.ConeGeometry(4 + Math.random()*3, leavesH, 8);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x0f2e0f }); 
            const leaves = new THREE.Mesh(leafGeo, leafMat);
            leaves.position.set(0, trunkH + (leavesH/2) - 1, 0); leaves.castShadow = true; treeGroup.add(leaves);
            treeGroup.position.set(tx, -2.5, tz); scene.add(treeGroup);
        }
    }

    function buildStation() {
        createEnvironment();
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d'); ctx.fillStyle = '#999'; ctx.fillRect(0,0,512,512);
        for(let i=0;i<8000;i++){ctx.fillStyle=Math.random()>0.5?'#777':'#BBB';ctx.fillRect(Math.random()*512,Math.random()*512,2,2);}
        const floorTex = new THREE.CanvasTexture(canvas); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(12,8);
        
        createBlock(450, 1, 150, null, 0, -0.5, 50, null, floorTex);
        createBlock(450, 1, 300, 0x111111, 0, -2.0, -175);
        
        // DECORATIVE WALLS (Half Circles at Ends)
        const wallTex = createCrossHatchTexture(); // UPDATED TEXTURE
        const wallMat = new THREE.MeshLambertMaterial({map: wallTex, side: THREE.DoubleSide});
        const wallGeo = new THREE.CircleGeometry(75, 32, 0, Math.PI); // Top half
        
        // Left End (-225)
        const wallL = new THREE.Mesh(wallGeo, wallMat);
        wallL.position.set(-225, 0, 50); // Center of floor depth roughly
        wallL.rotation.y = Math.PI / 2;
        scene.add(wallL);
        
        // Right End (225)
        const wallR = new THREE.Mesh(wallGeo, wallMat);
        wallR.position.set(225, 0, 50);
        wallR.rotation.y = -Math.PI / 2;
        scene.add(wallR);
        
        // SHRUBS (4 Corners)
        createShrub(-210, -10);
        createShrub(210, -10);
        createShrub(-210, 110);
        createShrub(210, 110);

        for(let i=0; i<6; i++) {
            const x = -100 + (i * 40);
            // PLATFORM
            createBlock(20, 2, 250, C.platform, x, -1.0, -150);
            // RAILS
            createBlock(1, 0.2, 250, 0x555555, x - 14, -1.9, -150); 
            createBlock(1, 0.2, 250, 0x555555, x - 18, -1.9, -150);
            
            // LADDER TRACKS (Sleepers)
            const sleeperGroup = new THREE.Group();
            for(let j=0; j<100; j++) { // Many sleepers
                createBlock(6, 0.1, 0.5, 0x221100, x - 16, -2.0, -25 - (j * 2.5), sleeperGroup);
            }
            scene.add(sleeperGroup);
            
            // TRAINS ARE NOW SPAWNED DYNAMICALLY IN spawnTrains() TO FIX RESET BUG
            
            const sCanvas = document.createElement('canvas'); sCanvas.width=128; sCanvas.height=128;
            const sCtx = sCanvas.getContext('2d'); sCtx.fillStyle='#222'; sCtx.fillRect(0,0,128,128);
            sCtx.strokeStyle='#FFD700'; sCtx.lineWidth=6; sCtx.strokeRect(5,5,118,118);
            sCtx.fillStyle='#FFF'; sCtx.font='bold 80px "Courier Prime"'; sCtx.textAlign='center'; sCtx.textBaseline='middle'; sCtx.fillText(i+1,64,68);
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(sCanvas)}));
            sign.position.set(x, 8, -24.8); scene.add(sign); 
            createBlock(0.5, 8, 0.5, 0x111111, x, 4, -25.5);
            for(let zP = -100; zP > -250; zP -= 60) createBlock(4, 60, 4, 0x333333, x, 30, zP);
        }

        createGenericShop(160, 40, "WHSmiffs", 0x707070); 
        createGenericShop(160, 10, "SHOES", 0x808080);
        createGenericShop(100, 80, "VAPES", 0x606060);
        createGenericShop(-160, 40, "NAILS", 0x757575);
        createGenericShop(-160, 10, "EAT", 0x666666); 
        createGenericShop(-100, 80, "Nice:Clothes", 0x555555);
        createGenericShop(160, -20, "COMBS", 0x777777);
        
        // --- NEW FENCES LOGIC: PERPENDICULAR BETWEEN PLATFORMS ---
        const gaps = [
            {s: -200, e: -110}, // Left of Plat 1
            {s: -90, e: -70},   // Between 1 & 2
            {s: -50, e: -30},   // Between 2 & 3
            {s: -10, e: 10},    // Between 3 & 4
            {s: 30, e: 50},     // Between 4 & 5
            {s: 70, e: 90},     // Between 5 & 6
            {s: 110, e: 200}    // Right of Plat 6
        ];
        
        gaps.forEach(g => {
            createPerpendicularFence(-25, g.s, g.e);
        });

        createBlock(400, 5, 10, 0x222222, 0, 40, -180); 
        createBlock(400, 1, 1, 0xff0000, 0, 43, -175); 

        const roofGeo = new THREE.CylinderGeometry(180, 180, 600, 32, 1, true, 0, Math.PI);
        const roofTex = createGratedTexture();
        const roofMat = new THREE.MeshBasicMaterial({ map: roofTex, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const roof = new THREE.Mesh(roofGeo, roofMat); roof.rotation.z = Math.PI / 2; roof.position.set(0, 90, -50); scene.add(roof);

        const boardGroup = new THREE.Group(); boardGroup.position.set(0, 25, -25);
        createBlock(140, 20, 2, 0x111111, 0, 0, 0, boardGroup);
        boardCanvas = document.createElement('canvas'); boardCanvas.width = 1024; boardCanvas.height = 256;
        boardCtx = boardCanvas.getContext('2d'); drawBoard(["SYSTEM BOOT..."]);
        boardTexture = new THREE.CanvasTexture(boardCanvas);
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(130, 16), new THREE.MeshBasicMaterial({map: boardTexture}));
        screen.position.set(0, 0, 1.1); boardGroup.add(screen); scene.add(boardGroup);
    }
    
    // --- CREATE PERPENDICULAR FENCE HELPER ---
    // Fence runs along X axis at a specific Z
    function createPerpendicularFence(z, xStart, xEnd) {
        const group = new THREE.Group();
        const length = Math.abs(xEnd - xStart);
        const centerX = (xStart + xEnd) / 2;
        const segmentLen = 10;
        const count = Math.floor(length / segmentLen);
        
        // Height 2.0 (Twice previous 1.0)
        // Top Rail (Y=1.8)
        createBlock(length, 0.2, 0.5, 0xAAAAAA, centerX, 1.8, z, group);
        // Mid Rail (Y=1.0)
        createBlock(length, 0.2, 0.5, 0xAAAAAA, centerX, 1.0, z, group);
        
        // Posts
        for(let i=0; i<=count; i++) {
            const x = xStart + (i * segmentLen);
            // Don't place post if it exceeds xEnd slightly due to rounding
            if(x > xEnd + 0.1) continue;
            createBlock(0.5, 2.0, 0.5, 0x888888, x, 1.0, z, group);
        }
        
        scene.add(group);
    }

    function createTrain(x, y, zStart, parent, color) {
        const col = color || C.trainColors[Math.floor(Math.random() * C.trainColors.length)];
        for(let i=0; i<5; i++) {
            const z = zStart - (i * 24);
            const car = new THREE.Group(); car.position.set(x, y + 2.5, z);
            
            createBlock(3.8, 4.5, 22, col, 0, 0, 0, car);
            
            createBlock(3.9, 1.5, 20, 0x222222, 0, 0.5, 0, car); 
            createBlock(0.2, 3, 2, 0x000000, 2, -0.5, 5, car); 
            parent.add(car);
        }
    }

    // Helper to get skin color
    function getRandomSkinColor() {
        // SKIN COLOR LOGIC
        let skinCol = 0xFFCCAA; // Default
        const whiteChance = 0.58 + (Math.random() * (0.81 - 0.58)); // 58% to 81% chance
        if(Math.random() < whiteChance) {
            skinCol = Math.random() > 0.5 ? 0xFFCCAA : 0xF5D0B0;
        } else {
            // Brown, Light Brown, Light Black, Dark Black
            const skins = [0xD2A679, 0xB07E55, 0x8D5524, 0x5C3836, 0x3B2319];
            skinCol = skins[Math.floor(Math.random() * skins.length)];
        }
        return skinCol;
    }

    function createGenericShop(x, z, text, greyCol) {
        const s = new THREE.Group(); s.position.set(x, 0, z);

        if (text === "VAPES") {
            // Walk-in Marquee Style
            
            // 4 Corner Columns
            const colW = 1.5; const colH = 15;
            createBlock(colW, colH, colW, greyCol, -11.5, 7.5, -11.5, s); // Back Left
            createBlock(colW, colH, colW, greyCol, 11.5, 7.5, -11.5, s);  // Back Right
            createBlock(colW, colH, colW, greyCol, -11.5, 7.5, 11.5, s);  // Front Left
            createBlock(colW, colH, colW, greyCol, 11.5, 7.5, 11.5, s);   // Front Right
            
            // Roof
            createBlock(26, 6, 26, greyCol, 0, 13, 0, s);
            
            // --- UPDATED VAPE SHOP COUNTER ---
            const dW = 9.8; 
            const dH = 1.82; 
            const dThick = 1;
            const yPos = dH / 2;
            const brightWhite = 0xFFFFFF; // Use white to let texture shine brightest
            
            // Front bar
            createBlock(dW, dH, dThick, brightWhite, 0, yPos, 2.5, s, marbleTexture);
            // Back bar
            createBlock(dW, dH, dThick, brightWhite, 0, yPos, -2.5, s, marbleTexture);
            // Left bar
            createBlock(dThick, dH, 4, brightWhite, -4.4, yPos, 0, s, marbleTexture); // Offset X to half of 9.8 approx (4.9 minus padding)
            // Right bar
            createBlock(dThick, dH, 4, brightWhite, 4.4, yPos, 0, s, marbleTexture);
            
            // ADD OBSTACLE FOR COLLISION
            obstacles.push({x: x, z: z, r: 8.0}); // Radius 8 for slightly safer boundary

            // Shopkeeper INSIDE the counter (Center)
            // UPDATED: Full body person logic
            const staffGrp = new THREE.Group();
            staffGrp.position.set(0, 0, 0); 
            // SPECIAL NAME FOR SHOOTABLE CHECK
            staffGrp.name = "PERSON_ROOT";
            
            // Random Pink/Purple Shirt
            const shirtCols = [0xFFC0CB, 0xFF69B4, 0x800080, 0x9370DB, 0xDA70D6];
            const shirtCol = shirtCols[Math.floor(Math.random() * shirtCols.length)];
            const skinCol = getRandomSkinColor();

            // Legs (Relative to group center 0,0,0)
            // Group will be raised to stand on floor.
            // Legs: x=+/-0.2, y=0.8, z=0
            createBlock(0.25, 1.6, 0.25, 0x111111, -0.2, 0.8, 0, staffGrp); // Left Leg
            createBlock(0.25, 1.6, 0.25, 0x111111, 0.2, 0.8, 0, staffGrp); // Right Leg
            
            // Body (Shirt)
            createBlock(0.9, 1.4, 0.5, shirtCol, 0, 2.2, 0, staffGrp); 
            
            // Arms
            createBlock(0.25, 1.3, 0.25, shirtCol, -0.6, 2.2, 0, staffGrp); // Left Arm
            createBlock(0.25, 1.3, 0.25, shirtCol, 0.6, 2.2, 0, staffGrp); // Right Arm

            // Head
            createBlock(0.5, 0.6, 0.5, skinCol, 0, 3.2, 0, staffGrp); 
            
            // Add to scene (Group sits at y=0 local, so legs touch y=0)
            s.add(staffGrp);
            
            shopStaff.push({
                mesh: staffGrp,
                basePos: staffGrp.position.clone(),
                timer: 0,
                targetRot: Math.random() * Math.PI * 2,
                interval: 15 + Math.random() * 10, // 15-25 seconds rotation
                swayTimer: 0,
                vapeTimer: 0,
                // Start random 3-8s, then switch to long interval
                vapeInterval: 3 + Math.random() * 5 
            });
            
        } else {
            // Standard Block Shop 
            createBlock(25, 15, 25, greyCol, 0, 7.5, 0, s); 
        }

        // SIGN GENERATION
        let bgCol = '#444';
        if(text === "EAT") bgCol = '#006600'; if(text === "WHSmiffs") bgCol = '#003399'; 
        
        const canvas=document.createElement('canvas');canvas.width=256;canvas.height=64;const ctx=canvas.getContext('2d');
        ctx.fillStyle=bgCol;ctx.fillRect(0,0,256,64);ctx.fillStyle='#FFF';ctx.font='bold 30px Arial';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(text,128,32);
        const signTex = new THREE.CanvasTexture(canvas);

        if (text === "VAPES" || text === "Nice:Clothes") {
            // SIGN ON ALL 4 SIDES
            const offsets = [
                { pos: new THREE.Vector3(0, 12, 13.1), rot: 0 },          // Front (Z+)
                { pos: new THREE.Vector3(0, 12, -13.1), rot: Math.PI },   // Back (Z-)
                { pos: new THREE.Vector3(-13.1, 12, 0), rot: -Math.PI/2 },// Left (X-)
                { pos: new THREE.Vector3(13.1, 12, 0), rot: Math.PI/2 }   // Right (X+)
            ];
            
            offsets.forEach(off => {
                const sign = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
                sign.position.copy(off.pos);
                sign.rotation.y = off.rot;
                // For "Nice:Clothes" extra height adjustment if needed, but 12 is fine standard
                s.add(sign);
            });

        } else {
            // Standard Sign Placement (Side Facing)
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
            sign.position.set(x>0?-13.1:13.1, 12, 0); 
            sign.rotation.y = x>0?-Math.PI/2:Math.PI/2; 
            s.add(sign); 
            
            // WHSmiffs EXTRA SIGN
            if(text === "WHSmiffs") {
                const sign2 = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
                // Face Positive Z (Towards Sniper)
                // Shop is at 160, 40. Dimensions 25x25. Half dim 12.5.
                // Front Face is Z = +12.5 (local).
                sign2.position.set(0, 12, 12.6); 
                sign2.rotation.y = 0; // Face Z+
                s.add(sign2);
            }
        }
        
        if(text === "Nice:Clothes") {
            const hGroup = new THREE.Group(); hGroup.position.set(0, 15, 0);
            createBlock(10, 1, 1, 0xEEEEEE, 0, 2, 0, hGroup); 
            const l1 = createBlock(6, 1, 1, 0xEEEEEE, -2, 4, 0, hGroup); l1.rotation.z = -0.5;
            const l2 = createBlock(6, 1, 1, 0xEEEEEE, 2, 4, 0, hGroup); l2.rotation.z = 0.5;
            createBlock(1, 2, 1, 0xEEEEEE, 0, 6, 0, hGroup); s.add(hGroup);
        }
        scene.add(s);
    }

    function triggerVape(staff) {
        if (!staff || !staff.mesh) return;
        
        // 1. Calculate Mouth Position in World Space
        const worldPos = new THREE.Vector3();
        staff.mesh.getWorldPosition(worldPos);
        
        // Height adjustment (Head is at y=3.2 roughly, world scaling is 1)
        // Group is at 0. Staff y position inside group might vary.
        // Mesh center is usually 0,0,0 relative to parent.
        // Let's assume mouth is ~3.0 units high in world space from shop floor
        worldPos.y += 3.0; 

        // 2. Get Facing Direction
        const worldQuat = new THREE.Quaternion();
        staff.mesh.getWorldQuaternion(worldQuat);
        const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(worldQuat).normalize();
        
        // Move start pos slightly forward
        worldPos.add(fwd.clone().multiplyScalar(0.5));

        // 3. Spawn Particles
        for(let i=0; i<20; i++) { // More particles
            const p = createBlock(0.15, 0.15, 0.15, 0xEEEEEE, worldPos.x, worldPos.y, worldPos.z, null);
            
            // Random spread
            p.position.x += (Math.random() - 0.5) * 0.4;
            p.position.y += (Math.random() - 0.5) * 0.4;
            p.position.z += (Math.random() - 0.5) * 0.4;

            // Velocity: Slowly forward + Slow Up + Drag
            const vel = fwd.clone().multiplyScalar(0.05 + Math.random() * 0.05); 
            vel.y += 0.02 + Math.random() * 0.03; // Slow rise
            vel.x += (Math.random()-0.5) * 0.02;
            vel.z += (Math.random()-0.5) * 0.02;

            particles.push({ 
                mesh: p, 
                vel: vel, 
                life: 3.5 + Math.random() * 1.5, // Linger 3.5-5s
                maxLife: 5.0,
                isVape: true 
            });
        }
    }

    function updateShopStaff(dt) {
        shopStaff.forEach(staff => {
            // Rotation Logic
            staff.timer += dt;
            if (staff.timer > staff.interval) {
                staff.targetRot = Math.random() * Math.PI * 2;
                staff.timer = 0;
                staff.interval = 15 + Math.random() * 10; // Reset to 15-25s
            }
            const diff = staff.targetRot - staff.mesh.rotation.y;
            staff.mesh.rotation.y += diff * dt * 0.5; 
            
            // Sway Logic
            if(staff.basePos) {
                 staff.swayTimer += dt;
                 staff.mesh.position.x = staff.basePos.x + Math.sin(staff.swayTimer * 0.5) * 0.3;
            }

            // VAPE LOGIC
            if (staff.vapeInterval) { 
                staff.vapeTimer += dt;
                if(staff.vapeTimer > staff.vapeInterval) {
                    triggerVape(staff);
                    staff.vapeTimer = 0;
                    // Reset to regular 27-46s interval
                    staff.vapeInterval = 27 + Math.random() * 19; 
                }
            }
        });
    }

    function drawBoard(lines, isScrolling) {
        boardCtx.fillStyle = '#000000'; boardCtx.fillRect(0,0,1024,256);
        boardCtx.font = 'bold 40px Courier New'; boardCtx.fillStyle = '#FF9900'; boardCtx.textAlign = 'left';
        
        if(isScrolling) {
            // SCROLLING NEWS TICKER
            boardCtx.fillText("NEWS UPDATE:", 20, 50); 
            boardCtx.fillRect(20, 60, 984, 4);
            boardCtx.font = 'bold 60px Courier New';
            
            // Construct ticker content if empty
            if (!tickerContent) {
                const football = "Latest News: Tottenham Hotspur win the Premier League in style with a 7-2 victory over Chelsea ... 50% off your first COMB with discount: I LOVE COMBS ... England Awarded 'Greyest' Country Award ... ";
                // Add random comb facts
                let extras = "";
                for(let k=0; k<5; k++) {
                    extras += COMB_TRIVIA[Math.floor(Math.random() * COMB_TRIVIA.length)] + " ... ";
                }
                tickerContent = football + extras;
            }
            
            // Draw text at offset
            boardCtx.fillText(tickerContent, 1024 - newsTickerOffset, 150);
            
            newsTickerOffset += 2.0; // Speed
            if(newsTickerOffset > (tickerContent.length * 40) + 1024) newsTickerOffset = 0; 
            
        } else {
            // STANDARD DEPARTURES
            boardCtx.fillText("DEPARTURES", 20, 50); boardCtx.fillRect(20, 60, 984, 4);
            for(let i=0; i<lines.length; i++) boardCtx.fillText(lines[i], 20, 110 + (i*50));
        }
        
        if(boardTexture) boardTexture.needsUpdate = true;
    }

    function createPerson(role, x, z) {
        const mesh = new THREE.Group(); mesh.position.set(x, 0, z);
        mesh.name = "PERSON_ROOT"; // Tag for raycaster

        const isWorker = role === 'WORKER' || role === 'GUARD';
        let shirtCol = 0x333333; let shirtTex = null;
        if(isWorker) shirtCol = C.workerColor;
        else if(role === 'STRIPED') { shirtCol = 0xffffff; shirtTex = stripeTexture; }
        else shirtCol = C.clothes[Math.floor(Math.random()*C.clothes.length)]; 

        createBlock(0.25, 1.6, 0.25, 0x111111, -0.2, 0.8, 0, mesh); createBlock(0.25, 1.6, 0.25, 0x111111, 0.2, 0.8, 0, mesh);
        createBlock(0.9, 1.4, 0.5, shirtCol, 0, 2.2, 0, mesh, shirtTex); 
        createBlock(0.25, 1.3, 0.25, shirtCol, -0.6, 2.2, 0, mesh, shirtTex); createBlock(0.25, 1.3, 0.25, shirtCol, 0.6, 2.2, 0, mesh, shirtTex);
        
        createBlock(0.5, 0.6, 0.5, getRandomSkinColor(), 0, 3.2, 0, mesh); 
        
        // LUGGAGE LOGIC (Applied to approx 30% of all people, unless they are specific roles that might look weird, but let's keep it broad)
        if(Math.random() < 0.30 && role !== 'WORKER') {
            const lug = new THREE.Group(); lug.name = "LUGGAGE"; 
            createBlock(0.6, 1.0, 0.4, 0x330000, 0, 0.5, 0, lug); createBlock(0.1, 1.2, 0.1, 0x111111, 0, 0.6, -0.3, lug);
            // Position slightly to the side
            lug.position.set(0.8, 0, 0.5); 
            mesh.add(lug);
        }

        scene.add(mesh); return mesh;
    }
    
    // --- JAMBONI (CLEANER) ---
    function createJamboni() {
        if(jamboni) scene.remove(jamboni.mesh);
        
        const group = new THREE.Group();
        // Initial pos: somewhere in the near-side shops area
        group.position.set((Math.random()-0.5)*100, 0, 40);
        
        // SCALING: 17% smaller => 0.83 scale factor
        const s = 0.83;

        // Main Body (Darker Orange)
        createBlock(6*s, 3*s, 8*s, 0xAA4400, 0, 1.5*s, 0, group);
        
        // SIDE STRIPE (Diagonal)
        // A thin plane on the right side
        const stripe = createBlock(0.2*s, 0.4*s, 7*s, 0xAAAAAA, 3.1*s, 2.0*s, 0, group);
        stripe.rotation.x = 0.15; // Angled down front-to-back
        // Left side stripe
        const stripe2 = createBlock(0.2*s, 0.4*s, 7*s, 0xAAAAAA, -3.1*s, 2.0*s, 0, group);
        stripe2.rotation.x = 0.15;

        // Seat/Engine bump
        createBlock(5*s, 2*s, 3*s, 0x883300, 0, 3.5*s, 2*s, group);
        
        // Wheels
        createBlock(7*s, 1.5*s, 1.5*s, 0x111111, 0, 0.75*s, -2.5*s, group); // Back Axle
        createBlock(7*s, 1.5*s, 1.5*s, 0x111111, 0, 0.75*s, 2.5*s, group); // Front Axle
        
        // Driver
        const driver = new THREE.Group();
        driver.position.set(0, 3*s, 1.5*s);
        // Orange Overalls
        createBlock(0.8*s, 1.2*s, 0.5*s, 0xFF6600, 0, 1.0*s, 0, driver);
        // Grey Stripe
        createBlock(0.2*s, 1.2*s, 0.51*s, 0x888888, 0, 1.0*s, 0, driver);
        // Head (Random Skin)
        createBlock(0.5*s, 0.6*s, 0.5*s, getRandomSkinColor(), 0, 2.0*s, 0, driver);
        // Arms
        createBlock(0.2*s, 0.8*s, 0.2*s, 0xFF6600, -0.6*s, 1.0*s, 0.5*s, driver).rotation.x = -1;
        createBlock(0.2*s, 0.8*s, 0.2*s, 0xFF6600, 0.6*s, 1.0*s, 0.5*s, driver).rotation.x = -1;
        
        group.add(driver);
        scene.add(group);
        
        // Return object with state logic
        return {
            mesh: group,
            angle: Math.random() * Math.PI * 2,
            speed: 0.05,
            turnSpeed: 0,
            timer: 0
        };
    }
    
    function updateJamboni(dt) {
        if(!jamboni) return;
        
        jamboni.timer -= dt;
        
        // State change logic
        if(jamboni.timer <= 0) {
            const r = Math.random();
            if(r < 0.5) {
                // Drive straight
                jamboni.turnSpeed = 0;
                jamboni.timer = 2 + Math.random() * 4;
            } else if (r < 0.8) {
                // Zig Zag / Turn
                jamboni.turnSpeed = (Math.random() - 0.5) * 1.5;
                jamboni.timer = 1 + Math.random() * 2;
            } else {
                // U-Turn attempt
                jamboni.turnSpeed = 2.5; // Sharp turn
                jamboni.timer = 1.5;
            }

            // Path correction bias
            const pos = jamboni.mesh.position;
            if (pos.x > -80 && pos.x < 80) {
                if (Math.random() > 0.33) {
                    jamboni.turnSpeed = (pos.x > 0) ? 0.5 : -0.5;
                }
            }
        }
        
        // Apply rotation
        jamboni.angle += jamboni.turnSpeed * dt;
        jamboni.mesh.rotation.y = jamboni.angle + Math.PI; // Face forward
        
        // Move forward
        const dir = new THREE.Vector3(Math.sin(jamboni.angle), 0, Math.cos(jamboni.angle));
        const newPos = jamboni.mesh.position.clone().add(dir.multiplyScalar(jamboni.speed * 60 * dt));
        
        // Collision check for Jamboni
        let hit = false;
        // Wall boundaries
        if(newPos.x < -180 || newPos.x > 180 || newPos.z < -20 || newPos.z > 90) hit = true;
        // Obstacle collision
        for(let ob of obstacles) {
            if(newPos.distanceTo(new THREE.Vector3(ob.x, 0, ob.z)) < ob.r + 3) hit = true;
        }

        if(hit) {
             jamboni.angle += Math.PI + (Math.random()-0.5);
             jamboni.timer = 2.0;
             jamboni.turnSpeed = 0;
        } else {
            jamboni.mesh.position.copy(newPos);
        }
    }

    function spawnPigeon() {
        const p = new THREE.Group();
        createBlock(0.2, 0.2, 0.4, 0x888888, 0, 0, 0, p); 
        const w1 = createBlock(0.3, 0.05, 0.2, 0xAAAAAA, 0.25, 0, 0, p); const w2 = createBlock(0.3, 0.05, 0.2, 0xAAAAAA, -0.25, 0, 0, p);
        const startX = Math.random() > 0.5 ? -200 : 200;
        p.position.set(startX, 20 + Math.random()*10, 20 + Math.random()*20);
        scene.add(p);
        
        // CHAOTIC LOGIC TRIGGER
        // If gameTime > 75, we have a 50% chance of a chaotic pigeon, OR random high chance around that time
        let isChaotic = false;
        if(gameTime > 75) {
            if(Math.random() < 0.6) isChaotic = true;
        }

        pigeons.push({ 
            mesh: p, 
            wings: [w1, w2], 
            // Chaotic ones move slower on X to stay on screen longer for twisting
            vel: new THREE.Vector3(startX > 0 ? (isChaotic ? -15 : -25) : (isChaotic ? 15 : 25), 0, (Math.random()-0.5)*5),
            isChaotic: isChaotic,
            nextFeather: 0,
            baseY: p.position.y,
            seed: Math.random() * 100 // Random seed for unique chaos path
        });
    }
    
    // NEW TRAIN SPAWNER FUNCTION to reset trains correctly
    function spawnTrains() {
    // Clear old trains
    trains.forEach(t => scene.remove(t.mesh));
    trains = [];

    // choose a slow train index (one per spawn)
    const slowIdx = Math.floor(Math.random() * 6);

    for (let i = 0; i < 6; i++) {
        const x = -100 + (i * 40);
        const trainGroup = new THREE.Group();
        // Create default train
        createTrain(x - 16, -1.0, -60, trainGroup, C.trainColors[Math.floor(Math.random() * C.trainColors.length)]);
        scene.add(trainGroup);

        // Initialize random departure time (was 63-87s). Add +4.5s to delay first departures slightly.
        // New range: 67.5 - 91.5
        const depTime = 67.5 + Math.random() * 24;

        trains.push({
            mesh: trainGroup,
            departTime: depTime,
            speed: 0,
            hasDeparted: false,
            // mark one train as the particularly slow-departing train
            isSlow: (i === slowIdx)
        });
    }
}

    
    function createFeather(pos) {
        const f = createBlock(0.1, 0.01, 0.1, 0xFFFFFF, pos.x, pos.y, pos.z, null);
        // Special particles for feathers: Slowly falling, drifting
        particles.push({ 
            mesh: f, 
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, -1.5, (Math.random()-0.5)*0.5), // Falling down
            life: 2.5, // 2.5 seconds life
            maxLife: 2.5,
            isFeather: true
        });
    }

    // --- LOGIC ---
    
    // NEW: First prepare the world but wait in "READY_CHECK" state
    function prepareGameEnv(mode) {
        gameMode = mode;
        timerRunning = false;
        timerStartTime = 0;
        isInitializing = false; // Reset lock
        
        // Setup UI for pause state
        document.getElementById('menu').style.display = 'none';
        document.getElementById('ready-overlay').style.display = 'flex'; // SHOW OVERLAY
        document.getElementById('fixed-timer-container').style.display = (gameMode === 'TIMED') ? 'block' : 'none';
        document.getElementById('timer-ui').innerText = "00.000";
        document.getElementById('menu-streak-box').style.display = (gameMode === 'STREAK') ? 'block' : 'none';
        document.getElementById('vol-music-container').style.display = SETTING_MUSIC_ON ? 'flex' : 'none';
        document.getElementById('vol-sfx-container').style.display = SETTING_SFX_ON ? 'flex' : 'none';
        
        // Reset Logic
        document.getElementById('phone-overlay').style.bottom = "-200px";
        document.getElementById('blood-screen-container').innerHTML = '';
        document.getElementById('blood-screen-container').style.display = 'none';
        civilians.forEach(c => scene.remove(c.mesh)); civilians = [];
        bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
        bloodPuddles.forEach(b => scene.remove(b.mesh)); bloodPuddles = [];
        pigeons.forEach(p => scene.remove(p.mesh)); pigeons = [];
        confetti.forEach(c => scene.remove(c.mesh)); confetti = [];
        particles.forEach(p => scene.remove(p.mesh)); particles = [];
        looseItems.forEach(i => scene.remove(i.mesh)); looseItems = [];
        
        // Reset trains completely
        spawnTrains();
        
        obstacles = []; // Clear obstacles (rebuilt in buildStation if static, but shops are static)
        
        shopStaff = []; 
        
        // Create Jamboni
        jamboni = createJamboni();
        
        drawBoard(["AWAITING DATA..."]);

        gameState = 'READY_CHECK'; // Wait here
        targetObj = null;
        boardDataGenerated = false;
        trainsDeparted = false;
        newsTickerActive = false;
        tickerContent = "";

        let camY = 50; if(Math.random() < 0.17) { camY += (Math.random() > 0.5 ? 5 : -5); }
        camera.position.set(0, camY, 130); camera.lookAt(0,0,0); pitch = -0.4; yaw = 0;
        targetTown = DESTINATIONS[Math.floor(Math.random() * DESTINATIONS.length)];
        targetPlatform = Math.floor(Math.random() * 6); 
        spawnCrowd();
    }

    // NEW: Click "I'm Ready" to actually start audio and logic
    function confirmReady() {
        document.getElementById('ready-overlay').style.display = 'none';
        
        // IMMEDIATE AUDIO START - Solves Safari Autoplay issues
        // SFX Starts immediately
        const sfx = document.getElementById('sfx-ambience');
        if(sfx) {
            sfx.volume = 0; sfx.pause(); 
            if(SETTING_SFX_ON) { 
                sfx.currentTime = Math.random() * 58; 
                sfx.play().then(() => {
                    fadeInAudio(sfx, SETTING_SFX_VOL, 2000);
                }).catch(e => console.log("SFX play failed:", e)); 
            }
        }

        // Music Starts after 2.7s delay
        if(SETTING_MUSIC_ON) {
            setTimeout(() => {
                playMusic();
            }, 2700);
        } else if(activeMusicAudio) { 
            activeMusicAudio.pause(); activeMusicAudio = null; 
        }
        
        // Start Logic
        gameState = 'MINGLE';
        gameTime = 0;
        bleedTimer = 0;
        bloodSpawned = false;
        nextPigeonTime = 5 + Math.random() * 5;
    }

    function abortMission() {
        STATS.abort++; saveSettings(); reloadWithFade();
    }

    function spawnCrowd() {
        for(let i=0; i<5; i++) {
            const mesh = createPerson('WORKER', (Math.random()-0.5)*200, -30 + Math.random()*10);
            civilians.push({mesh:mesh, role:'WORKER', state:'IDLE', waypoints:[]});
        }
        const guardMesh = createPerson('GUARD', (Math.random()-0.5)*200, -50);
        civilians.push({mesh:guardMesh, role:'GUARD', state:'WALKING', waypoints:[new THREE.Vector3(100,0,-50), new THREE.Vector3(-100,0,-50)], speed:0.02});
        const staticCount = 5 + Math.floor(Math.random() * 22); 
        for(let i=0; i<staticCount; i++) {
            const sm = createPerson('CIV', (Math.random()-0.5)*250, 20 + Math.random()*60);
            civilians.push({mesh:sm, role:'STATIC', state:'STATIC', waypoints:[], speed:0, sway:Math.random()*100, origin: sm.position.clone() });
        }
        const civCount = parseInt(SETTING_CROWD);
        const packageCount = parseInt(SETTING_PACKAGES);
        const flowerCount = Math.floor(Math.random() * 4) + 1;
        const flowerIndices = [];
        for(let i=0; i<flowerCount; i++) flowerIndices.push(Math.floor(Math.random() * civCount));
        for(let i=0; i<civCount; i++) {
            const x = (Math.random()-0.5)*280; const z = 20 + Math.random()*80;
            let role = 'CIV'; let hasPackage = false; let isDecoy = false;
            if(i < packageCount) {
                hasPackage = true;
                if(i === 0) role = 'TARGET'; else { role = 'DECOY'; isDecoy = true; }
            } else if(i >= packageCount && i < packageCount + 8) role = 'STRIPED'; 
            const mesh = createPerson(role, x, z);
            let pkg;
            if(hasPackage) {
                pkg = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.1), new THREE.MeshBasicMaterial({color: C.packageColor}));
                pkg.position.set(0.6, 1.5, 0.3); mesh.add(pkg);
            }
            if(flowerIndices.includes(i) && !hasPackage) {
                const bouquet = new THREE.Group();
                const wrap = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 8), new THREE.MeshLambertMaterial({color: 0xFFFFFF}));
                wrap.rotation.x = Math.PI; bouquet.add(wrap);
                const fCols = [0xFF0000, 0xFFFF00, 0x9900FF]; 
                for(let f=0; f<5; f++) {
                    const fMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshBasicMaterial({color: fCols[Math.floor(Math.random()*3)]}));
                    fMesh.position.set((Math.random()-0.5)*0.2, 0.2+(Math.random()*0.1), (Math.random()-0.5)*0.2); bouquet.add(fMesh);
                }
                bouquet.position.set(0.7, 1.6, 0.5); bouquet.rotation.x = -0.5; bouquet.rotation.z = -0.2; bouquet.scale.set(2.5, 2.5, 2.5); mesh.add(bouquet);
            }
            const civ = { mesh: mesh, role: role, pkg: pkg, isDecoy: isDecoy, state: 'IDLE', waypoints: [], speed: 0.04 + Math.random()*0.02, sway: Math.random()*100 };
            if(role === 'TARGET') targetObj = civ;
            civilians.push(civ);
        }
    }

    function triggerRush() {
        gameState = 'RUSH';
        civilians.forEach(c => {
            if(c.role === 'WORKER' || c.role === 'GUARD' || c.role === 'STATIC') {
                if(c.role === 'WORKER') { c.state = 'WALKING'; c.speed = 0.02; c.waypoints = [new THREE.Vector3((Math.random()-0.5)*200, 0, -40 - Math.random()*40)]; }
                return;
            }
            c.state = 'WALKING'; c.speed *= 2.0;
            let pid = -1; let isShop = false;
            if(c.role === 'TARGET') { pid = targetPlatform; } 
            else if(c.role === 'DECOY') {
                const r = Math.random();
                if(r < 0.33) pid = (targetPlatform + 1) % 6; else if (r < 0.66) { isShop = true; c.shopSide = 'LEFT'; } else { isShop = true; c.shopSide = 'RIGHT'; }
            } else { pid = Math.floor(Math.random()*6); }
            if(isShop) {
                const sX = c.shopSide === 'LEFT' ? -160 : 160; c.waypoints = [ new THREE.Vector3(sX, 0, 0) ];
            } else {
                const pX = -100 + (pid * 40); const randOffset = (Math.random()-0.5) * 10;
                c.waypoints = [ new THREE.Vector3(pX + randOffset, 0, -20), new THREE.Vector3(pX + randOffset, 0, -60 - Math.random()*60), new THREE.Vector3(pX - 12, 0, -60 - Math.random()*60) ];
            }
        });
    }

    function updateLogic(dt) {
        gameTime += dt;
        if(gameTime > nextPigeonTime) { spawnPigeon(); nextPigeonTime = gameTime + 10 + Math.random()*15; }
        if(gameTime > 14 && document.getElementById('phone-overlay').style.bottom === "-200px") {
            document.getElementById('phone-text').innerText = "TARGET TO: " + targetTown;
            document.getElementById('phone-overlay').style.bottom = "20px";
        }
        
        // BUG FIX: Ensure board only generates ONCE to prevent freeze/loop
        if(gameTime > 17 && !boardDataGenerated) {
             boardDataGenerated = true;
             
             if(gameMode === 'TIMED' && !timerRunning) { timerRunning = true; timerStartTime = performance.now(); }
             let boardRows = [];
             let availableDestinations = DESTINATIONS.filter(d => d !== targetTown); let otherIdx = 0;
             let platformData = []; 
             for(let i=0; i<6; i++) { if(i === targetPlatform) platformData[i] = targetTown; else platformData[i] = availableDestinations[otherIdx++ % availableDestinations.length]; }
             let displayOrder = [0,1,2,3,4,5];
             for (let i = displayOrder.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [displayOrder[i], displayOrder[j]] = [displayOrder[j], displayOrder[i]]; }
             for(let i=0; i<6; i++) {
                 let pId = displayOrder[i]; let dest = platformData[pId]; let line = `14:0${i}  ${dest.padEnd(10, ' ')} PLAT ${pId+1}`; boardRows.push(line);
             }
             if(Math.random() < 0.25) { const idx = Math.floor(Math.random() * 6); const northDest = NORTHERN[Math.floor(Math.random()*NORTHERN.length)]; boardRows[idx] = `14:0${idx}  ${northDest.padEnd(10, ' ')} PLAT 9b`; }
             drawBoard(boardRows);
        }
        
        if(gameTime > 24 && gameState === 'MINGLE') triggerRush();

        // TRAIN DEPARTURE EVENT - CHECK EVERY FRAME
        // If any train is due to depart
        if(!trainsDeparted) {
            // Check if we should start the sequence? No, they depart individually
            // But we need to switch the board at some point.
            // Let's switch board when the FIRST train starts moving.
        }
        
        trains.forEach(t => {
            if(gameTime > t.departTime && !t.hasDeparted) {
                // If this is the first train to move, activate ticker
                if (!newsTickerActive) {
                    newsTickerActive = true;
                    trainsDeparted = true; 
                }
                
                // Train movement + acceleration (respect slow train flag)
if (!t.hasDeparted) {
    // acceleration strength: slow trains accelerate much more slowly
    const accel = t.isSlow ? 0.6 : 5.0; // slow train gets tiny acceleration
    t.speed += dt * accel;

    // movement multiplier: slow trains move away much slower
    const moveMul = t.isSlow ? 2.0 : 10.0;
    t.mesh.position.z -= t.speed * dt * moveMul; // Move away (-Z)

    // Fade out logic (unchanged)
    if (t.mesh.position.z < -250) {
        t.mesh.traverse(child => {
            if (child.isMesh && child.material) {
                child.material.transparent = true;
                // Simple linear fade
                let opacity = 1.0 - (Math.abs(t.mesh.position.z + 250) / 150);
                child.material.opacity = Math.max(0, opacity);
            }
        });
    }

    if (t.mesh.position.z < -500) {
        t.hasDeparted = true;
        scene.remove(t.mesh);
    }
}

                
                // Fade out logic
                if(t.mesh.position.z < -250) { 
                    t.mesh.traverse(child => {
                        if(child.isMesh && child.material) {
                            child.material.transparent = true;
                            // Simple linear fade
                            let opacity = 1.0 - (Math.abs(t.mesh.position.z + 250) / 150);
                            child.material.opacity = Math.max(0, opacity);
                        }
                    });
                }
                
                if(t.mesh.position.z < -500) {
                    t.hasDeparted = true;
                    scene.remove(t.mesh);
                }
            }
        });
    }

    function createParticle(x, y, z, col, speed) {
        const p = createBlock(0.3, 0.3, 0.3, col, x, y, z, null);
        particles.push({ mesh: p, vel: new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed, (Math.random()-0.5)*speed), life: 1.0 });
    }

    function spawnFireworks() {
        for(let i=0; i<5; i++) {
            setTimeout(() => {
                const cx = (Math.random()-0.5)*200; const cy = 50 + Math.random()*50; const cz = -50 + (Math.random()-0.5)*100;
                const col = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF][Math.floor(Math.random()*5)];
                for(let j=0; j<30; j++) createParticle(cx, cy, cz, col, 2.0);
            }, i*500);
        }
    }

    function updateLooseItems(dt) {
    for (let i = looseItems.length - 1; i >= 0; i--) {
        const item = looseItems[i];
        if (item.life > 0) {
            // Move the item
            item.mesh.position.add(item.vel.clone().multiplyScalar(dt * 60)); // scale by dt*60 to match other movement
            item.mesh.rotation.x += item.rotVel.x;
            item.mesh.rotation.z += item.rotVel.z;

            // Basic drag & gravity imitation
            item.vel.multiplyScalar(0.96);
            item.vel.y -= 9.8 * dt * 0.02; // slight gravity so it drops a little faster

            if (item.mesh.position.y < 0) { item.mesh.position.y = 0; item.vel.y = 0; }

            // COLLISION: luggage hits a single civilian
            if (!item.hasHit) {
                for (let c = 0; c < civilians.length; c++) {
                    const civ = civilians[c];
                    if (!civ || !civ.mesh) continue;
                    // ignore the original owner falling etc  we only check for OTHER civilians
                    // distance threshold tuned to match visual scale (approx 1.0 units)
                    const dist = item.mesh.position.distanceTo(civ.mesh.position);
                    if (dist < 1.0) {
                        // Mark this item as having hit someone, so it won't hit multiple
                        item.hasHit = true;

                        // Knock the civilian over (one-time)
                        try {
                            // Give the victim a 'down' rotation & small upward pop so it's visually distinct
                            civ.mesh.rotation.x = -Math.PI / 2;
                            // Slight lift/jerk if still above ground
                            civ.mesh.position.y = Math.max(0.02, civ.mesh.position.y - 0.05);

                            // Spawn a blood puddle under them (reuse spawnBlood logic)
                            spawnBlood(civ);

                            // If there is a victimRef used elsewhere, set it for bleed animation path if appropriate
                            victimRef = civ;

                            // Make the civ state explicit to avoid further AI movement
                            civ.state = 'DOWN';
                        } catch (e) {
                            console.warn("Luggage hit handling error:", e);
                        }

                        // Remove / expire the luggage quickly so it doesn't keep colliding
                        item.life = Math.min(item.life, 0.2);
                        break; // break out of civilians loop; luggage only hits one
                    }
                }
            }

            item.life -= dt;
        } else {
            // Clean up expired item
            if (item.mesh) {
                scene.remove(item.mesh);
                try { if (item.mesh.geometry) item.mesh.geometry.dispose(); if (item.mesh.material) item.mesh.material.dispose(); } catch (e) {}
            }
            looseItems.splice(i, 1);
        }
    }
}


    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        
        // Always draw matrix, but it handles speed inside the function
        drawMatrix();

        if(gameState === 'MENU' || gameState === 'ENDED') { 
            return; 
        }

        if(timerRunning) {
            const now = performance.now(); const elapsed = (now - timerStartTime) / 1000;
            document.getElementById('timer-ui').innerText = elapsed.toFixed(3);
        }
        
        // BOARD ANIMATION LOOP
        if(newsTickerActive) {
            drawBoard([], true);
        }

        if(gameState === 'BLEEDING') {
            bleedTimer += dt;
            if(victimRef && victimRef.mesh) {
                if(victimRef.role === 'TARGET' || victimRef.role === 'COURIER') {
                    if(victimRef.mesh.rotation.x > -Math.PI/2) { victimRef.mesh.rotation.x -= dt * 5.0; victimRef.mesh.position.y = Math.max(0.2, victimRef.mesh.position.y - dt); } 
                    else if(bleedTimer > 1.0 && victimRef.mesh.position.y < 15) { victimRef.mesh.position.y += dt * 2.0; victimRef.mesh.rotation.y = 0; }
                } else {
                    if(victimRef.mesh.rotation.x > -Math.PI/2) { victimRef.mesh.rotation.x -= dt * 5.0; victimRef.mesh.position.y = Math.max(0.2, victimRef.mesh.position.y - dt); }
                }
            }
            updateLooseItems(dt);
            if(bleedTimer > 0.3 && !bloodSpawned) { spawnBlood(victimRef); bloodSpawned = true; }
            if(bloodPuddles.length > 0) { const p = bloodPuddles[bloodPuddles.length-1]; if(p.scale < 1.5) { p.scale += dt * 2; p.mesh.scale.setScalar(p.scale); } }
            if(bleedTimer > 4.5) {
                if(resultIsWin) {
                    if(gameMode === 'TIMED' && isHighscore(finalTime)) {
                        gameState = 'INPUT_SCORE'; document.getElementById('high-score-modal').style.display = 'flex';
                        document.getElementById('new-record-time').innerText = finalTime.toFixed(3) + "s";
                        document.getElementById('hs-input').value = ""; document.getElementById('hs-input').focus();
                    } else showEndScreen();
                } else { gameState = 'SCREEN_EFFECT'; bleedTimer = 0; triggerScreenBlood(); }
            }
            renderer.render(scene, camera); return;
        }
        
        if(gameState === 'INPUT_SCORE' || gameState === 'READY_CHECK') {
            // While in ready check, allow simple idle animations but NO game time progress
            civilians.forEach(c => { if(c.role === 'STATIC') c.mesh.rotation.y = Math.sin(Date.now()*0.001 + c.sway) * 0.5; });
            renderer.render(scene, camera);
            return;
        }

        if(gameState === 'SCREEN_EFFECT') {
            bleedTimer += dt; if(bleedTimer > 2.0) showEndScreen(); renderer.render(scene, camera); return;
        }

        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i]; 
            p.mesh.position.add(p.vel.clone().multiplyScalar(dt)); // Scale velocity by dt for all particles now
            
            if(p.isFeather) {
                 // Feathers float down gently with sway
                 p.mesh.position.x += Math.sin(gameTime * 3 + p.life) * 0.05;
                 p.mesh.position.z += Math.cos(gameTime * 2 + p.life) * 0.05;
                 p.mesh.rotation.x += dt;
                 p.mesh.rotation.y += dt;
                 // Fade out logic (scale)
                 const scale = (p.life / p.maxLife); // 1 to 0
                 p.mesh.scale.setScalar(scale);
            } else if (p.isVape) {
                 // Vape smoke: float up + drag + fade/shrink
                 p.vel.y += dt * 0.5; // Acceleration up
                 p.vel.x *= 0.95; // Drag
                 p.vel.z *= 0.95; 
                 p.mesh.scale.setScalar(p.life * 0.5); 
            } else {
                 // Standard fireworks scaling
                 p.mesh.scale.setScalar(p.life);
            }

            p.life -= dt; 
            if(p.life <= 0) { 
                scene.remove(p.mesh); 
                // BUG FIX: Dispose geometry to prevent memory leak/freeze over time
                if(p.mesh.geometry) p.mesh.geometry.dispose();
                if(p.mesh.material) p.mesh.material.dispose();
                particles.splice(i,1); 
            }
        }
        confetti.forEach(c => { c.mesh.position.y -= c.speed; c.mesh.rotation.x += 0.1; });
        if(gameState === 'ENDED') return;

        updateLogic(dt);
        updateJamboni(dt); // Update the cleaner
        updateShopStaff(dt); // Update shopkeepers
        
        const aimSpeed = isZoomed ? 0.2 * dt : 1.0 * dt;
        if(keyState['w'] || keyState['arrowup']) pitch += aimSpeed; if(keyState['s'] || keyState['arrowdown']) pitch -= aimSpeed;
        if(keyState['a'] || keyState['arrowleft']) yaw += aimSpeed; if(keyState['d'] || keyState['arrowright']) yaw -= aimSpeed;
        pitch = Math.max(-1.2, Math.min(0.2, pitch)); camera.rotation.x = pitch; camera.rotation.y = yaw;

        civilians.forEach(c => {
            if(c.role === 'STATIC') {
                c.mesh.rotation.y = Math.sin(gameTime + c.sway) * 0.5;
                if(c.state === 'STATIC' && Math.random() < 0.005) {
                     c.state = 'WANDERING'; const angle = Math.random() * Math.PI * 2; const dist = 5 + Math.random()*5;
                     c.waypoints = [new THREE.Vector3(c.origin.x + Math.cos(angle)*dist, 0, c.origin.z + Math.sin(angle)*dist)]; c.speed = 0.02;
                }
            }
            if(c.state === 'IDLE' && c.role !== 'WORKER' && Math.random() < 0.01) {
                 c.state = 'WALKING'; c.waypoints = [new THREE.Vector3((Math.random()-0.5)*250, 0, 20 + Math.random()*80)];
            }
            if((c.state === 'WALKING' || c.state === 'WANDERING') && c.waypoints.length > 0) {
                const target = c.waypoints[0];
                const dir = new THREE.Vector3().subVectors(target, c.mesh.position);
                if(statuePos && c.mesh.position.distanceTo(statuePos) < 8) dir.add(c.mesh.position.clone().sub(statuePos).normalize().multiplyScalar(0.5));
                
                // Obstacle Avoidance (Collision Check)
                let collision = false;
                for(let ob of obstacles) {
                     let dist = c.mesh.position.distanceTo(new THREE.Vector3(ob.x, 0, ob.z));
                     if(dist < ob.r) {
                         collision = true;
                         // HARD COLLISION FIX: Push to edge of radius immediately
                         let pushDir = c.mesh.position.clone().sub(new THREE.Vector3(ob.x, 0, ob.z)).normalize();
                         // Ensure we don't get NaN if exactly on top (rare but possible)
                         if (pushDir.lengthSq() === 0) pushDir.set(1, 0, 0);
                         
                         let newPos = new THREE.Vector3(ob.x, 0, ob.z).add(pushDir.multiplyScalar(ob.r + 0.5));
                         c.mesh.position.x = newPos.x;
                         c.mesh.position.z = newPos.z;
                     }
                }

                if(dir.length() < 1.0 && !collision) {
                    c.waypoints.shift();
                    if(c.waypoints.length === 0) {
                        if(c.role === 'GUARD') c.waypoints = [new THREE.Vector3(c.mesh.position.x > 0 ? -100 : 100, 0, -50)];
                        else if(gameState === 'RUSH' && c.role !== 'WORKER' && c.role !== 'STATIC') { c.state = 'BOARDED'; scene.remove(c.mesh); } 
                        else if(c.role === 'STATIC') { c.state = 'STATIC'; } else c.state = 'IDLE';
                    }
                } else {
                    dir.normalize(); 
                    const moveVec = dir.multiplyScalar(c.speed * 60 * dt);
                    c.mesh.position.add(moveVec); 
                    c.mesh.lookAt(c.mesh.position.clone().add(dir));
                    const legL = c.mesh.children[0]; const legR = c.mesh.children[1];
                    legL.rotation.x = Math.sin(gameTime * 15 + c.sway) * 0.6; legR.rotation.x = -Math.sin(gameTime * 15 + c.sway) * 0.6;
                }
            }
        });

        for(let i=pigeons.length-1; i>=0; i--) {
            const p = pigeons[i]; 
            
            // Chaotic Movement Logic
            let currentVel = p.vel.clone();
            
            if(p.isChaotic) {
                // Apply chaotic wave functions based on time and seed
                // Use a faster time scale for "twitchy" chaotic movement
                // Twist and turn over "concourse-ish area" (Z > -30)
                if (p.mesh.position.z > -30) {
                     const chaosT = gameTime * 3.0 + p.seed;
                     currentVel.y += Math.sin(chaosT * 2.0) * 8; // Vertical wobble
                     currentVel.z += Math.cos(chaosT * 1.5) * 15; // Horizontal sway
                     
                     // Rotation banking
                     p.mesh.rotation.z = Math.sin(chaosT) * 0.8; 
                     p.mesh.rotation.x = Math.cos(chaosT * 0.5) * 0.3;
                     
                     // Drop Feathers
                     if(gameTime > p.nextFeather) {
                         // Random small burst of 2-3 feathers
                         const count = 2 + Math.floor(Math.random()*2);
                         for(let f=0; f<count; f++) {
                             // Slight random offset for feather spawn
                             const fPos = p.mesh.position.clone();
                             fPos.x += (Math.random()-0.5);
                             fPos.y -= 0.2;
                             fPos.z += (Math.random()-0.5);
                             createFeather(fPos);
                         }
                         // Random delay before next drop (0.3s to 0.8s)
                         p.nextFeather = gameTime + 0.3 + Math.random() * 0.5;
                     }
                }
            }

            p.mesh.position.add(currentVel.multiplyScalar(dt));
            
            // Despawn
            if(Math.abs(p.mesh.position.x) > 300) { scene.remove(p.mesh); pigeons.splice(i,1); }
        }
        
        bullets.forEach((b,i) => { b.age+=dt; b.mesh.material.opacity-=dt*3; if(b.age>0.3){scene.remove(b.mesh);bullets.splice(i,1);} });
        const fov = isZoomed ? 10 : 60; camera.fov += (fov - camera.fov) * 0.15; camera.updateProjectionMatrix();
        renderer.render(scene, camera);
    }

    function fire() {
        try {
            camera.position.y += 0.5; setTimeout(()=>camera.position.y-=0.5, 80);
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            const ray = raycaster.ray; const start = camera.position.clone().add(new THREE.Vector3(0,-1,0)); const end = ray.at(300, new THREE.Vector3());
            const geo = new THREE.CylinderGeometry(0.05,0.05,start.distanceTo(end),4); geo.rotateX(-Math.PI/2); geo.translate(0,0,start.distanceTo(end)/2);
            const tracer = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0xFFFF00, transparent:true, opacity:0.8}));
            tracer.position.copy(start); tracer.lookAt(end); scene.add(tracer); bullets.push({mesh:tracer, age:0});

            // SMART TARGETING FIX:
            let firstCivHit = null;
            let targetHitDist = -1;

            for(let hit of intersects) {
                let obj = hit.object; 
                // TRAVERSE UP TO ROOT OBJECT
                // Stop at Scene, or specific roots like "PERSON_ROOT"
                let safeguard = 0; 
                while(obj.parent && obj.parent.type !== 'Scene' && obj.name !== 'PERSON_ROOT' && safeguard < 100) { 
                    obj = obj.parent; 
                    safeguard++; 
                }
                
                // CHECK IF OBJECT IS A CIVILIAN OR SHOP STAFF
                let civ = civilians.find(c => c.mesh === obj); 
                
                // IF NOT IN CIVILIAN LIST, CHECK SHOP STAFF
                if(!civ) {
                    const staff = shopStaff.find(s => s.mesh === obj);
                    if(staff) civ = { mesh: staff.mesh, role: 'STATIC' }; // Treat staff as static civ for hit logic
                }

                if(civ) {
                    if(!firstCivHit) firstCivHit = { civ: civ, dist: hit.distance };
                    if(civ === targetObj) targetHitDist = hit.distance;
                }
            }

            // Decision Logic:
            if(targetHitDist !== -1 && firstCivHit) {
                if(targetHitDist <= firstCivHit.dist + 2.5) {
                    processHit(targetObj);
                    return;
                }
            }

            if(firstCivHit) {
                processHit(firstCivHit.civ);
            }

        } catch(e) { console.error("Fire Error:", e); }
    }

    function processHit(civ) {
        document.getElementById('scope-overlay').style.display = 'none';
        if(timerRunning) { timerRunning = false; finalTime = (performance.now() - timerStartTime) / 1000; }
        if(civ === targetObj) { resultIsWin = true; KILL_STREAK++; STATS.target++; } else {
            resultIsWin = false; KILL_STREAK = 0; victimRef = civ;
            if(civ.role === 'DECOY') { resultReason = "YOU SHOT A DECOY (WRONG TRAIN/SHOP)."; STATS.decoy++; }
            else if(civ.role === 'STRIPED') { resultReason = "DISTRACTION TARGET. CIVILIAN CASUALTY."; STATS.civ++; }
            else if(civ.role === 'STATIC') { resultReason = "BYSTANDER CASUALTY."; STATS.civ++; }
            else if(civ.role === 'GUARD') { resultReason = "OFFICER DOWN. MISSION COMPROMISED."; STATS.civ++; }
            else { resultReason = "CIVILIAN CASUALTY."; STATS.civ++; }
        }
        saveSettings();
        if(civ && civ.mesh) {
            const luggage = civ.mesh.getObjectByName("LUGGAGE");
            if(luggage) {
                const worldPos = new THREE.Vector3(); luggage.getWorldPosition(worldPos);
                const worldQuat = new THREE.Quaternion(); luggage.getWorldQuaternion(worldQuat);
                civ.mesh.remove(luggage); scene.add(luggage);
                luggage.position.copy(worldPos); luggage.quaternion.copy(worldQuat);
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(civ.mesh.quaternion).normalize();
                const speed = (civ.speed || 0.04) * 5.0; 
                looseItems.push({ mesh: luggage, vel: forward.multiplyScalar(speed).add(new THREE.Vector3((Math.random()-0.5)*0.2, 0, (Math.random()-0.5)*0.2)), rotVel: new THREE.Vector3((Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1), life: 3.0 });
            }
            civ.mesh.rotation.x = 0; 
        }
        gameState = 'BLEEDING'; bleedTimer = 0; bloodSpawned = false;
    }

    function isHighscore(time) {
        if(LEADERBOARD.length < 5) return true;
        const worst = Math.max(...LEADERBOARD.map(e => e.time)); return time < worst;
    }

    function submitScore() {
        const input = document.getElementById('hs-input');
        const initials = input.value.toUpperCase().substring(0,3) || "UNK";
        LEADERBOARD.push({name: initials, time: finalTime});
        LEADERBOARD.sort((a,b) => a.time - b.time);
        if(LEADERBOARD.length > 5) LEADERBOARD = LEADERBOARD.slice(0,5);
        saveSettings();
        document.getElementById('high-score-modal').style.display = 'none';
        reloadWithFade(); 
    }

    function spawnBlood(civ) {
        if(!civ || !civ.mesh) return;
        const b = new THREE.Mesh(new THREE.CircleGeometry(0.6,16), new THREE.MeshBasicMaterial({color:0xaa0000, depthTest:false, transparent:false}));
        b.renderOrder = 999; b.rotation.x = -Math.PI/2; 
        b.position.set(civ.mesh.position.x, 0.02, civ.mesh.position.z); scene.add(b);
        bloodPuddles.push({mesh:b, scale:0.1}); 
    }

    function triggerScreenBlood() {
        const cont = document.getElementById('blood-screen-container');
        cont.innerHTML = ''; cont.style.display = 'block';
        for(let i=0; i<60; i++) {
            const d = document.createElement('div'); d.className = 'drip'; d.style.left = (Math.random()*100)+'%'; 
            d.style.height = (50+Math.random()*200)+'px'; d.style.transition = 'top '+(1+Math.random()*2)+'s';
            cont.appendChild(d); setTimeout(()=>d.style.top = '-20px', 100);
        }
    }

    function showEndScreen() {
        gameState = 'ENDED';
        document.getElementById('menu').style.display = 'flex';
        document.getElementById('start-dossier').style.display = 'none';
        document.getElementById('end-dossier').style.display = 'block';
        const endDossier = document.getElementById('end-dossier');
        endDossier.className = resultIsWin ? 'dossier win-theme' : 'dossier lose-theme';
        const stamp = document.getElementById('end-stamp');
        const title = document.getElementById('outcome-title');
        const desc = document.getElementById('outcome-desc');
        const award = document.getElementById('award-text');

        // ANIMATION RESET
        stamp.classList.remove('slammed'); // Reset animation
        stamp.style.opacity = '0'; // Ensure hidden initially
        
        // Trigger Stamp Slam after slight delay
        setTimeout(() => {
            stamp.classList.add('slammed');
        }, 800);

        if(resultIsWin) {
            for(let i=0; i<100; i++) {
                const c = createBlock(0.5, 0.5, 0, [0xff0000,0x00ff00,0xffff00][Math.floor(Math.random()*3)], (Math.random()-0.5)*50, 40+Math.random()*20, -50);
                confetti.push({mesh:c, speed:Math.random()*0.5});
            }
            spawnFireworks();
            const rndTitle = WIN_TITLES[Math.floor(Math.random() * WIN_TITLES.length)];
            stamp.innerText = "SUCCESS"; 
            stamp.style.color = "#00AA00"; stamp.style.borderColor = "#00AA00";
            title.innerText = rndTitle; 
            if(gameMode === 'TIMED') {
                desc.innerText = "TARGET DOWN. TIME: " + finalTime.toFixed(3) + "s";
                award.innerText = "";
                renderLeaderboard(); 
            } else {
                desc.innerText = "TARGET NEUTRALIZED. THE CROWN SLEEPS SAFELY.";
                award.innerText = generateCodeName();
            }
        } else {
            stamp.innerText = "FAILED"; 
            stamp.style.color = "#C00"; stamp.style.borderColor = "#C00";
            title.innerText = "DISAVOWED"; 
            desc.innerText = resultReason + " CATASTROPHIC FAILURE.";
            award.innerText = "";
        }
        document.getElementById('streak-display').innerText = KILL_STREAK;
        renderStats();
    }

    function toggleZoom(forceOff) {
        if(forceOff) isZoomed = false; else isZoomed = !isZoomed;
        document.getElementById('scope-overlay').style.display = isZoomed ? 'block' : 'none';
        const ch = document.getElementById('crosshair');
        if(isZoomed) ch.classList.add('zoomed'); else ch.classList.remove('zoomed');
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if(matCanvas) {
            matCanvas.width = window.innerWidth;
            matCanvas.height = window.innerHeight;
            initMatrix();
        }
    }

    init();
</script>
</body>
</html>
