<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Station Master: Terminal Velocity VIII</title>
    <style>
        /* FONTS */
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Montserrat:wght@800&family=Russo+One&family=Satisfy&family=Roboto+Mono:wght@400;500&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier Prime', monospace; user-select: none; }

        /* --- INTRO SPLASH (FIRST LOAD) --- */
        #intro-splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 1; transition: opacity 2s ease-out;
        }
        .intro-text {
            font-family: 'Satisfy', cursive;
            font-size: 42px; color: #eee;
            margin-bottom: 40px;
            text-align: center;
            padding: 0 20px;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        .dot { animation: blink-dot 1.4s infinite both; }
        .dot:nth-child(1) { animation-delay: 0s; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes blink-dot {
            0% { opacity: 0; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes flash-white {
            0% { border-color: #444; color: #888; box-shadow: 0 0 0 #000; }
            50% { border-color: #fff; color: #fff; box-shadow: 0 0 15px #fff; }
            100% { border-color: #444; color: #888; box-shadow: 0 0 0 #000; }
        }

        #intro-btn {
            background: #111; color: #888; border: 2px solid #444;
            padding: 15px 40px; font-family: 'Montserrat', sans-serif;
            font-size: 18px; letter-spacing: 2px; text-transform: uppercase;
            cursor: pointer; transition: 0.3s;
            animation: flash-white 2.5s infinite;
        }
        #intro-btn:hover {
            background: #eee; color: #000; border-color: #fff; animation: none;
        }

        /* --- READY OVERLAY (GAME START) --- */
        #ready-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(200, 190, 170, 0.15); /* Warmer fog */
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 150; display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #ready-msg {
            font-family: 'Montserrat', sans-serif; font-size: 30px; color: #fff;
            text-shadow: 0 0 10px #000; letter-spacing: 5px; margin-bottom: 30px;
            text-transform: uppercase; border-bottom: 2px solid #00FF00; padding-bottom: 10px;
        }
        #ready-btn {
            background: rgba(0, 0, 0, 0.8); color: #00FF00; border: 2px solid #00FF00;
            padding: 20px 60px; font-family: 'Russo One', sans-serif; font-size: 24px;
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #ready-btn:hover { background: #00FF00; color: #000; box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }

        /* --- RETURN OVERLAY (MENU RESTART) --- */
        #return-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 50, 50, 0.9); /* Grey overlay */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            z-index: 250; /* Above menu but below intro */
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #return-msg {
            font-family: 'Montserrat', sans-serif; font-size: 30px; color: #fff;
            text-shadow: 0 0 10px #000; letter-spacing: 5px; margin-bottom: 30px;
            text-transform: uppercase; border-bottom: 2px solid #FFCC00; padding-bottom: 10px;
        }
        #return-btn {
            background: rgba(0, 0, 0, 0.8); color: #FFCC00; border: 2px solid #FFCC00;
            padding: 20px 60px; font-family: 'Russo One', sans-serif; font-size: 24px;
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            text-transform: uppercase; letter-spacing: 2px;
        }
        #return-btn:hover { background: #FFCC00; color: #000; box-shadow: 0 0 40px rgba(255, 204, 0, 0.8); }


        /* --- VISUAL FX --- */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 15%, #000 60%);
            pointer-events: none; display: none; z-index: 10;
        }

        #blood-screen-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90; overflow: hidden; display: none;
        }
        .drip {
            position: absolute; top: -150px; width: 15px; background: #8a0303;
            border-radius: 0 0 15px 15px; opacity: 0.9; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            pointer-events: none; z-index: 11; transition: all 0.2s;
        }
        #crosshair.zoomed { 
            border-color: #00FF00; width: 200px; height: 200px; border-width: 1px; border-radius: 0;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><line x1="100" y1="0" x2="100" y2="200" stroke="%2300FF00" stroke-width="1"/><line x1="0" y1="100" x2="200" y2="100" stroke="%2300FF00" stroke-width="1"/></svg>');
        }

        /* --- UI --- */
        #top-ui-container {
            position: absolute; top: 0; left: 0; width: 100%; z-index: 20;
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #top-ui-container.minimized {
            transform: translateY(-92%); 
        }

        #top-ui {
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 90%, transparent 100%);
            padding: 10px 30px 20px 30px; display: flex; justify-content: space-between; align-items: flex-start;
            color: #00FF00; font-family: 'Montserrat', sans-serif; letter-spacing: 2px; font-size: 14px;
            text-shadow: 0 0 5px #00FF00; position: relative;
        }
        
        #ui-toggle-btn {
            position: absolute; bottom: -24px; left: 0; 
            background: rgba(0,0,0,0.8); color: #00FF00; border: 1px solid #005500; border-top: none; border-left: none;
            padding: 4px 15px; cursor: pointer; font-size: 10px; border-radius: 0 0 10px 0;
            text-shadow: 0 0 5px #00FF00; pointer-events: auto; display: flex; align-items: center; gap: 5px;
            font-family: 'Montserrat', sans-serif; letter-spacing: 1px;
        }
        #ui-toggle-btn:hover { background: #002200; }
        
        /* SKIP MUSIC BUTTON (Mirror Style) */
        #skip-music-btn {
            position: absolute; bottom: -24px; right: 0;
            background: rgba(0,0,0,0.8); color: #00FF00; border: 1px solid #005500; border-top: none; border-right: none;
            padding: 4px 15px; cursor: pointer; font-size: 10px; border-radius: 0 0 0 10px;
            text-shadow: 0 0 5px #00FF00; pointer-events: auto; display: flex; align-items: center; gap: 5px;
            font-family: 'Montserrat', sans-serif; letter-spacing: 1px;
            width: 80px; justify-content: center; box-sizing: border-box;
            height: 24px;
        }
        #skip-music-btn:hover { background: #002200; }
        
        /* RADIO TOGGLE BUTTON (Tab Style) */
        #radio-toggle-btn {
            position: absolute; bottom: -24px; right: 81px; /* Attached to left of Skip */
            background: rgba(0,0,0,0.8); color: #00FF00; border: 1px solid #005500; border-top: none; border-right: none;
            padding: 4px 10px; cursor: pointer; font-size: 10px; border-radius: 0 0 0 10px;
            text-shadow: 0 0 5px #00FF00; pointer-events: auto; display: flex; align-items: center; gap: 4px;
            font-family: 'Montserrat', sans-serif; letter-spacing: 1px; height: 24px; box-sizing: border-box;
        }
        #radio-toggle-btn:hover { background: #002200; }

        /* Small Toggle Switch inside Radio Tab */
        .bar-toggle-switch {
            width: 24px; height: 12px; background: #222; border: 1px solid #555; 
            border-radius: 6px; position: relative; 
            box-shadow: inset 0 0 3px #000;
        }
        .bar-toggle-knob {
            width: 8px; height: 8px; background: #888; border-radius: 50%;
            position: absolute; top: 1px; left: 1px; transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        /* States */
        .bar-toggle-switch.fm .bar-toggle-knob { left: 2px; background: #00FF00; box-shadow: 0 0 4px #00FF00; }
        .bar-toggle-switch.am .bar-toggle-knob { left: 13px; background: #FFCC00; box-shadow: 0 0 4px #FFCC00; }


        .arrow-icon { font-size: 14px; font-weight: bold; }

        /* TIMER FIXED */
        #fixed-timer-container {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            z-index: 25; pointer-events: none; display: none;
        }
        #timer-ui {
            font-family: 'Courier Prime', monospace; font-size: 24px; color: #FF0000;
            text-shadow: 0 0 10px #FF0000; border: 2px solid #550000;
            background: rgba(0,0,0,0.8); padding: 5px 15px; font-weight: bold;
        }

        .key-hint { color: #fff; background: rgba(0,255,0,0.2); padding: 2px 6px; border: 1px solid #00FF00; font-size: 11px; margin: 0 5px; }

        /* CUSTOM SLIDER STYLING */
        .vol-control { font-size: 10px; display: flex; align-items: center; margin-bottom: 8px; justify-content: flex-end; }
        .vol-label { width: 20px; text-align: center; margin-right: 5px; color: #888; font-size: 14px; }
        .vol-btn { color: #555; font-size: 12px; margin: 0 5px; font-weight: bold; cursor: pointer;}
        .vol-btn:hover { color: #fff; }
        
        input[type=range].tech-slider {
            -webkit-appearance: none; width: 140px; background: transparent; cursor: pointer; /* Extended width */
        }
        input[type=range].tech-slider:focus { outline: none; }
        input[type=range].tech-slider::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border: 1px solid #555;
        }
        input[type=range].tech-slider::-webkit-slider-thumb {
            height: 12px; width: 6px; background: #00FF00; cursor: pointer;
            -webkit-appearance: none; margin-top: -5px; box-shadow: 0 0 5px #00FF00;
        }

        #phone-overlay {
            position: absolute; bottom: -200px; right: 30px; width: 350px;
            background: rgba(10,10,10,0.95); border-left: 5px solid #FFCC00; 
            padding: 20px; color: white; box-shadow: 0 10px 40px rgba(0,0,0,1);
            transition: bottom 0.6s cubic-bezier(0.22, 1, 0.36, 1); z-index: 50;
        }
        .intel-header { font-family: 'Montserrat', sans-serif; font-size: 10px; color: #FFCC00; letter-spacing: 3px; margin-bottom: 5px; }
        .intel-body { font-size: 18px; font-weight: bold; color: #fff; font-family: 'Courier Prime', monospace; }

        /* --- MENUS --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }
        #matrix-canvas { position: absolute; top: 0; left: 0; z-index: 0; opacity: 0.25; }
        #chalk-outlines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.2; pointer-events: none; }
        .chalk-body {
            position: absolute; width: 100px; height: 180px;
            border: 2px dashed #fff; border-radius: 30% 30% 0 0; opacity: 0.6;
        }
        .chalk-body::after { content:''; position:absolute; top: -30px; left:25px; width:50px; height:50px; border: 2px dashed #fff; border-radius:50%; }

        .dossier {
            width: 700px; padding: 40px; background: #e8e4c9; color: #111; /* Beige/Sand */
            box-shadow: 0 0 100px rgba(0,0,0,1); transform: rotate(-0.5deg); position: relative;
            border: 1px solid #999; z-index: 5;
        }
        /* STAMP - Higher Z-Index than Bio */
        .stamp {
            position: absolute; top: 30px; right: 30px;
            border: 5px solid #C00; color: #C00; font-family: 'Montserrat', sans-serif;
            font-size: 40px; font-weight: 900; padding: 5px 20px;
            transform: rotate(12deg) scale(3); opacity: 0; mix-blend-mode: normal; /* Removed multiply to sit on top clearly */
            /* Default state hidden for animation */
            pointer-events: none; z-index: 25; /* Ensure on top of bio */
        }

        /* STAMP ANIMATION */
        @keyframes stamp-slam {
            0% { opacity: 0; transform: rotate(12deg) scale(3); }
            70% { opacity: 0.95; transform: rotate(12deg) scale(0.9); }
            100% { opacity: 1; transform: rotate(12deg) scale(1.0); }
        }
        .stamp.slammed {
            animation: stamp-slam 0.4s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes sheen { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
        h1 { 
            font-family: 'Montserrat', sans-serif; font-size: 40px; margin: 0 0 10px 0; 
            text-transform: uppercase; letter-spacing: -2px; border-bottom: 4px solid #111; 
            position: relative; overflow: hidden;
            background: linear-gradient(90deg, #111 0%, #111 45%, #555 50%, #111 55%, #111 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: sheen 3s infinite linear;
        }
        
        .mission-brief {
            background: #d3cba8; padding: 15px; border-left: 5px solid #111; /* Darker Sand */
            font-family: 'Courier Prime', monospace; font-size: 13px; margin: 15px 0; line-height: 1.4;
        }

        .streak-box {
            position: absolute; top: -20px; left: -20px; background: #000; color: #FFCC00;
            padding: 10px 20px; border: 2px solid #FFCC00; font-family: 'Montserrat', sans-serif;
            font-weight: bold; transform: rotate(-5deg); box-shadow: 5px 5px 0 rgba(0,0,0,0.5);
        }

        .leaderboard-box {
            position: absolute; top: 15%; right: -280px; transform: rotate(2deg);
            width: 250px; background: #111; border: 1px solid #444; color: #00FF00;
            padding: 20px; font-family: 'Montserrat', sans-serif;
            background-image: linear-gradient(0deg, transparent 24%, rgba(0, 255, 0, .05) 25%, rgba(0, 255, 0, .05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .05) 75%, rgba(0, 255, 0, .05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(0, 255, 0, .05) 25%, rgba(0, 255, 0, .05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .05) 75%, rgba(0, 255, 0, .05) 76%, transparent 77%, transparent);
            background-size: 30px 30px; box-shadow: -10px 10px 30px rgba(0,0,0,0.8);
        }
        
        .stats-box {
            position: absolute; top: 60%; right: -300px; transform: rotate(-1deg);
            width: 270px; background: #000; border: 2px solid #fff; color: #fff;
            padding: 15px; font-family: 'Courier Prime', monospace;
            box-shadow: -10px 10px 30px rgba(0,0,0,0.8);
        }
        .stats-title { text-align: center; border-bottom: 1px dashed #fff; margin-bottom: 10px; font-weight: bold; letter-spacing: 2px; }
        .stats-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; }
        .stats-val { font-weight: bold; color: #FFCC00; }
        
        .reset-btn-small { margin-top:5px; width: 100%; background: #222; border: 1px solid #555; color: #777; font-size: 10px; padding: 5px; cursor: pointer; text-transform: uppercase; }
        .reset-btn-small:hover { background: #500; color: #fff; border-color: #f00; }

        .lb-title { border-bottom: 2px solid #00FF00; font-size: 14px; letter-spacing: 2px; margin-bottom: 10px; padding-bottom: 5px; }
        .lb-row { display: flex; justify-content: space-between; font-family: 'Courier Prime', monospace; font-size: 12px; margin-bottom: 6px; color: #fff; }
        .lb-rank { color: #555; margin-right: 10px; }
        .lb-name { color: #00FF00; margin-right: 5px; }
        .lb-time { color: #FFCC00; font-weight: bold; }

        #award-text {
            font-family: 'Russo One', sans-serif; font-size: 32px; color: #444;
            margin-top: 10px; text-transform: uppercase; letter-spacing: 2px;
            background: linear-gradient(45deg, #998800, #FFDD00, #998800);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2); font-style: italic;
        }

        .settings-box {
            background: #333; color: #fff; padding: 15px; margin-top: 15px;
            border: 1px solid #555; font-family: 'Montserrat', sans-serif;
        }
        .slider-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .slider-row label { font-size: 12px; letter-spacing: 1px; width: 150px; }
        .slider-row input[type=range] { flex-grow: 1; margin: 0 15px; cursor: pointer; }
        .slider-row span { font-weight: bold; color: #FFCC00; width: 30px; text-align: right; }
        
        .chk-group { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .chk-label { font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: #ccc; }
        .chk-label input:checked + span { color: #00FF00; text-shadow: 0 0 5px #00FF00; font-weight: bold; }

        .preset-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .preset-btn {
            flex: 1; background: #222; color: #888; border: 1px solid #444;
            font-size: 10px; padding: 5px; cursor: pointer; font-family: 'Montserrat', sans-serif;
            letter-spacing: 1px; transition: 0.2s;
        }
        .preset-btn:hover { background: #444; color: #fff; border-color: #888; }
        
        /* CLASSY DIFFICULTY BUTTON STYLES */
        #btn-easy { border-bottom: 2px solid #00AA00; }
        #btn-easy:hover { background: #002200; color: #00FF00; border-color: #00FF00; }
        
        #btn-med { border-bottom: 2px solid #AA6600; }
        #btn-med:hover { background: #221100; color: #FFAA00; border-color: #FFAA00; }
        
        #btn-hard { border-bottom: 2px solid #AA0000; }
        #btn-hard:hover { background: #220000; color: #FF0000; border-color: #FF0000; }

        .btn-row { display: flex; gap: 15px; margin-top: 15px; }
        
        @keyframes pulse-btn {
            0% { box-shadow: 0 0 0 0 rgba(123, 44, 191, 0.4); } /* Purple Pulse */
            70% { box-shadow: 0 0 0 10px rgba(123, 44, 191, 0); }
            100% { box-shadow: 0 0 0 0 rgba(123, 44, 191, 0); }
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner {
            border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid #fff;
            border-radius: 50%; width: 20px; height: 20px;
            animation: spin 1s linear infinite; margin: 0 auto;
        }

        button.action-btn {
            width: 100%; background: #111; color: white; border: none; padding: 15px;
            font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 16px;
            text-transform: uppercase; letter-spacing: 2px; cursor: pointer; transition: 0.3s;
            animation: pulse-btn 2s infinite; height: 50px;
        }
        button.action-btn:hover { background: #7b2cbf; transform: scale(1.02); animation: none; }
        button.action-btn.clicked {
            animation: none; transform: scale(0.95); background: #333; box-shadow: inset 0 0 10px #000; border: 1px solid #555;
        }

        button.sec-btn { background: #222; border: 1px solid #444; color: #aaa; animation: none; }
        button.sec-btn:hover { background: #004400; color: #fff; border-color: #00FF00; }

        /* End game button container for stacking */
        .end-btn-container {
            display: flex; flex-direction: column; gap: 15px; margin-top: 30px; width: 100%;
        }
        
        #restart-ui { position: absolute; bottom: 20px; left: 20px; z-index: 60; }
        #restart-btn { background: #333; color: #aaa; border: 1px solid #555; padding: 10px; font-family: sans-serif; font-size: 10px; cursor: pointer; text-transform: uppercase; }
        #restart-btn:hover { background: #C00; color: #fff; border-color: #C00; }

        /* HIGH SCORE MODAL */
        #high-score-modal {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .hs-content {
            background: #111; border: 2px solid #555; padding: 40px;
            text-align: center; font-family: 'Courier Prime', monospace;
            box-shadow: 0 0 50px #000; border-top: 5px solid #00FF00;
        }
        .hs-title { font-size: 24px; color: #00FF00; margin-bottom: 20px; font-weight: bold; font-family: 'Montserrat', sans-serif; letter-spacing: 2px;}
        #new-record-time { font-family: 'Russo One', sans-serif; font-size: 40px; color: #FFCC00; margin-bottom: 20px; }
        #hs-input {
            background: #222; border: 2px solid #00FF00; color: #fff;
            font-size: 40px; text-transform: uppercase; text-align: center;
            width: 200px; padding: 10px; font-family: 'Courier Prime', monospace;
            margin: 20px 0; letter-spacing: 10px;
        }
        #hs-input:focus { outline: none; background: #003300; }

        /* CUSTOM CONFIRM MODAL */
        #confirm-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 300;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .confirm-box {
            background: #111; border: 2px solid #FFCC00; padding: 30px; width: 400px;
            text-align: center; font-family: 'Montserrat', sans-serif; color: #fff;
            box-shadow: 0 0 40px rgba(255, 204, 0, 0.2);
            position: relative;
        }
        .confirm-title { font-size: 20px; color: #FFCC00; border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 20px; letter-spacing: 2px; }
        .confirm-msg { font-size: 14px; margin-bottom: 30px; font-family: 'Courier Prime', monospace; color: #ccc; line-height: 1.5; }
        .confirm-btn-row { display: flex; gap: 20px; justify-content: center; }
        .conf-btn { padding: 10px 20px; font-family: 'Montserrat', sans-serif; font-weight: bold; cursor: pointer; border: 1px solid #444; transition: 0.2s; font-size: 12px; }
        .btn-yes { background: #300; color: #f55; border-color: #500; }
        .btn-yes:hover { background: #f00; color: #fff; }
        .btn-no { background: #222; color: #aaa; }
        .btn-no:hover { background: #444; color: #fff; }
        .warning-stripe {
            position: absolute; top: -10px; left: -10px; background: #FFCC00; color: #000;
            font-size: 10px; padding: 5px; font-weight: bold; transform: rotate(-5deg); border: 2px solid #000;
        }


        /* VERTICAL MENU SLIDER */
        #menu-vol-container {
            position: absolute; top: 50%; left: -70px;
            transform: translateY(-50%) rotate(-90deg);
            display: flex; align-items: center; gap: 10px;
            background: #111; padding: 8px; border: 1px solid #444;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.8); z-index: 6;
        }
        #menu-vol-container label { font-size: 9px; color: #888; letter-spacing: 2px; font-family: 'Montserrat', sans-serif; }
        input[type=range].vertical-slider {
            -webkit-appearance: none; width: 80px; background: transparent; cursor: pointer;
        }
        input[type=range].vertical-slider:focus { outline: none; }
        input[type=range].vertical-slider::-webkit-slider-runnable-track { width: 100%; height: 2px; background: #555; }
        input[type=range].vertical-slider::-webkit-slider-thumb {
            height: 10px; width: 10px; background: #00FF00; cursor: pointer;
            -webkit-appearance: none; margin-top: -4px; border-radius: 50%;
        }

        /* BIO / TOP TRUMPS CARD - REDESIGNED */
        #bio-overlay {
            width: 100%; 
            background: #e6e2d3; /* Textured Sand/Beige */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzjwqonyABJILoIi4Hw9ZQAz9wz/T6+R/wAAAABJRU5ErkJggg=='); /* Noise texture */
            border: 1px solid #999;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2), 0 0 15px rgba(0,0,0,0.1) inset;
            margin-top: 15px; 
            margin-bottom: 20px; 
            padding: 20px; 
            display: none;
            font-family: 'Courier Prime', monospace;
            text-align: left;
            position: relative;
            z-index: 5; /* Lower than stamp */
            color: #333;
            transform: rotate(-0.5deg);
        }
        
        /* Rough paper edges effect */
        #bio-overlay::before {
            content: ''; position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px;
            border: 1px dashed #bbb; pointer-events: none;
        }

        .bio-header {
            display: flex; justify-content: space-between; border-bottom: 2px solid #555;
            padding-bottom: 5px; margin-bottom: 15px; color: #555; font-size: 11px; font-weight: bold;
        }
        .bio-row {
            display: flex; margin-bottom: 8px; font-size: 13px; align-items: baseline;
        }
        .bio-label { width: 130px; color: #777; text-transform: uppercase; font-size: 10px; letter-spacing: 1px; font-family: 'Montserrat', sans-serif; font-weight: bold; }
        .bio-val { color: #222; font-weight: bold; font-family: 'Courier Prime', monospace; }
        
        .italic-val { font-style: italic; color: #444; }

        .bio-photo {
            position: absolute; top: 50px; right: 20px; width: 80px; height: 100px;
            background: #ddd; border: 4px solid #fff; box-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; transform: rotate(2deg); z-index: 10;
        }
        .bio-photo svg { width: 100%; height: 100%; fill: #555; background: #ccc; }
        
        .bio-stamp {
            position: absolute; top: 80px; left: 0px; 
            border: 3px solid #C00;
            color: #C00; font-weight: bold; font-size: 18px; padding: 2px 8px; 
            transform: rotate(-15deg); opacity: 0.6; font-family: 'Montserrat', sans-serif;
            z-index: 5;
        }
        
        /* Read More Animation Logic */
        .bio-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.6s ease-in-out, opacity 0.6s ease-in-out;
            opacity: 0;
        }
        .bio-details.open {
            max-height: 300px; /* Enough to show all */
            opacity: 1;
        }

        .read-more-btn {
            background: transparent; color: #555; border: 1px solid #888;
            font-size: 10px; width: 100%; padding: 6px; cursor: pointer; margin-top: 15px;
            font-family: 'Montserrat', sans-serif; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.2s;
        }
        .read-more-btn:hover { background: #555; color: #fff; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <audio id="sfx-ambience" loop>
        <source src="ambience.mp3" type="audio/mp3">
    </audio>
    <audio id="menu-bgm" loop>
        <source src="menumusic.mp3" type="audio/mp3">
    </audio>

    <div id="intro-splash">
        <div class="intro-text">
            So... are you ready to die for your country<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>
        </div>
        <button id="intro-btn" onclick="enterGame()">Yes I am</button>
    </div>

    <div id="ready-overlay">
        <div id="ready-msg">Area Secure</div>
        <button id="ready-btn" onclick="confirmReady()">I'm Ready</button>
    </div>

    <div id="return-overlay">
        <div id="return-msg">System Rebooted</div>
        <button id="return-btn" onclick="confirmReturn()">Resume Operation</button>
    </div>

    <div id="confirm-modal">
        <div class="confirm-box">
            <div class="warning-stripe">IRREVERSIBLE</div>
            <div class="confirm-title">SYSTEM PURGE</div>
            <div class="confirm-msg">
                Are you sure you want to wipe all data?
                <br><br>
                <span style="color:#f55;">THIS ACTION CANNOT BE UNDONE.</span>
            </div>
            <div class="confirm-btn-row">
                <button class="conf-btn btn-yes" onclick="performReset()">CONFIRM PURGE</button>
                <button class="conf-btn btn-no" onclick="closeConfirm()">CANCEL</button>
            </div>
        </div>
    </div>

    <div id="top-ui-container" class="minimized">
        <div id="top-ui">
            <div style="margin-top:10px;">
                <span class="key-hint">WASD</span> AIM 
                <span class="key-hint">SPACE</span> ZOOM 
                <span class="key-hint">F</span> FIRE
            </div>
            <div style="display:flex; align-items:center; gap:20px;">
                <div style="display:flex; flex-direction: column; align-items: flex-end;">

                    <div class="vol-control" id="vol-music-container">
                        <span class="vol-label">&#9834;</span>
                        <span class="vol-btn" onclick="nextTrack()">[>>]</span>
                        <span class="vol-btn">[-]</span>
                        <input type="range" id="vol-music-slider" class="tech-slider" min="0" max="1" step="0.02" value="0.3">
                        <span class="vol-btn">[+]</span>
                    </div>
                    <div class="vol-control" id="vol-sfx-container">
                        <span class="vol-label" style="margin-right:20px;">SFX</span>
                        <span class="vol-btn">[-]</span>
                        <input type="range" id="vol-sfx-slider" class="tech-slider" min="0" max="1" step="0.02" value="0.8">
                        <span class="vol-btn">[+]</span>
                    </div>
                </div>
                <div style="font-size:16px;">UNIT: 00-WATCHMAN</div>
            </div>
            <button id="ui-toggle-btn" onclick="toggleTopUI()">
                <span class="arrow-icon" id="toggle-icon">^</span>
                <span id="toggle-text">OPEN MENU</span>
            </button>
            
            <button id="radio-toggle-btn" onclick="toggleRadioMode()">
                <span style="font-size:10px; margin-right:5px;">RADIO</span>
                <span id="label-fm" style="font-size:9px; color:#00FF00; margin-right:4px;">FM</span>
                <div class="bar-toggle-switch fm" id="bar-radio-switch">
                    <div class="bar-toggle-knob"></div>
                </div>
                <span id="label-am" style="font-size:9px; color:#444; margin-left:4px;">AM</span>
            </button>

            <button id="skip-music-btn" onclick="nextTrack()">
                <span style="font-size:10px;">SKIP</span>
                <span class="arrow-icon">>></span>
            </button>
        </div>
    </div>

    <div id="fixed-timer-container">
        <div id="timer-ui">00.000</div>
    </div>

    <div id="scope-overlay"></div>
    <div id="crosshair"></div>
    <div id="blood-screen-container"></div>
    
    <div id="phone-overlay" data-phase="0">
        <div class="intel-header">INCOMING TRANSMISSION</div>
        <div class="intel-body" id="phone-text">CONNECTING...</div>
    </div>
    
    <div id="high-score-modal">
        <div class="hs-content">
            <div class="hs-title">RECORD BREAKER</div>
            <div id="new-record-time">00.000s</div>
            <div style="font-size:12px; color:#aaa;">ENTER INITIALS:</div>
            <input type="text" id="hs-input" maxlength="3" placeholder="___">
            <br>
            <button class="action-btn" style="width:auto; padding:10px 30px; margin-top:20px;" onclick="submitScore()">SUBMIT</button>
        </div>
    </div>

    <div id="menu">
        <canvas id="matrix-canvas"></canvas>
        <div id="chalk-outlines"></div>
        
        <div class="dossier" id="start-dossier">
            <div id="menu-vol-container">
                <label>MENU AUDIO</label>
                <input type="range" id="slide-menu-vol" class="vertical-slider" min="0" max="1" step="0.1" value="0.5" oninput="updateMenuVol()">
            </div>

            <div class="leaderboard-box">
                <div class="lb-title">TOP 5 AGENTS (SPEED)</div>
                <div id="lb-content"></div>
            </div>

            <div class="stats-box">
                <div class="stats-title">FIELD REPORT</div>
                <div class="stats-row"><span>TARGET COURIERS</span> <span class="stats-val" id="stat-target">0</span></div>
                <div class="stats-row"><span>DECOYS HIT</span> <span class="stats-val" id="stat-decoy">0</span></div>
                <div class="stats-row"><span>BYSTANDERS HIT</span> <span class="stats-val" id="stat-civ">0</span></div>
                <div class="stats-row"><span>ABORTS</span> <span class="stats-val" id="stat-abort">0</span></div>
                <div style="display:flex; gap:10px; width:100%; margin-top:10px;">
                    <button class="reset-btn-small" onclick="triggerReset('LEADERBOARD')">[ RESET TIMES ]</button>
                    <button class="reset-btn-small" onclick="triggerReset('STATS')">[ RESET STATS ]</button>
                </div>
            </div>

            <div class="streak-box" id="menu-streak-box">STREAK: <span id="streak-display">0</span></div>
            <div class="stamp" style="opacity:0.8; transform: rotate(12deg) scale(1);">TOP SECRET</div>
            <h1>Operation: Terminus</h1>
            
            <div class="mission-brief">
                <p>> <strong>THE SITUATION:</strong> Multiple subjects carrying <span style="background:#FF0; color:#000; padding:0 2px;">YELLOW PACKAGES</span> have entered the concourse.</p>
                <p>> <strong>THE TARGET:</strong> Only <strong>ONE</strong> is heading to the correct train. The rest are decoys or shoppers.</p>
                <p>> <strong>EXECUTION:</strong> Wait for INTEL. Check the BOARD (Randomized). Eliminate the courier boarding the CORRECT train.</p>
            </div>

            <div class="settings-box">
                <div class="preset-row">
                    <button id="btn-easy" class="preset-btn" onclick="setDifficulty('EASY')">EASY</button>
                    <button id="btn-med" class="preset-btn" onclick="setDifficulty('MEDIUM')">MEDIUM</button>
                    <button id="btn-hard" class="preset-btn" onclick="setDifficulty('HARD')">HARD</button>
                </div>
                <div class="slider-row">
                    <label>CROWD DENSITY</label>
                    <input type="range" id="slide-crowd" min="117" max="499" value="80" oninput="updateUI()">
                    <span id="val-crowd">80</span>
                </div>
                <div class="slider-row">
                    <label>PACKAGE HOLDERS</label>
                    <input type="range" id="slide-pkg" min="2" max="99" value="4" oninput="updateUI()">
                    <span id="val-pkg">4</span>
                </div>
                <hr style="border-color:#555; margin:15px 0;">
                <div class="slider-row">
                    <label>AUDIO CONFIG</label>
                    <div class="chk-group">
                        <label class="chk-label">
                            <input type="checkbox" id="chk-music" checked onchange="updateUI()"> 
                            <span>GAME MUSIC</span>
                        </label>
                        <label class="chk-label">
                            <input type="checkbox" id="chk-random-pl" onchange="updateUI()"> 
                            <span>RANDOM PLAYLIST</span>
                        </label>
                        <label class="chk-label">
                            <input type="checkbox" id="chk-sfx" checked onchange="updateUI()"> 
                            <span>AMBIENCE</span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="btn-row">
                <button id="btn-fun" class="action-btn" onclick="initiateGame('STREAK', this)">PLAY FOR FUN</button>
                <button id="btn-speed" class="action-btn sec-btn" onclick="initiateGame('TIMED', this)">PLAY FOR SPEED</button>
            </div>
        </div>

        <div class="dossier" id="end-dossier" style="display:none; text-align:center;">
            <div class="stamp" id="end-stamp">CLEARED</div>
            
            <!-- Result Headers -->
            <div id="result-headers" style="margin-bottom:20px;">
                <h1 id="outcome-title" style="margin-bottom:10px;">REPORT</h1>
                <p id="outcome-desc" style="font-size:18px; font-weight:bold; color: #ccc;">...</p>
                <div id="award-text"></div>
            </div>
            
            <!-- BIO OVERLAY (GUILT TRIP) -->
            <div id="bio-overlay">
                <div class="bio-photo" id="bio-pic"></div>
                <div class="bio-header">
                    <span>BIO-ID: <span id="bio-id-num">4492-X</span></span>
                    <span>CITIZEN RECORD</span>
                </div>
                
                <!-- Always Visible -->
                <div class="bio-row"><span class="bio-label">FULL NAME</span><span class="bio-val" id="bio-name">JANE DOE</span></div>
                
                <!-- Hidden by Default -->
                <div id="bio-masked-area" class="bio-details">
                    <div class="bio-row"><span class="bio-label">DOB</span><span class="bio-val" id="bio-dob">12 MAY 1984</span></div>
                    <div class="bio-row"><span class="bio-label">SOCIAL SEC. ID</span><span class="bio-val" id="bio-ssn">QQ-12-34-56-A</span></div>
                    <div class="bio-row"><span class="bio-label">BLOOD TYPE</span><span class="bio-val" id="bio-blood">O+</span></div>
                    <div class="bio-row"><span class="bio-label">NATIONALITY</span><span class="bio-val" id="bio-nation">BRITISH</span></div>
                    <div style="border-top:1px dashed #777; margin:8px 0;"></div>
                    <div class="bio-row"><span class="bio-label">FAV MOVIE</span><span class="bio-val italic-val" id="bio-movie">SHREK 2</span></div>
                    <div class="bio-row"><span class="bio-label">FAV ALBUM</span><span class="bio-val italic-val" id="bio-music">UNKNOWN PLEASURES</span></div>
                </div>

                <button id="bio-read-more" class="read-more-btn" onclick="revealBio()">READ MORE ABOUT THIS PERSON...</button>
                <div class="bio-stamp">DECEASED</div>
            </div>

            <div class="end-btn-container">
                <button class="action-btn" onclick="reloadWithFade()">NEW ASSIGNMENT >></button>
                <button id="replay-btn" class="action-btn sec-btn" onclick="replaySameSettings()">REPLAY WITH SAME SETTINGS</button>
            </div>
        </div>
    </div>
    
    <div id="restart-ui">
        <button id="restart-btn" onclick="abortMission()">ABORT / RESTART</button>
    </div>

<script>
    // --- DATABASE GENERATORS ---
    const BIO_DATA = {
        // Updated with diverse names for British nationality spread
        maleNames: [
            // Traditional
            "James", "David", "Robert", "Mohammed", "Thomas", "William", "Daniel", "Jack", "Lucas", "Ethan", "Alexander", "Benjamin", "Jacob", "Michael", "Joshua", "Harry", "Samuel", "Matthew", "Joseph", "Callum", "George", "Oscar", "Charlie", "Leo", "Connor", "Adam", "Liam", "Noah", "Mason", "Kieran", "Ryan", "Nathan", "Aaron", "Luke", "Henry", "Isaac", "Oliver", "Teddy", "Finley", "Max", "Harrison", "Edward", "Sebastian", "Arthur", "Freddie", "Theo", "Toby", "Jude", "Rory", "Louis", "Elijah", "Hugo", "Bobby", "Albert", "Reuben", "Frankie", "Albie", "Stanley", "Luca", "Jaxon", "Gabriel", "Blake", "Carter", "Caleb", "Hunter", "Elliot", "Austin", "Ronnie", "Ezra", "Ellis", "Kai", "Reggie", "Alex", "Jasper", "Rowan", "Jesse", "Finn", "Riley", "Seth", 
            // Diverse Additions (Muslim, Sikh, European, etc.)
            "Ibrahim", "Sonny", "Oakley", "Piotr", "Dmitri", "Hassan", "Wei", "Arjun", "Tariq", "Santiago", "Diego", "Muhammad", "Omar", "Ali", "Yusuf", "Zain", "Hamza", "Bilal", "Mustafa", "Abdullah", "Ishaan", "Rohan", "Aarav", "Vihaan", "Aditya", "Sai", "Reyansh", "Mateo", "Jakub", "Lukas", "Sven", "Lars", "Giovanni", "Antonio", "Carlos", "Javier", "Hiroshi", "Kenji", "Min-Ho", "Wei-Jie", "Ahmed", "Mahmoud", "Sultan", "Kabir", "Aryan", "Gurdeep", "Manpreet", "Raj", "Amit", "Vikram", "Kacper", "Jan", "Stefan", "Marek"
        ],
        femaleNames: [
            // Traditional
            "Sarah", "Priya", "Aisha", "Emma", "Julie", "Olivia", "Sophie", "Chloe", "Amara", "Zara", "Mia", "Grace", "Lily", "Ava", "Emily", "Isla", "Ella", "Charlotte", "Harper", "Evelyn", "Aaliyah", "Ruby", "Sienna", "Alice", "Freya", "Niamh", "Eva", "Sofia", "Elena", "Maya", "Layla", "Scarlett", "Aria", "Mila", "Eliza", "Lola", "Jasmine", "Daisy", "Violet", "Bella", "Rose", "Imogen", "Florence", "Matilda", "Phoebe", "Elizabeth", "Lucy", "Hannah", "Eleanor", "Holly", "Lilly", "Georgia", "Amber", "Megan", "Bethany", "Abigail", "Gracie", "Harriet", "Iris", "Erin", "Annabelle", "Lottie", "Amelia", "Felicity", "Heidi", "Martha", "Penelope", "Lara", "Sara", "Robyn", "Nancy", "Darcie", "Clara", "Orla", "Summer", "Edith", "Molly", "Bonnie", "Maria", 
            // Diverse Additions
            "Maryam", "Lacey", "Hollie", "Esme", "Lena", "Elena", "Fatima", "Mei", "Ananya", "Yasmin", "Camila", "Valentina", "Zainab", "Zoya", "Amira", "Noor", "Khadija", "Hana", "Sana", "Iqra", "Diya", "Anjali", "Simran", "Kavita", "Riya", "Saanvi", "Aditi", "Ishita", "Sneha", "Katarzyna", "Ana", "Isabella", "Marta", "Agnieszka", "Yuki", "Sakura", "Ji-Woo", "Hui", "Ling", "Farida", "Salma", "Rania", "Nadia", "Parveen", "Sunita", "Gurpreet", "Rajni", "Meera"
        ],
        lastNames: [
            // Traditional
            "Smith", "Jones", "Taylor", "Williams", "Brown", "Davies", "Evans", "Wilson", "Thomas", "Roberts", "Johnson", "Lewis", "Robinson", "Walker", "Wright", "Thompson", "White", "Hughes", "Edwards", "Green", "Hall", "Wood", "Harris", "Clark", "Jackson", "Clarke", "Scott", "Turner", "Hill", "Phillips", "Cooper", "Mason", "Ward", "Morris", "Martin", "Baker", "Harrison", "Morgan", "King", "Allen", "James", "Moore", "Parker", "Lee", "Davis", "Bennett", "Mitchell", "Bailey", "Adams", "Richardson", "Carter", "Watson", "Cook", "Collins", "Bell", "Shaw", "Murphy", "Miller", "Cox", "Kelly", "Simpson", "Marshall", "Griffiths", "Anderson", "Ellis", "Rogers", "Stevens", "Murray", "Reynolds", "Gray", "Price", "Hunt", "Fox", "Mills", "Owen", "Palmer", "Lloyd", "Barnes", "Booth", "Barker", "Graham", "Jenkins", "Powell", "Butler", "Foster", "Russell", "Saunders", "Fisher", "Harvey", "Chapman", "Pearson", "Walsh", "Lawrence", "Webb", "Gibson", "Yates", "Brooks", "West", "Gardner", "Stone", "Andrews", "Gill", "Dawson", 
            // Diverse Additions
            "Patel", "Khan", "Ali", "Ahmed", "Hussain", "Begum", "Kaur", "Singh", "Shah", "Miah", "Rahman", "Uddin", "Akhtar", "Chowdhury", "Malik", "Bi", "Mahmood", "Iqbal", "Khatun", "Fernandes", "Silva", "Santos", "Oliveira", "Pereira", "Costa", "Rodrigues", "Martins", "Nowak", "Kowalski", "Wisniewski", "Wojcik", "Kamiński", "Lewandowski", "Zieliński", "Szymański", "Ivanov", "Smirnov", "Kuznetsov", "Popov", "Vasiliev", "Petrov", "Sokolov", "Mikhailov", "Sharma", "Gupta", "Kumar", "Verma", "Mehta", "Reddy", "Nair", "Iyer", "Nguyen", "Tran", "Le", "Pham", "Hoang", "Kim", "Lee", "Park", "Choi", "Jeong", "Chen", "Wang", "Li", "Zhang", "Liu", "Yang", "Huang", "Wu"
        ],
        nationalities: ["BRITISH", "BRITISH", "BRITISH", "BRITISH", "BRITISH", "BRITISH", "BRITISH", "IRISH", "SCOTTISH", "WELSH", "FRENCH", "GERMAN", "POLISH", "AMERICAN", "CANADIAN", "AUSTRALIAN", "INDIAN", "PAKISTANI", "BANGLADESHI", "CHINESE", "JAPANESE", "SPANISH", "ITALIAN", "BRAZILIAN", "NIGERIAN", "SOUTH AFRICAN", "JAMAICAN", "SWEDISH", "NORWEGIAN", "DUTCH", "ROMANIAN", "BULGARIAN", "UKRAINIAN", "RUSSIAN", "TURKISH", "GREEK"],
        wildcardNations: ["SEALAND", "VATICAN CITY", "ANTARCTICA", "ISLE OF MAN", "GUERNSEY", "JERSEY", "GIBRALTAR", "FALKLAND ISLANDS", "UNKNOWN", "STATELESS", "GALACTIC FED", "NARNIA"],
        movies: [
            "The Godfather (Dir. Coppola)", "Shrek 2 (Dir. Adamson)", "Paddington 2 (Dir. King)", "Pulp Fiction (Dir. Tarantino)", "The Dark Knight (Dir. Nolan)", "Spirited Away (Dir. Miyazaki)", "Parasite (Dir. Bong)", "Trainspotting (Dir. Boyle)", "Hot Fuzz (Dir. Wright)", "Shaun of the Dead (Dir. Wright)", "Mean Girls (Dir. Waters)", "Legally Blonde (Dir. Luketic)", "Inception (Dir. Nolan)", "Interstellar (Dir. Nolan)", "Titanic (Dir. Cameron)", "The Matrix (Dir. Wachowskis)", "Goodfellas (Dir. Scorsese)", "Fight Club (Dir. Fincher)", "Forrest Gump (Dir. Zemeckis)", "The Lion King (Dir. Allers)", "Back to the Future (Dir. Zemeckis)", "Blade Runner 2049 (Dir. Villeneuve)", "1917 (Dir. Mendes)", "Dunkirk (Dir. Nolan)", "Skyfall (Dir. Mendes)", "Casino Royale (Dir. Campbell)", "No Time To Die (Dir. Fukunaga)", "Pride & Prejudice (Dir. Wright)", "Atonement (Dir. Wright)", "The Grand Budapest Hotel (Dir. Anderson)", "Moonlight (Dir. Jenkins)", "La La Land (Dir. Chazelle)", "Get Out (Dir. Peele)", "Everything Everywhere (Dir. Daniels)", "Aftersun (Dir. Wells)", "Banshees of Inisherin (Dir. McDonagh)", "Top Gun: Maverick (Dir. Kosinski)", "Avatar (Dir. Cameron)", "Avengers: Endgame (Dir. Russos)", "Spider-Man 2 (Dir. Raimi)", "The Incredibles (Dir. Bird)", "Ratatouille (Dir. Bird)", "Wall-E (Dir. Stanton)", "Up (Dir. Docter)", "Toy Story 3 (Dir. Unkrich)", "Finding Nemo (Dir. Stanton)", "Monsters Inc (Dir. Docter)", "Frozen (Dir. Buck)", "Moana (Dir. Clements)", "Tangled (Dir. Greno)", "The Princess Diaries (Dir. Marshall)", "The Devil Wears Prada (Dir. Frankel)", "Mamma Mia! (Dir. Lloyd)", "Les Misérables (Dir. Hooper)", "The Greatest Showman (Dir. Gracey)", "Bohemian Rhapsody (Dir. Singer)", "Rocketman (Dir. Fletcher)", "Elvis (Dir. Luhrmann)", "Oppenheimer (Dir. Nolan)", "Barbie (Dir. Gerwig)", "Dune (Dir. Villeneuve)", "Arrival (Dir. Villeneuve)", "Her (Dir. Jonze)", "Ex Machina (Dir. Garland)", "Mad Max: Fury Road (Dir. Miller)", "Joker (Dir. Phillips)", "Taxi Driver (Dir. Scorsese)", "Apocalypse Now (Dir. Coppola)", "The Shining (Dir. Kubrick)", "2001: A Space Odyssey (Dir. Kubrick)", "A Clockwork Orange (Dir. Kubrick)", "Full Metal Jacket (Dir. Kubrick)", "Reservoir Dogs (Dir. Tarantino)", "Kill Bill (Dir. Tarantino)", "Inglourious Basterds (Dir. Tarantino)", "Django Unchained (Dir. Tarantino)", "The Hateful Eight (Dir. Tarantino)", "Once Upon a Time in Hollywood (Dir. Tarantino)", "Eternal Sunshine (Dir. Gondry)", "Lost in Translation (Dir. Coppola)", "Amélie (Dir. Jeunet)", "Pan's Labyrinth (Dir. del Toro)", "Roma (Dir. Cuarón)", "Gravity (Dir. Cuarón)", "Birdman (Dir. Iñárritu)", "The Revenant (Dir. Iñárritu)", "Whiplash (Dir. Chazelle)", "Black Swan (Dir. Aronofsky)", "The Wrestler (Dir. Aronofsky)", "Requiem for a Dream (Dir. Aronofsky)", "Donnie Darko (Dir. Kelly)", "American Psycho (Dir. Harron)", "The Social Network (Dir. Fincher)", "Zodiac (Dir. Fincher)", "Se7en (Dir. Fincher)", "Gone Girl (Dir. Fincher)", "Knives Out (Dir. Johnson)", "Glass Onion (Dir. Johnson)", "Lady Bird (Dir. Gerwig)", "Little Women (Dir. Gerwig)", "Frances Ha (Dir. Baumbach)", "Marriage Story (Dir. Baumbach)", "The Meyerowitz Stories (Dir. Baumbach)", "Uncut Gems (Dir. Safdies)", "Good Time (Dir. Safdies)", "The Lighthouse (Dir. Eggers)", "The Witch (Dir. Eggers)", "Midsommar (Dir. Aster)", "Hereditary (Dir. Aster)", "Us (Dir. Peele)", "Nope (Dir. Peele)", "Call Me by Your Name (Dir. Guadagnino)", "Suspiria (Dir. Guadagnino)", "Challengers (Dir. Guadagnino)", "Past Lives (Dir. Song)", "Minari (Dir. Chung)", "The Farewell (Dir. Wang)", "Crazy Rich Asians (Dir. Chu)", "Memories of Murder (Dir. Bong)", "Oldboy (Dir. Park)", "The Handmaiden (Dir. Park)", "Burning (Dir. Lee)", "Drive My Car (Dir. Hamaguchi)", "Shoplifters (Dir. Kore-eda)", "My Neighbor Totoro (Dir. Miyazaki)", "Princess Mononoke (Dir. Miyazaki)", "Howl's Moving Castle (Dir. Miyazaki)", "Kiki's Delivery Service (Dir. Miyazaki)", "Ponyo (Dir. Miyazaki)", "The Wind Rises (Dir. Miyazaki)", "The Boy and the Heron (Dir. Miyazaki)", "Akira (Dir. Otomo)", "Ghost in the Shell (Dir. Oshii)", "Perfect Blue (Dir. Kon)", "Paprika (Dir. Kon)", "Your Name (Dir. Shinkai)", "Weathering With You (Dir. Shinkai)", "Suzume (Dir. Shinkai)", "Godzilla Minus One (Dir. Yamazaki)", "Shin Godzilla (Dir. Anno)", "Stalker (Dir. Tarkovsky)", "Solaris (Dir. Tarkovsky)", "Mirror (Dir. Tarkovsky)", "Come and See (Dir. Klimov)", "Battleship Potemkin (Dir. Eisenstein)", "The Seventh Seal (Dir. Bergman)", "Persona (Dir. Bergman)", "Wild Strawberries (Dir. Bergman)", "8½ (Dir. Fellini)", "La Dolce Vita (Dir. Fellini)", "Bicycle Thieves (Dir. De Sica)", "Breathless (Dir. Godard)", "The 400 Blows (Dir. Truffaut)", "Seven Samurai (Dir. Kurosawa)", "Rashomon (Dir. Kurosawa)", "Tokyo Story (Dir. Ozu)", "Chungking Express (Dir. Wong)", "In the Mood for Love (Dir. Wong)", "Fallen Angels (Dir. Wong)", "Happy Together (Dir. Wong)", "Beau Travail (Dir. Denis)", "La Haine (Dir. Kassovitz)", "City of God (Dir. Meirelles)", "Y Tu Mamá También (Dir. Cuarón)", "Amores Perros (Dir. Iñárritu)"
        ],
        globalAlbums: [
             "Clube da Esquina - Milton Nascimento", "Construção - Chico Buarque", "Getz/Gilberto - Stan Getz & João Gilberto", "Os Mutantes - Os Mutantes", "Tropicalia: Ou Panis et Circencis", "Solid State Survivor - YMO", "Merry Christmas Mr. Lawrence - Ryuichi Sakamoto", "First Love - Utada Hikaru", "Fantasma - Cornelius", "Modal Soul - Nujabes", "Coke Studio Season 12 - Rohail Hyatt", "Night Song - Nusrat Fateh Ali Khan", "Mustt Mustt - Nusrat Fateh Ali Khan", "Laila - Junoon", "Sangam (Soundtrack) - Shankar Jaikishan", "Dil Se (Soundtrack) - A.R. Rahman", "Rockstar (Soundtrack) - A.R. Rahman", "Call Me Dil - Sajjad Ali", "The Moon Represents My Heart - Teresa Teng", "Nothing to My Name - Cui Jian", "Map of the Soul: 7 - BTS", "The Most Beautiful Moment in Life - BTS", "Canto-Pop Classics - Faye Wong", "Buena Vista Social Club - Buena Vista Social Club", "Clandestino - Manu Chao", "Siembra - Rubén Blades", "Bachata Rosa - Juan Luis Guerra", "Donde Estan los Ladrones - Shakira", "Amor Prohibido - Selena", "Artaal - Various", "Tinariwen - Amassakoul", "Zombie - Fela Kuti", "Juju Music - King Sunny Ade", "Talking Timbuktu - Ali Farka Toure", "Geeta Dutt Classics", "R.D. Burman Hits", "Greatest Hits - Jay Chou", "Blue Blood - X Japan", "Long Season - Fishmans", "Gal Costa - Gal Costa", "A Tábua de Esmeralda - Jorge Ben", "Racional - Tim Maia", "Cartola - Cartola", "Elis & Tom - Elis Regina", "Azadi - Junoon", "Crumbling - Mid-Air Thief", "Homogenic - Björk", "Agaetis Byrjun - Sigur Rós", "Kala - M.I.A.", "Arular - M.I.A."
        ],
        albums: [
            "Unknown Pleasures - Joy Division", "Rumours - Fleetwood Mac", "OK Computer - Radiohead", "In Rainbows - Radiohead", "Kid A - Radiohead", "The Bends - Radiohead", "Abbey Road - The Beatles", "Revolver - The Beatles", "Sgt. Pepper - The Beatles", "White Album - The Beatles", "Rubber Soul - The Beatles", "Dark Side of the Moon - Pink Floyd", "The Wall - Pink Floyd", "Wish You Were Here - Pink Floyd", "Animals - Pink Floyd", "Led Zeppelin IV - Led Zeppelin", "Physical Graffiti - Led Zeppelin", "Back in Black - AC/DC", "Highway to Hell - AC/DC", "Nevermind - Nirvana", "In Utero - Nirvana", "Ten - Pearl Jam", "Superunknown - Soundgarden", "Dirt - Alice in Chains", "Hybrid Theory - Linkin Park", "Meteora - Linkin Park", "Toxicity - System of a Down", "White Pony - Deftones", "Is This It - The Strokes", "Room on Fire - The Strokes", "Turn on the Bright Lights - Interpol", "Antics - Interpol", "Silent Alarm - Bloc Party", "Whatever People Say I Am - Arctic Monkeys", "Favourite Worst Nightmare - Arctic Monkeys", "AM - Arctic Monkeys", "The Queen Is Dead - The Smiths", "Meat Is Murder - The Smiths", "The Stone Roses - The Stone Roses", "Definitely Maybe - Oasis", "(What's the Story) Morning Glory? - Oasis", "Parklife - Blur", "Modern Life Is Rubbish - Blur", "Different Class - Pulp", "Urban Hymns - The Verve", "Dummy - Portishead", "Mezzanine - Massive Attack", "Blue Lines - Massive Attack", "Maxinquaye - Tricky", "Untrue - Burial", "Original Pirate Material - The Streets", "A Grand Don't Come for Free - The Streets", "Boy in da Corner - Dizzee Rascal", "Home - Fred again..", "Actual Life - Fred again..", "Brat - Charli XCX", "Crash - Charli XCX", "How I'm Feeling Now - Charli XCX", "Future Nostalgia - Dua Lipa", "Radical Optimism - Dua Lipa", "Renaissance - Beyoncé", "Lemonade - Beyoncé", "Cowboy Carter - Beyoncé", "Midnights - Taylor Swift", "Folklore - Taylor Swift", "Evermore - Taylor Swift", "1989 - Taylor Swift", "Red - Taylor Swift", "Fearless - Taylor Swift", "Speak Now - Taylor Swift", "Reputation - Taylor Swift", "Lover - Taylor Swift", "Norman Fucking Rockwell! - Lana Del Rey", "Born to Die - Lana Del Rey", "Ultraviolence - Lana Del Rey", "Melodrama - Lorde", "Pure Heroine - Lorde", "Solar Power - Lorde", "Ctrl - SZA", "SOS - SZA", "Blonde - Frank Ocean", "Channel Orange - Frank Ocean", "Igor - Tyler, the Creator", "Flower Boy - Tyler, the Creator", "Call Me If You Get Lost - Tyler, the Creator", "To Pimp a Butterfly - Kendrick Lamar", "Good Kid, M.A.A.D City - Kendrick Lamar", "DAMN. - Kendrick Lamar", "Mr. Morale & The Big Steppers - Kendrick Lamar", "My Beautiful Dark Twisted Fantasy - Kanye West", "Yeezus - Kanye West", "The College Dropout - Kanye West", "Late Registration - Kanye West", "Graduation - Kanye West", "808s & Heartbreak - Kanye West", "The Life of Pablo - Kanye West", "Discovery - Daft Punk", "Random Access Memories - Daft Punk", "Homework - Daft Punk", "Cross - Justice", "Woman - Justice", "Audio, Video, Disco - Justice", "Immunity - Jon Hopkins", "Singularity - Jon Hopkins", "Music for Psychedelic Therapy - Jon Hopkins", "Selected Ambient Works 85-92 - Aphex Twin", "Windowlicker - Aphex Twin", "Druqs - Aphex Twin", "Syro - Aphex Twin", "Music Has the Right to Children - Boards of Canada", "Geogaddi - Boards of Canada", "The Campfire Headphase - Boards of Canada", "Tomorrow's Harvest - Boards of Canada", "Untrue - Burial", "Kind of Blue - Miles Davis", "A Love Supreme - John Coltrane", "Time Out - Dave Brubeck", "Blue Train - John Coltrane", "Mingus Ah Um - Charles Mingus", "Head Hunters - Herbie Hancock", "Bitches Brew - Miles Davis", "In a Silent Way - Miles Davis", "Oil of Every Pearl's Un-Insides - SOPHIE", "Product - SOPHIE", "Tunes 2011-2019 - Burial", "Kindred - Burial", "Rival Dealer - Burial", "Street Halo - Burial", "Antidawn - Burial", "Experience - The Prodigy", "Music for the Jilted Generation - The Prodigy", "The Fat of the Land - The Prodigy", "Leftism - Leftfield", "Exit Planet Dust - The Chemical Brothers", "Dig Your Own Hole - The Chemical Brothers", "Surrender - The Chemical Brothers", "Better Living Through Chemistry - Fatboy Slim", "You've Come a Long Way, Baby - Fatboy Slim", "Homework - Daft Punk", "Discovery - Daft Punk", "Human After All - Daft Punk", "Remedy - Basement Jaxx", "Rooty - Basement Jaxx", "Kish Kash - Basement Jaxx", "Boy in da Corner - Dizzee Rascal", "Showtime - Dizzee Rascal", "Maths + English - Dizzee Rascal", "Original Pirate Material - The Streets", "A Grand Don't Come for Free - The Streets", "The Hardest Way to Make an Easy Living - The Streets", "Arular - M.I.A.", "Kala - M.I.A.", "Maya - M.I.A.", "Dummy - Portishead", "Portishead - Portishead", "Third - Portishead", "Blue Lines - Massive Attack", "Protection - Massive Attack", "Mezzanine - Massive Attack", "100th Window - Massive Attack", "Heligoland - Massive Attack", "Maxinquaye - Tricky", "Pre-Millennium Tension - Tricky", "Angels with Dirty Faces - Tricky", "Endtroducing..... - DJ Shadow", "The Private Press - DJ Shadow", "Since I Left You - The Avalanches", "Wildflower - The Avalanches", "We Will Always Love You - The Avalanches", "Donuts - J Dilla", "Madvillainy - Madvillain", "Mm.. Food - MF DOOM", "Operation: Doomsday - MF DOOM", "Take Me to Your Leader - King Geedorah", "Vaudeville Villain - Viktor Vaughn"
        ],
        fakeMovies: ["The Onion Knight Rises", "Grange Hill: The Movie", "Toast of London 2", "Coronation Street: 2049", "Attack of the 50ft Badger", "Carry On Coding", "James Bond: Tax Return", "Harry Potter and the Infinite Spreadsheet", "Doctor Who? No Seriously Who?", "EastEnders: The Musical", "Strictly Come Dancing: Battle Royale", "The Great British Bake Off: Hunger Games Edition", "Sherlock Holmes and the Case of the Missing Biscuit", "Paddington 3: Hard Time in Belmarsh", "Wallace and Gromit: The Were-Rabbit's Revenge", "Mr. Bean Goes to Mars", "The Inbetweeners 3: Funeral Crashers", "Peep Show: The Movie", "Black Mirror: A Happy Ending", "Fawlty Towers: Re-Open for Business"],
        fakeAlbums: ["Songs for Dustbins - The Wombles", "Heavy Metal Bagpipes - The Scotsman", "Techno Tea Party - The Queen", "Garage Grime Hymns - The Vicar", "Dubstep Morris Dancing - The Village Idiots", "Ambient Traffic Noises - The Commuter", "Screamo lullabies - The Nanny", "Jazz Flute for Beginners - Ron Burgundy", "Polka Punk - The Accordions", "Operatic Rap - The Tenors", "Country & Western & Eastern - The Globalist", "Reggae Christmas Carols - The Rastafarians", "Disco Dirges - The Goths", "Hip Hop Harpsichord - The Baroque Boyz", "Drum & Bass & Bassoon - The Orchestra", "Synthpop Sea Shanties - The Sailors", "Acoustic Acid House - The Busker", "Funk Folk Fusion - The Hipsters", "Soulful Screeching - The Banshee", "Blues for Blue Bottles - The Fly"]
    };

    // SVG HEADS
    const SVG_MALE = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="40" r="25" fill="#555"/><path d="M20 100 Q50 60 80 100" fill="#555"/></svg>`;
    const SVG_FEMALE = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M30 15 Q50 -5 70 15 L75 50 L85 90 L15 90 L25 50 Z" fill="#555"/><circle cx="50" cy="40" r="23" fill="#555"/><path d="M20 100 Q50 70 80 100" fill="#555"/></svg>`;

    function generateBio() {
        const isFemale = Math.random() > 0.5;
        const nameList = isFemale ? BIO_DATA.femaleNames : BIO_DATA.maleNames;
        const first = nameList[Math.floor(Math.random() * nameList.length)];
        const last = BIO_DATA.lastNames[Math.floor(Math.random() * BIO_DATA.lastNames.length)];
        
        const day = 1 + Math.floor(Math.random() * 28);
        const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
        const mon = months[Math.floor(Math.random() * 12)];
        const year = 1968 + Math.floor(Math.random() * 30); // Ages approx 27-56
        const dob = `${day} ${mon} ${year}`;
        
        // Generate Fake SSN / NINO
        const chars = "ABCEGHJKLMNOPRSTWXYZ";
        const l1 = chars[Math.floor(Math.random() * chars.length)];
        const l2 = chars[Math.floor(Math.random() * chars.length)];
        const n1 = Math.floor(Math.random() * 100).toString().padStart(2, '0');
        const n2 = Math.floor(Math.random() * 100).toString().padStart(2, '0');
        const n3 = Math.floor(Math.random() * 100).toString().padStart(2, '0');
        const l3 = "ABCD"[Math.floor(Math.random() * 4)];
        const ssn = `${l1}${l2}-${n1}-${n2}-${n3}-${l3}`;

        const bloods = ["A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-"];
        const blood = bloods[Math.floor(Math.random() * bloods.length)];

        // Movies & Music (5% Fake)
        const isFake = Math.random() < 0.05;
        const movie = isFake ? BIO_DATA.fakeMovies[Math.floor(Math.random()*BIO_DATA.fakeMovies.length)] : BIO_DATA.movies[Math.floor(Math.random() * BIO_DATA.movies.length)];
        
        // Album Selection: 30% chance for Global Music, 70% Western, unless Fake
        let album = "";
        if (isFake) {
            album = BIO_DATA.fakeAlbums[Math.floor(Math.random()*BIO_DATA.fakeAlbums.length)];
        } else {
            if (Math.random() < 0.30) {
                // 30% chance for Global / Non-Western
                album = BIO_DATA.globalAlbums[Math.floor(Math.random() * BIO_DATA.globalAlbums.length)];
            } else {
                // 70% chance for Standard List
                album = BIO_DATA.albums[Math.floor(Math.random() * BIO_DATA.albums.length)];
            }
        }

        // Nationality
        let nat = "BRITISH";
        const rNat = Math.random();
        if(rNat < 0.65) nat = "BRITISH";
        else if (rNat < 0.95) nat = BIO_DATA.nationalities[Math.floor(Math.random()*BIO_DATA.nationalities.length)];
        else nat = BIO_DATA.wildcardNations[Math.floor(Math.random()*BIO_DATA.wildcardNations.length)];

        return { 
            name: `${first} ${last}`, 
            dob: dob, 
            ssn: ssn, 
            blood: blood, 
            movie: movie, 
            album: album, 
            isFemale: isFemale,
            nationality: nat 
        };
    }
    
    function revealBio() {
        const details = document.getElementById('bio-masked-area');
        const btn = document.getElementById('bio-read-more');
        details.classList.add('open');
        btn.style.display = 'none';
    }

    // --- EXPANDED MUSIC LIBRARY ---
    const MUSIC_TRACKS = [
        'music1.mp3', 'music2.mp3', 'music3.mp3', 'music4.mp3', 
        'music5.mp3', 'music6.mp3', 'music7.mp3', 'music8.mp3'
    ];
    
    // --- DOCUMENTARY TRACKS ---
    const DOCU_TRACKS = ['docu1.mp3', 'docu2.mp3'];

    // DESTINATIONS
    const DESTINATIONS = [
        "OXFORD", "BRISTOL", "CARDIFF", "YORK", "DOVER", "BATH", "LEEDS", "RYE", 
        "SOUTHAMPTON", "BRIGHTON", "PORTSMOUTH", "EXETER", "BOURNEMOUTH",
        "SEVENOAKS", "LITTLE CROWLEY", "HASTINGS", "EASTBOURNE", "MARGATE", "RAMSGATE", "WORTHING"
    ];
    const NORTHERN = ["GLASGOW", "EDINBURGH", "ABERDEEN", "INVERNESS", "NEWCASTLE", "DURHAM", "MANCHESTER", "LIVERPOOL"];

    // COMB FACTS & REVIEWS (TVGoHome Style)
    // AMENDMENT: Changed single quotes to double quotes for facts
    const COMB_TRIVIA = [
        "FACT: The first comb was made of frozen butter.",
        "REVIEW: \"It combed my soup perfectly.\" - G. Ramsey",
        "FACT: Napoleon used a comb to signal retreat.",
        "REVIEW: \"Too pointy. 1 star.\" - Anon",
        "FACT: Combs were illegal in Devon until 1984.",
        "REVIEW: \"My hamster loves the grip.\" - P. Daniels",
        "FACT: A comb cannot float in mercury.",
        "REVIEW: \"Don't shop at COMBS, terrible service.\" - Jeff in Stoke",
        "FACT: In 1204, a comb was elected Mayor of Norwich.",
        "REVIEW: \"It smells of old trams.\" - B. Johnson",
        "FACT: The moon is shaped like a very old comb.",
        "REVIEW: \"Instructions unclear, combed my toaster.\"",
        "FACT: Queen Victoria owned 400 invisible combs.",
        "REVIEW: \"Does not work on bald eagles.\" - USA_Fan",
        "FACT: Comb technology peaked in the Bronze Age.",
        "REVIEW: \"Refund refused. Sad.\" - Karen1975",
        "FACT: \"Comb\" is short for \"Combustable\".",
        "REVIEW: \"Perfect for scratching my car.\" - D. Clarkson",
        "FACT: Every 3rd comb sold is haunted.",
        "REVIEW: \"It whispers to me at night.\" - SpookySteve",
        "FACT: Combs can be used as primitive radios.",
        "REVIEW: \"Only picks up Radio 4.\" - T. May",
        "FACT: A comb has never killed a swan.",
        "REVIEW: \"Too many teeth, not enough gum.\"",
        "FACT: The collective noun for combs is a \"Tangle\".",
        "REVIEW: \"Made of cheese? No. Disappointed.\"",
        "FACT: Julius Caesar invented the parting.",
        "REVIEW: \"Sticky. Why is it sticky?\"",
        "FACT: Combs are banned in space.",
        "REVIEW: \"Arrived broken. Fixed with tape. 3/10\"",
        "FACT: The world's largest comb is in Wigan.",
        "REVIEW: \"Not suitable for heavy gravel.\"",
        "FACT: Ancient Greeks combed their salads.",
        "REVIEW: \"Expensive for a piece of plastic.\"",
        "FACT: A comb a day keeps the barber away.",
        "REVIEW: \"My cat ate it.\"",
        "FACT: Combs were once currency in Wales.",
        "REVIEW: \"Too loud when dropped.\"",
        "FACT: The plastic comb was invented by accident.",
        "REVIEW: \"Does not comb thoughts. False advertising.\"",
        "FACT: Vikings used combs to navigate.",
        "REVIEW: \"Slippery when wet.\"",
        "FACT: A comb has 42 teeth on average.",
        "REVIEW: \"Lost it immediately.\"",
        "FACT: Combs are afraid of heights.",
        "REVIEW: \"Color did not match my aura.\"",
        "FACT: You can play a comb like a kazoo.",
        "REVIEW: \"Tastes like purple.\"",
        "FACT: The Titanic had a dedicated comb room.",
        "REVIEW: \"Too shiny.\"",
        "FACT: Combs were originally square.",
        "REVIEW: \"Not round enough.\"",
        "FACT: A broken comb signifies rain.",
        "REVIEW: \"It bit me.\"",
        "FACT: Combs dissolve in vinegar.",
        "REVIEW: \"Why is it vibrating?\"",
        "FACT: The Queen combs her corgis daily.",
        "REVIEW: \"Good for scraping toast.\"",
        "FACT: Combs are 90% air.",
        "REVIEW: \"Heavier than it looks.\"",
        "FACT: Never lend a comb to a ghost.",
        "REVIEW: \"It glows in the dark. Helpful.\"",
        "FACT: Combs can survive a nuclear blast.",
        "REVIEW: \"My dog hates it.\"",
        "FACT: The word \"Comb\" is 4 letters long.",
        "REVIEW: \"I ordered a brush. This is a comb.\"",
        "FACT: Combs amplify silence.",
        "REVIEW: \"Works on llamas.\"",
        "FACT: There is no such thing as a left-handed comb.",
        "REVIEW: \"I am left handed. It exploded.\"",
        "FACT: Combs are magnetic to socks.",
        "REVIEW: \"Found in my soup.\"",
        "FACT: A comb is a ladder for fleas.",
        "REVIEW: \"Too extravagant.\"",
        "FACT: Combs are allergic to jazz.",
        "REVIEW: \"It sings.\"",
        "FACT: A comb is just a skeleton of a brush.",
        "REVIEW: \"Too boney.\"",
        "FACT: Combs hate water.",
        "REVIEW: \"It sank.\"",
        "FACT: Every comb has a name.",
        "REVIEW: \"Mine is called Steve.\"",
        "FACT: Combs can feel love.",
        "REVIEW: \"It judged me.\"",
        "FACT: A comb is a mirror for hair.",
        "REVIEW: \"Too reflective.\"",
        "FACT: Combs are older than time.",
        "REVIEW: \"Dusty.\"",
        "FACT: A comb is a key to a lock of hair.",
        "REVIEW: \"Did not unlock my door.\"",
        "FACT: Combs are strictly non-edible.",
        "REVIEW: \"Crunchy.\"",
        "FACT: A comb is a saw for air.",
        "REVIEW: \"Too sharp.\""
    ];

    // WIN PHRASES
    const ADJECTIVES = ["Lethal", "Silent", "Phantom", "Shadow", "Iron", "Cold", "Patient", "Surgical", "Ghost", "Vengeful", "Invisible", "Swift", "Precise", "Deadly", "Golden", "Silver", "Ruthless", "Calm"];
    const NOUNS = ["Assassin", "Spirit", "Agent", "Hunter", "Spectre", "Wolf", "Eagle", "Viper", "Operator", "Sniper", "Watchman", "Sentinel", "Wraith", "Reaper", "Soldier", "Professional"];
    const WIN_TITLES = ["LEGENDARY", "STUNNING", "CLINICAL", "EXEMPLARY", "GODLIKE", "PERFECT", "FLAWLESS", "MASTERFUL", "ELITE"];

    const C = {
        sky: 0x88CCFF, floor: 0x999999, platform: 0x333333,
        clothes: [0x111111, 0x222222, 0x001133, 0x332211, 0xDDDDDD],
        spyColor: 0x777777, workerColor: 0xFFFF00,
        packageColor: 0xCCFF00, trainColors: [0xEEEEEE, 0x444444, 0x003366]
    };

    let scene, camera, renderer, raycaster;
    let clock = new THREE.Clock();
    
    // States: MENU, READY_CHECK, MINGLE, RUSH, BLEEDING, INPUT_SCORE, SCREEN_EFFECT, ENDED
    let gameState = 'MENU'; 
    let gameMode = 'STREAK'; 
    let gameTime = 0;
    let bleedTimer = 0;
    
    // Arrival Logic Variables
    let arrivalPhase = 'WAITING'; // WAITING, ARRIVING, BOARDING_OFF, COMPLETE
    let arrivalStartTime = 0;
    let arrivalTrainData = [];
    let arrivingTrains = [];
    let greenTargetAssigned = false;
    let greenTargetSpawned = false;
    let lateDepartureTriggered = false;
    let lateDepartureTime = 0;
    let chainReactionTriggered = false; // New flag for multiple train departures
    
    // Dynamic Package Color
    const PACKAGE_COLORS = {
        NEON_GREEN: 0x39FF14,
        WHITE: 0xFFFFFF,
        LIGHT_BLUE: 0xADD8E6
    };
    let currentPackageType = 'NEON_GREEN'; 
    let currentPackageColor = 0x39FF14;
    
    // Timed Mode Logic
    let timerRunning = false;
    let timerStartTime = 0;
    let finalTime = 0;
    
    // Objects
    let civilians = [];
    let bullets = [];
    let bloodPuddles = [];
    let pigeons = [];
    let confetti = [];
    let particles = []; 
    let looseItems = [];
    let statuePos = null; 
    let jamboni = null; // The cleaner vehicle
    let shopStaff = []; // The shopkeepers
    let slidingDoors = []; // Sliding doors array

    // Logic
    let targetObj = null; 
    let targetTown = "";
    let targetPlatform = -1; 
    let isInitializing = false; // Prevent double init
    let boardDataGenerated = false; // Prevent board redraw loop
    
    let boardCanvas, boardCtx, boardTexture;
    let nextPigeonTime = 5;
    let stripeTexture;
    let marbleTexture; // Light grey marble texture
    let bloodSpawned = false;
    let obstacles = []; // Global obstacles for collision

    // New Arrays for Train Sequence
    let trains = [];
    let newsTickerOffset = 0;
    let newsTickerActive = false;
    let trainsDeparted = false; // State flag
    let tickerContent = ""; // Dynamic content
    let firstTrainMoveTime = -1;
    let newsDelay = 0;

    // Settings & Persistence
    let SETTING_CROWD = 80;
    let SETTING_PACKAGES = 4;
    let KILL_STREAK = 0;
    let LEADERBOARD = []; 
    
    let SETTING_MUSIC_ON = true;
    let SETTING_SFX_ON = true;
    // UPDATED DEFAULTS handled in loadSettings
    let SETTING_MUSIC_VOL = 0.3;
    let SETTING_SFX_VOL = 0.8;
    let SETTING_MENU_VOL = 0.5;
    let SETTING_RANDOM_PL = false;
    let SETTING_RADIO_MODE = 'FM'; // 'FM' or 'AM'

    let STATS = { target:0, decoy:0, civ:0, abort:0 };

    // Audio Globals
    let currentMusicIdx = 0;
    let currentDocuIdx = 0;
    let activeMusicAudio = null;
    let fadeInterval = null;
    let menuMusicStarted = false;
    let isAudioPersisting = false; // Flag for AM persistence
    
    let sfxStartTimeout = null;
    let musicStartTimeout = null;

    let resultIsWin = false;
    let resultReason = "";
    let victimRef = null;
    let victimSurvivalStatus = "DECEASED";

    let isZoomed = false;
    let pitch = -0.4, yaw = 0;
    const keyState = {};

    function loadSettings() {
        if(localStorage.getItem('sm_crowd')) SETTING_CROWD = parseInt(localStorage.getItem('sm_crowd'));
        if(localStorage.getItem('sm_pkg')) SETTING_PACKAGES = parseInt(localStorage.getItem('sm_pkg'));
        if(localStorage.getItem('sm_streak')) KILL_STREAK = parseInt(localStorage.getItem('sm_streak'));
        if(localStorage.getItem('sm_leaderboard')) {
            try { 
                let raw = JSON.parse(localStorage.getItem('sm_leaderboard'));
                if(raw.length > 0 && typeof raw[0] === 'number') {
                    LEADERBOARD = raw.map(t => ({name: 'AGT', time: t}));
                } else {
                    LEADERBOARD = raw;
                }
            } catch(e){ LEADERBOARD=[]; }
        }
        if(localStorage.getItem('sm_stats')) {
            try { STATS = JSON.parse(localStorage.getItem('sm_stats')); } catch(e){ STATS={target:0, decoy:0, civ:0, abort:0}; }
        }
        
        if(localStorage.getItem('sm_music_on') !== null) SETTING_MUSIC_ON = (localStorage.getItem('sm_music_on') === 'true');
        if(localStorage.getItem('sm_sfx_on') !== null) SETTING_SFX_ON = (localStorage.getItem('sm_sfx_on') === 'true');
        if(localStorage.getItem('sm_random_pl') !== null) SETTING_RANDOM_PL = (localStorage.getItem('sm_random_pl') === 'true');
        
        // NEW DEFAULT VOLUME LOGIC (80% SFX, 30% Music if not set)
        if(localStorage.getItem('sm_music_vol')) {
            SETTING_MUSIC_VOL = parseFloat(localStorage.getItem('sm_music_vol'));
        } else {
            SETTING_MUSIC_VOL = 0.3;
        }

        if(localStorage.getItem('sm_sfx_vol')) {
            SETTING_SFX_VOL = parseFloat(localStorage.getItem('sm_sfx_vol'));
        } else {
            SETTING_SFX_VOL = 0.8;
        }

        if(localStorage.getItem('sm_menu_vol')) SETTING_MENU_VOL = parseFloat(localStorage.getItem('sm_menu_vol'));
        
        if(localStorage.getItem('sm_radio_mode')) SETTING_RADIO_MODE = localStorage.getItem('sm_radio_mode');

        document.getElementById('slide-crowd').value = SETTING_CROWD;
        document.getElementById('slide-pkg').value = SETTING_PACKAGES;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        document.getElementById('streak-display').innerText = KILL_STREAK;
        document.getElementById('chk-music').checked = SETTING_MUSIC_ON;
        document.getElementById('chk-sfx').checked = SETTING_SFX_ON;
        document.getElementById('chk-random-pl').checked = SETTING_RANDOM_PL;
        document.getElementById('vol-music-slider').value = SETTING_MUSIC_VOL;
        document.getElementById('vol-sfx-slider').value = SETTING_SFX_VOL;
        document.getElementById('slide-menu-vol').value = SETTING_MENU_VOL;

        updateRadioVisuals();
        updateMenuVisuals();
        renderLeaderboard();
        renderStats();
    }

    function renderLeaderboard() {
        const lbDiv = document.getElementById('lb-content');
        lbDiv.innerHTML = '';
        const sorted = LEADERBOARD.sort((a,b) => a.time - b.time).slice(0, 5);
        for(let i=0; i<5; i++) {
            const entry = sorted[i];
            const timeStr = entry ? entry.time.toFixed(3) + "s" : "---";
            const nameStr = entry ? entry.name : "---";
            const row = document.createElement('div');
            row.className = 'lb-row';
            row.innerHTML = `<span class="lb-rank">${i+1}.</span> <span class="lb-name">${nameStr}</span> <span class="lb-time">${timeStr}</span>`;
            lbDiv.appendChild(row);
        }
    }

    function renderStats() {
        document.getElementById('stat-target').innerText = STATS.target;
        document.getElementById('stat-decoy').innerText = STATS.decoy;
        document.getElementById('stat-civ').innerText = STATS.civ;
        document.getElementById('stat-abort').innerText = STATS.abort;
    }

    function updateMenuVisuals() {
        const container = document.getElementById('chalk-outlines');
        container.innerHTML = '';
        const count = Math.min(KILL_STREAK, 20); 
        for(let i=0; i<count; i++) {
            const el = document.createElement('div');
            el.className = 'chalk-body';
            el.style.left = (Math.random() * 90) + '%';
            el.style.top = (Math.random() * 80) + '%';
            el.style.transform = `rotate(${Math.random()*360}deg) scale(${0.5 + Math.random()*0.5})`;
            container.appendChild(el);
        }
    }

    function saveSettings() {
        localStorage.setItem('sm_crowd', SETTING_CROWD);
        localStorage.setItem('sm_pkg', SETTING_PACKAGES);
        localStorage.setItem('sm_streak', KILL_STREAK);
        localStorage.setItem('sm_leaderboard', JSON.stringify(LEADERBOARD));
        localStorage.setItem('sm_stats', JSON.stringify(STATS));
        localStorage.setItem('sm_music_on', SETTING_MUSIC_ON);
        localStorage.setItem('sm_sfx_on', SETTING_SFX_ON);
        localStorage.setItem('sm_random_pl', SETTING_RANDOM_PL);
        localStorage.setItem('sm_music_vol', SETTING_MUSIC_VOL);
        localStorage.setItem('sm_sfx_vol', SETTING_SFX_VOL);
        localStorage.setItem('sm_menu_vol', SETTING_MENU_VOL);
        localStorage.setItem('sm_radio_mode', SETTING_RADIO_MODE);
    }

    // UPDATED RESET LOGIC
    let pendingResetType = null;
    function triggerReset(type) {
        pendingResetType = type;
        const title = document.querySelector('.confirm-title');
        const msg = document.querySelector('.confirm-msg');
        document.getElementById('confirm-modal').style.display = 'flex';

        if(type === 'STATS') {
            title.innerText = "PURGE FIELD REPORT";
            msg.innerHTML = "Are you sure you want to wipe all cumulative stats (Targets, Decoys, etc)?<br><br><span style='color:#f55;'>THIS ACTION CANNOT BE UNDONE.</span>";
        } else {
            title.innerText = "PURGE LEADERBOARD";
            msg.innerHTML = "Are you sure you want to wipe the Speed Run Leaderboard?<br><br><span style='color:#f55;'>THIS ACTION CANNOT BE UNDONE.</span>";
        }
    }
    
    function closeConfirm() {
        document.getElementById('confirm-modal').style.display = 'none';
        pendingResetType = null;
    }
    
    function performReset() {
        if(pendingResetType === 'STATS') {
             STATS = { target:0, decoy:0, civ:0, abort:0 };
             saveSettings();
             renderStats();
        } else if (pendingResetType === 'LEADERBOARD') {
             LEADERBOARD = [];
             saveSettings();
             renderLeaderboard();
        }
        closeConfirm();
    }

    function setDifficulty(level) {
        if(level === 'EASY') { SETTING_CROWD = 134; SETTING_PACKAGES = 2; }
        else if(level === 'MEDIUM') { SETTING_CROWD = 227; SETTING_PACKAGES = 17; }
        else if(level === 'HARD') { SETTING_CROWD = 420; SETTING_PACKAGES = 70; }
        document.getElementById('slide-crowd').value = SETTING_CROWD;
        document.getElementById('slide-pkg').value = SETTING_PACKAGES;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        saveSettings();
    }

    function updateUI() {
        SETTING_CROWD = document.getElementById('slide-crowd').value;
        SETTING_PACKAGES = document.getElementById('slide-pkg').value;
        SETTING_MUSIC_ON = document.getElementById('chk-music').checked;
        SETTING_SFX_ON = document.getElementById('chk-sfx').checked;
        SETTING_RANDOM_PL = document.getElementById('chk-random-pl').checked;
        document.getElementById('val-crowd').innerText = SETTING_CROWD;
        document.getElementById('val-pkg').innerText = SETTING_PACKAGES;
        document.getElementById('vol-music-container').style.display = SETTING_MUSIC_ON ? 'flex' : 'none';
        document.getElementById('vol-sfx-container').style.display = SETTING_SFX_ON ? 'flex' : 'none';
        saveSettings(); 
    }

    function updateMenuVol() {
        SETTING_MENU_VOL = parseFloat(document.getElementById('slide-menu-vol').value);
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) menuBgm.volume = SETTING_MENU_VOL;
        saveSettings();
    }

    function generateCodeName() {
        const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
        const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
        return `"${adj} ${noun}"`;
    }

    function toggleTopUI() {
        const ui = document.getElementById('top-ui-container');
        const icon = document.getElementById('toggle-icon');
        const text = document.getElementById('toggle-text');
        ui.classList.toggle('minimized');
        const isMin = ui.classList.contains('minimized');
        icon.innerText = isMin ? '^' : 'v';
        text.innerText = isMin ? 'OPEN MENU' : 'HIDE MENU';
    }

    // --- AUDIO SYSTEM ---

    function startMenuMusicTimer() {
        const seenIntro = sessionStorage.getItem('sm_intro_seen');
        if(seenIntro) {
            document.getElementById('intro-splash').style.display = 'none';
            // NEW: Instead of auto-playing (which browsers block on reload), show return overlay
            document.getElementById('return-overlay').style.display = 'flex';
        }
    }

    // NEW: Handle return click to start music
    function confirmReturn() {
        document.getElementById('return-overlay').style.display = 'none';
        
        if(gameState === 'MENU' && !menuMusicStarted) {
            const menuBgm = document.getElementById('menu-bgm');
            menuBgm.currentTime = Math.random() * 60; 
            menuBgm.volume = 0;
            menuBgm.play().then(() => {
                menuMusicStarted = true;
                fadeInAudio(menuBgm, SETTING_MENU_VOL, 3000);
            }).catch(e=>console.log("Menu music fail",e));
        }
    }

    function enterGame() {
        sessionStorage.setItem('sm_intro_seen', 'true');
        const splash = document.getElementById('intro-splash');
        splash.style.opacity = '0';
        setTimeout(() => splash.style.display = 'none', 2000);
        const menuBgm = document.getElementById('menu-bgm');
        menuBgm.currentTime = 0;
        menuBgm.volume = 0;
        menuBgm.play().then(() => {
            menuMusicStarted = true;
            fadeInAudio(menuBgm, SETTING_MENU_VOL, 3000);
        });
    }

    function initiateGame(mode, btn) {
        if(isInitializing) return; // Prevent double trigger
        isInitializing = true;

        if(btn) {
            btn.classList.add('clicked');
            btn.innerHTML = '<div class="spinner"></div>';
        }
        
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) {
            fadeOutAudio(menuBgm, 2800, () => {
                menuBgm.pause();
                menuMusicStarted = false;
            });
        }
        
        // Wait for fade then show Ready Screen
        setTimeout(() => {
            prepareGameEnv(mode);
        }, 3000);
    }
    
    // NEW: Replay with same settings
    function replaySameSettings() {
         // UI Button feedback
         const btn = document.getElementById('replay-btn'); // Use ID for safety
         if(btn) {
             btn.classList.add('clicked');
             btn.innerHTML = '<div class="spinner"></div>';
         }

         // PERSISTENCE CHECK
         // If we are in AM mode (Docs), we do NOT fade out music. We let it ride.
         if (SETTING_RADIO_MODE === 'AM' && activeMusicAudio && !activeMusicAudio.paused) {
             isAudioPersisting = true;
             // Do not fade out activeMusicAudio
         } else {
             // FM Music logic (standard fade out)
             isAudioPersisting = false;
             if(activeMusicAudio && !activeMusicAudio.paused) fadeOutAudio(activeMusicAudio, 2100, null);
         }

         // Transition delay increased to 2.3s as requested
         setTimeout(() => {
             document.getElementById('end-dossier').style.display = 'none';
             // Re-enter setup
             prepareGameEnv(gameMode);
         }, 2300);
    }

    function reloadWithFade() {
        if(activeMusicAudio && !activeMusicAudio.paused) fadeOutAudio(activeMusicAudio, 1700, null);
        const menuBgm = document.getElementById('menu-bgm');
        if(menuBgm && !menuBgm.paused) fadeOutAudio(menuBgm, 1700, null);
        setTimeout(() => location.reload(), 1700);
    }
    
    function toggleRadioMode() {
        SETTING_RADIO_MODE = SETTING_RADIO_MODE === 'FM' ? 'AM' : 'FM';
        updateRadioVisuals();
        saveSettings();
        
        // If music is currently playing, switch track immediately
        if(activeMusicAudio && !activeMusicAudio.paused) {
            // Stop current with short fade
            const oldAudio = activeMusicAudio;
            fadeOutAudio(oldAudio, 500, () => {
                oldAudio.pause();
                playMusic(); // Start new mode track
            });
        }
    }
    
    function updateRadioVisuals() {
        const sw = document.getElementById('bar-radio-switch');
        const lFm = document.getElementById('label-fm');
        const lAm = document.getElementById('label-am');
        
        if(SETTING_RADIO_MODE === 'FM') {
            sw.classList.remove('am'); sw.classList.add('fm');
            if(lFm) { lFm.style.color = '#00FF00'; lFm.style.textShadow = '0 0 5px #00FF00'; }
            if(lAm) { lAm.style.color = '#444'; lAm.style.textShadow = 'none'; }
        } else {
            sw.classList.remove('fm'); sw.classList.add('am');
            if(lFm) { lFm.style.color = '#444'; lFm.style.textShadow = 'none'; }
            if(lAm) { lAm.style.color = '#FFCC00'; lAm.style.textShadow = '0 0 5px #FFCC00'; }
        }
    }

    function playMusic() {
        if(!SETTING_MUSIC_ON) return;
        
        // Ensure no overlapping audio (unless persistence handled it, but this function is called when starting fresh usually)
        if(activeMusicAudio && !activeMusicAudio.paused) {
            activeMusicAudio.pause();
            activeMusicAudio.src = ""; 
            activeMusicAudio = null;
        }

        let trackName = "";
        
        if (SETTING_RADIO_MODE === 'FM') {
            // FM MUSIC LOGIC
            let idx = 0;
            if(SETTING_RANDOM_PL) idx = Math.floor(Math.random() * MUSIC_TRACKS.length);
            else idx = currentMusicIdx % MUSIC_TRACKS.length;
            currentMusicIdx = idx;
            trackName = MUSIC_TRACKS[idx];
        } else {
            // AM DOCS LOGIC
            let idx = currentDocuIdx % DOCU_TRACKS.length;
            trackName = DOCU_TRACKS[idx];
        }

        activeMusicAudio = new Audio(trackName);
        activeMusicAudio.loop = true;
        
        // Random start time logic (0% to 85% of duration)
        activeMusicAudio.addEventListener('loadedmetadata', () => {
             const dur = activeMusicAudio.duration || 100;
             // Random point up to 85% to ensure not starting at very end
             const maxStart = dur * 0.85; 
             activeMusicAudio.currentTime = Math.random() * maxStart; 
        });
        
        activeMusicAudio.volume = 0; 
        activeMusicAudio.play().then(() => {
            // 4 second fade in
            fadeInAudio(activeMusicAudio, SETTING_MUSIC_VOL, 4000);
        }).catch(e => console.log("Music failed to play", e));
    }

    function nextTrack() {
        if(!activeMusicAudio) return;
        
        if (SETTING_RADIO_MODE === 'FM') {
            currentMusicIdx++;
        } else {
            currentDocuIdx++;
        }
        
        // Instant switch with fade out of old is handled by playMusic stopping previous
        // But let's do a quick crossfade effect manually
        const oldAudio = activeMusicAudio;
        fadeOutAudio(oldAudio, 500, () => {
            oldAudio.pause();
            playMusic();
        });
    }

    function fadeInAudio(audioEl, targetVol, duration) {
        if(fadeInterval) clearInterval(fadeInterval);
        const stepTime = 100;
        const stepVol = targetVol / (duration / stepTime);
        const fInt = setInterval(() => {
            if(!audioEl || audioEl.paused) { clearInterval(fInt); return; }
            let newVol = audioEl.volume + stepVol;
            if(newVol >= targetVol) { newVol = targetVol; clearInterval(fInt); }
            audioEl.volume = newVol;
        }, stepTime);
    }

    function fadeOutAudio(audioEl, duration, callback) {
        const stepTime = 50;
        const startVol = audioEl.volume;
        const stepVol = startVol / (duration / stepTime);
        const fInt = setInterval(() => {
            if(!audioEl) { clearInterval(fInt); return; }
            let newVol = audioEl.volume - stepVol;
            if(newVol <= 0) {
                newVol = 0; audioEl.volume = 0; clearInterval(fInt);
                if(callback) callback();
            } else { audioEl.volume = newVol; }
        }, stepTime);
    }

    // --- MATRIX EFFECT ---
    const matCanvas = document.getElementById('matrix-canvas');
    const matCtx = matCanvas.getContext('2d');
    const matrixWords = ["SNIPER", "YELLOW", "PACKAGE", "COURIER", "FLOWERS", "PLATFORM", "HASTINGS", "DISAVOW", "TERMINUS", "WATCHMAN", "TARGET", "DECOY", "BYSTANDER", "MISSION", "INTEL", "BOARD", "TRAIN", "DEPARTURE", "STATION", "PROTOCOL", "SILENCER", "SCOPE", "ZOOM", "VELOCITY", "AGENT", "SUSPECT", "IDENTIFY", "ELIMINATE", "CLEARED", "FAILED", "ABORT", "TIME", "SPEED", "RECORD", "NORTHERN", "SOUTHERN", "RAIL", "TICKET", "GATE", "LUGGAGE", "BRIEFCASE"];
    let matColumns = [];
    const matFontSize = 12;

    function initMatrix() {
        matCanvas.width = window.innerWidth;
        matCanvas.height = window.innerHeight;
        const colCount = Math.floor(matCanvas.width / matFontSize);
        matColumns = [];
        for(let x=0; x<colCount; x++) {
            matColumns.push({ y: Math.random() * matCanvas.height, word: matrixWords[Math.floor(Math.random() * matrixWords.length)], wordIdx: 0, speed: 1 + Math.random() * 2 });
        }
    }

    function drawMatrix() {
        if(gameState !== 'MENU' && gameState !== 'ENDED') return;
        
        // Slower background if ENDED screen
        const bgSpeedMult = (gameState === 'ENDED') ? 0.85 : 1.0;

        matCtx.fillStyle = 'rgba(0, 0, 0, 0.08)'; matCtx.fillRect(0, 0, matCanvas.width, matCanvas.height);
        matCtx.font = matFontSize + 'px monospace';
        for(let i=0; i<matColumns.length; i++) {
            const col = matColumns[i];
            const shade = Math.floor(50 + Math.random() * 200);
            matCtx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
            const char = col.word[col.wordIdx % col.word.length];
            matCtx.fillText(char, i * matFontSize, col.y);
            col.y += (col.speed * bgSpeedMult); // Apply speed mult
            if(Math.floor(col.y) % 20 < 2) col.wordIdx++;
            if(col.y > matCanvas.height && Math.random() > 0.98) {
                col.y = 0; col.wordIdx = 0; col.word = matrixWords[Math.floor(Math.random() * matrixWords.length)];
            }
        }
    }

    // --- THREE JS INIT ---
    function init() {
        loadSettings();
        startMenuMusicTimer();
        initMatrix();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x111111, 0.002);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
        camera.position.set(0, 50, 130);
        camera.rotation.order = "YXZ";

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();

        const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
        const sun = new THREE.SpotLight(0xffddaa, 1.5);
        sun.position.set(50, 150, 50); sun.angle = 0.8; sun.penumbra = 0.5; sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        stripeTexture = createStripeTexture();
        marbleTexture = createMarbleTexture();
        buildStation();

        document.getElementById('hs-input').addEventListener('keydown', function(e) {
            if(e.key === 'Enter') submitScore();
        });

        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));
        window.addEventListener('resize', onResize);

        const sliderMusic = document.getElementById('vol-music-slider');
        sliderMusic.addEventListener('input', function() { 
            SETTING_MUSIC_VOL = parseFloat(this.value); 
            if(activeMusicAudio) activeMusicAudio.volume = SETTING_MUSIC_VOL;
            saveSettings(); 
        });

        const sliderSFX = document.getElementById('vol-sfx-slider');
        const sfx = document.getElementById('sfx-ambience');
        sliderSFX.addEventListener('input', function() { 
            SETTING_SFX_VOL = parseFloat(this.value);
            sfx.volume = SETTING_SFX_VOL;
            saveSettings(); 
        });

        animate();
    }

    function handleKey(e, isDown) {
        // Prevent default browser actions for game keys to avoid scrolling/interactions
        if(isDown && (e.code === 'Space' || e.code === 'KeyF' || e.code === 'Enter')) {
            // e.preventDefault(); // Optional, but good for Space (scrolling)
        }

        const key = e.key.toLowerCase();
        keyState[key] = isDown; 
        keyState[e.code] = isDown;
        
        if(isDown && (gameState === 'MINGLE' || gameState === 'RUSH')) {
            if(e.code === 'Space') toggleZoom();
            // FIX: Check for 'f' OR 'F' via toLowerCase, or use e.code 'KeyF'
            if(key === 'f' || e.code === 'KeyF' || e.code === 'Enter') fire();
        }
    }

    function createStripeTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFD700'; ctx.fillRect(0,0,64,64);
        ctx.fillStyle = '#000000';
        for(let i=0; i<64; i+=8) ctx.fillRect(0, i, 64, 4);
        return new THREE.CanvasTexture(canvas);
    }
    
    function createCrossHatchTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Base: Grey/Metallic
        ctx.fillStyle = '#99AAAA'; 
        ctx.fillRect(0,0,256,256);
        
        ctx.strokeStyle = '#667788';
        ctx.lineWidth = 4;
        
        // Diagonals 1
        for(let i=-256; i<512; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i+256, 256);
            ctx.stroke();
        }
        
        // Diagonals 2
        for(let i=-256; i<512; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i, 256);
            ctx.lineTo(i+256, 0);
            ctx.stroke();
        }
        
        // Subtle variations
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        for(let i=0; i<10; i++) {
            ctx.fillRect(Math.random()*200, Math.random()*200, 50, 50);
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    function createMarbleTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        // Base light grey - LIGHTER NOW
        ctx.fillStyle = '#F0F0F0'; 
        ctx.fillRect(0,0,256,256);
        // Veins
        ctx.strokeStyle = '#CCCCCC'; 
        ctx.lineWidth = 2;
        for(let i=0; i<20; i++) {
            ctx.beginPath(); 
            ctx.moveTo(Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256, Math.random()*256);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(canvas);
    }

    function createGratedTexture() {
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#445566'; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = '#000000';
        for(let i=0; i<512; i+=32) ctx.fillRect(i, 0, 8, 512); 
        for(let i=0; i<512; i+=32) ctx.fillRect(0, i, 512, 8); 
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 4); 
        return tex;
    }

    function createBlock(w, h, d, col, x, y, z, parent, tex) {
        const mat = tex ? new THREE.MeshLambertMaterial({map: tex, transparent:true}) : new THREE.MeshLambertMaterial({color: col});
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
        mesh.position.set(x,y,z); mesh.castShadow = true; mesh.receiveShadow = true;
        if(parent) parent.add(mesh); else scene.add(mesh);
        return mesh;
    }
    
    function createShrub(x, z) {
        const grp = new THREE.Group();
        grp.position.set(x, 0, z);
        
        // Pot
        const potGeo = new THREE.CylinderGeometry(2.5, 2, 3, 16);
        const pot = new THREE.Mesh(potGeo, new THREE.MeshLambertMaterial({color: 0x8B4513})); // Brown
        pot.position.y = 1.5;
        grp.add(pot);
        
        // Plant
        const isTree = Math.random() > 0.5;
        if (isTree) {
            // Small Tree
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 6, 8), new THREE.MeshLambertMaterial({color: 0x553311}));
            trunk.position.y = 4.5;
            grp.add(trunk);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(3.5), new THREE.MeshLambertMaterial({color: 0x228B22}));
            leaves.position.y = 8;
            grp.add(leaves);
        } else {
            // Bush
            const bush = new THREE.Mesh(new THREE.DodecahedronGeometry(3), new THREE.MeshLambertMaterial({color: 0x006400}));
            bush.position.y = 3.5;
            grp.add(bush);
        }
        
        // Add obstacle so people walk around it
        obstacles.push({x: x, z: z, r: 3.5});
        scene.add(grp);
    }
    
    function createSignpost() {
        const grp = new THREE.Group();
        // Slightly off centre by random 4% (5-15 units)
        const xOff = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 10);
        // Between centre (Z=0) and sniper (Z=130), around Z=60
        grp.position.set(xOff, 0, 60);

        // Pole: White column, ~6.5 high
        createBlock(0.6, 6.5, 0.6, 0xEEEEEE, 0, 3.25, 0, grp);
        // Base: Metal
        createBlock(1.2, 0.5, 1.2, 0x555555, 0, 0.25, 0, grp);
        
        // Signs: 4 way
        const yTop = 6.0;
        // Sign 1 (Z+)
        createBlock(3.0, 0.8, 0.2, 0xFFFFFF, 0, yTop, 0.5, grp);
        // Sign 2 (Z-)
        createBlock(3.0, 0.8, 0.2, 0xFFFFFF, 0, yTop, -0.5, grp);
        // Sign 3 (X+)
        createBlock(0.2, 0.8, 3.0, 0xFFFFFF, 0.5, yTop, 0, grp);
        // Sign 4 (X-)
        createBlock(0.2, 0.8, 3.0, 0xFFFFFF, -0.5, yTop, 0, grp);
        
        obstacles.push({x: xOff, z: 60, r: 2.0});
        scene.add(grp);
    }
    
    // --- SLIDING DOORS ---
    function createSlidingDoors(x, z, rotY) {
        const grp = new THREE.Group();
        grp.position.set(x, 0, z);
        grp.rotation.y = rotY;
        
        const frameColor = 0x2C3E50; // Dark Blue Grey
        const glassColor = 0xADD8E6; // Light Blue
        
        // SCALED DOWN DIMENSIONS (~55% smaller than original 24x14)
        const w = 11; 
        const h = 6.5; 
        
        // THE BLACK VOID (Backing)
        createBlock(w - 1, h, 0.5, 0x000000, 0, h/2, -0.8, grp);

        // Top Frame
        createBlock(w + 0.5, 0.8, 0.8, frameColor, 0, h - 0.4, 0, grp);
        // Side Frames
        createBlock(0.8, h, 0.8, frameColor, -w/2 + 0.4, h/2, 0, grp);
        createBlock(0.8, h, 0.8, frameColor, w/2 - 0.4, h/2, 0, grp);
        
        // Door Panels
        const dW = (w / 2) - 0.2;
        
        // Left Door
        const lDoor = new THREE.Group();
        lDoor.position.set(-dW/2 + 0.2, h/2, 0); 
        createBlock(dW, h - 1, 0.4, frameColor, 0, 0, 0, lDoor);
        const gL = new THREE.Mesh(new THREE.PlaneGeometry(dW - 0.4, h - 1.4), new THREE.MeshLambertMaterial({color: glassColor, transparent: true, opacity: 0.3}));
        gL.position.z = 0.25; 
        lDoor.add(gL);
        const gL2 = gL.clone(); gL2.rotation.y = Math.PI; gL2.position.z = -0.25; lDoor.add(gL2);
        grp.add(lDoor);
        
        // Right Door
        const rDoor = new THREE.Group();
        rDoor.position.set(dW/2 - 0.2, h/2, 0);
        createBlock(dW, h - 1, 0.4, frameColor, 0, 0, 0, rDoor);
        const gR = new THREE.Mesh(new THREE.PlaneGeometry(dW - 0.4, h - 1.4), new THREE.MeshLambertMaterial({color: glassColor, transparent: true, opacity: 0.3}));
        gR.position.z = 0.25;
        rDoor.add(gR);
        const gR2 = gR.clone(); gR2.rotation.y = Math.PI; gR2.position.z = -0.25; rDoor.add(gR2);
        grp.add(rDoor);
        
        slidingDoors.push({
            grp: grp, lDoor: lDoor, rDoor: rDoor,
            baseLx: -dW/2 + 0.2, baseRx: dW/2 - 0.2,
            openLx: -dW/2 + 0.2 - (dW * 0.85), openRx: dW/2 - 0.2 + (dW * 0.85),
            slideVal: 0 
        });
        
        scene.add(grp);
    }
    
    function updateDoors(dt) {
        slidingDoors.forEach(d => {
            // Check proximity to civilians or camera
            let shouldOpen = false;
            
            // Check Camera distance
            if(camera.position.distanceTo(d.grp.position) < 30) shouldOpen = true;
            
            // Check Civilians
            if(!shouldOpen) {
                for(let c of civilians) {
                    if(c.mesh.position.distanceTo(d.grp.position) < 12) {
                        shouldOpen = true;
                        break;
                    }
                }
            }
            
            // Lerp slideVal
            const target = shouldOpen ? 1.0 : 0.0;
            const speed = shouldOpen ? 4.0 : 2.0; // Open fast, close slow
            d.slideVal += (target - d.slideVal) * speed * dt;
            
            // Apply positions
            d.lDoor.position.x = d.baseLx + (d.openLx - d.baseLx) * d.slideVal;
            d.rDoor.position.x = d.baseRx + (d.openRx - d.baseRx) * d.slideVal;
        });
    }

    function createEnvironment() {
        const grassGeo = new THREE.PlaneGeometry(800, 800);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x1a2e12 }); 
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2; grass.position.set(0, -3.0, -200); grass.receiveShadow = true; scene.add(grass);
        for(let i = 0; i < 60; i++) {
            const treeGroup = new THREE.Group();
            const tx = (Math.random() - 0.5) * 600; const tz = -180 - (Math.random() * 300); 
            const trunkH = 5 + Math.random() * 5;
            createBlock(1.5, trunkH, 1.5, 0x3d2817, 0, trunkH/2, 0, treeGroup);
            const leavesH = 10 + Math.random() * 10;
            const leafGeo = new THREE.ConeGeometry(4 + Math.random()*3, leavesH, 8);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x0f2e0f }); 
            const leaves = new THREE.Mesh(leafGeo, leafMat);
            leaves.position.set(0, trunkH + (leavesH/2) - 1, 0); leaves.castShadow = true; treeGroup.add(leaves);
            treeGroup.position.set(tx, -2.5, tz); scene.add(treeGroup);
        }
    }

    function buildStation() {
        createEnvironment();
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d'); ctx.fillStyle = '#999'; ctx.fillRect(0,0,512,512);
        for(let i=0;i<8000;i++){ctx.fillStyle=Math.random()>0.5?'#777':'#BBB';ctx.fillRect(Math.random()*512,Math.random()*512,2,2);}
        const floorTex = new THREE.CanvasTexture(canvas); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(12,8);
        
        createBlock(450, 1, 150, null, 0, -0.5, 50, null, floorTex);
        createBlock(450, 1, 300, 0x111111, 0, -2.0, -175);
        
        // DECORATIVE WALLS (Half Circles at Ends)
        const wallTex = createCrossHatchTexture(); // UPDATED TEXTURE
        const wallMat = new THREE.MeshLambertMaterial({map: wallTex, side: THREE.DoubleSide});
        const wallGeo = new THREE.CircleGeometry(75, 32, 0, Math.PI); // Top half
        
        // Left End (-225)
        const wallL = new THREE.Mesh(wallGeo, wallMat);
        wallL.position.set(-225, 0, 50); // Center of floor depth roughly
        wallL.rotation.y = Math.PI / 2;
        scene.add(wallL);
        
        // Right End (225)
        const wallR = new THREE.Mesh(wallGeo, wallMat);
        wallR.position.set(225, 0, 50);
        wallR.rotation.y = -Math.PI / 2;
        scene.add(wallR);
        
        // SLIDING DOORS (Embedded in the Walls)
        createSlidingDoors(-225, 50, Math.PI/2);
        createSlidingDoors(225, 50, -Math.PI/2);
        
        // SHRUBS (4 Corners)
        createShrub(-210, -10);
        createShrub(210, -10);
        createShrub(-210, 110);
        createShrub(210, 110);

        for(let i=0; i<6; i++) {
            const x = -100 + (i * 40);
            // PLATFORM
            createBlock(20, 2, 250, C.platform, x, -1.0, -150);
            // RAILS
            createBlock(1, 0.2, 250, 0x555555, x - 14, -1.9, -150); 
            createBlock(1, 0.2, 250, 0x555555, x - 18, -1.9, -150);
            
            // LADDER TRACKS (Sleepers)
            const sleeperGroup = new THREE.Group();
            for(let j=0; j<100; j++) { // Many sleepers
                createBlock(6, 0.1, 0.5, 0x221100, x - 16, -2.0, -25 - (j * 2.5), sleeperGroup);
            }
            scene.add(sleeperGroup);
            
            // TRAINS ARE NOW SPAWNED DYNAMICALLY IN spawnTrains() TO FIX RESET BUG
            
            const sCanvas = document.createElement('canvas'); sCanvas.width=128; sCanvas.height=128;
            const sCtx = sCanvas.getContext('2d'); sCtx.fillStyle='#222'; sCtx.fillRect(0,0,128,128);
            sCtx.strokeStyle='#FFD700'; sCtx.lineWidth=6; sCtx.strokeRect(5,5,118,118);
            sCtx.fillStyle='#FFF'; sCtx.font='bold 80px "Courier Prime"'; sCtx.textAlign='center'; sCtx.textBaseline='middle'; sCtx.fillText(i+1,64,68);
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(sCanvas)}));
            sign.position.set(x, 8, -24.8); scene.add(sign); 
            createBlock(0.5, 8, 0.5, 0x111111, x, 4, -25.5);
            for(let zP = -100; zP > -250; zP -= 60) createBlock(4, 60, 4, 0x333333, x, 30, zP);
        }

        createGenericShop(160, 40, "WHSmiffs", 0x707070); 
        createGenericShop(160, 10, "SHOES", 0x808080);
        createGenericShop(100, 80, "VAPES", 0x606060);
        createGenericShop(-160, 40, "NAILS", 0x757575);
        createGenericShop(-160, 10, "EAT", 0x666666); 
        createGenericShop(-100, 80, "Nice:Clothes", 0x555555);
        createGenericShop(160, -20, "COMBS", 0x777777);
        
        // --- NEW FENCES LOGIC: PERPENDICULAR BETWEEN PLATFORMS ---
        const gaps = [
            {s: -200, e: -110}, // Left of Plat 1
            {s: -90, e: -70},   // Between 1 & 2
            {s: -50, e: -30},   // Between 2 & 3
            {s: -10, e: 10},    // Between 3 & 4
            {s: 30, e: 50},     // Between 4 & 5
            {s: 70, e: 90},     // Between 5 & 6
            {s: 110, e: 200}    // Right of Plat 6
        ];
        
        gaps.forEach(g => {
            createPerpendicularFence(-25, g.s, g.e);
        });

        createBlock(400, 5, 10, 0x222222, 0, 40, -180); 
        createBlock(400, 1, 1, 0xff0000, 0, 43, -175); 

        const roofGeo = new THREE.CylinderGeometry(180, 180, 600, 32, 1, true, 0, Math.PI);
        const roofTex = createGratedTexture();
        const roofMat = new THREE.MeshBasicMaterial({ map: roofTex, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const roof = new THREE.Mesh(roofGeo, roofMat); roof.rotation.z = Math.PI / 2; roof.position.set(0, 90, -50); scene.add(roof);
        
        createSignpost();

        const boardGroup = new THREE.Group(); boardGroup.position.set(0, 25, -25);
        createBlock(140, 20, 2, 0x111111, 0, 0, 0, boardGroup);
        boardCanvas = document.createElement('canvas'); boardCanvas.width = 1024; boardCanvas.height = 256;
        boardCtx = boardCanvas.getContext('2d'); drawBoard(["SYSTEM BOOT..."]);
        boardTexture = new THREE.CanvasTexture(boardCanvas);
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(130, 16), new THREE.MeshBasicMaterial({map: boardTexture}));
        screen.position.set(0, 0, 1.1); boardGroup.add(screen); scene.add(boardGroup);
    }
    
    // --- CREATE PERPENDICULAR FENCE HELPER ---
    // Fence runs along X axis at a specific Z
    function createPerpendicularFence(z, xStart, xEnd) {
        const group = new THREE.Group();
        const length = Math.abs(xEnd - xStart);
        const centerX = (xStart + xEnd) / 2;
        const segmentLen = 10;
        const count = Math.floor(length / segmentLen);
        
        // Height 2.0 (Twice previous 1.0)
        // Top Rail (Y=1.8)
        createBlock(length, 0.2, 0.5, 0xAAAAAA, centerX, 1.8, z, group);
        // Mid Rail (Y=1.0)
        createBlock(length, 0.2, 0.5, 0xAAAAAA, centerX, 1.0, z, group);
        
        // Posts
        for(let i=0; i<=count; i++) {
            const x = xStart + (i * segmentLen);
            // Don't place post if it exceeds xEnd slightly due to rounding
            if(x > xEnd + 0.1) continue;
            createBlock(0.5, 2.0, 0.5, 0x888888, x, 1.0, z, group);
        }
        
        scene.add(group);
    }

    function createTrain(x, y, zStart, parent, color, options) {
        const col = color || C.trainColors[Math.floor(Math.random() * C.trainColors.length)];
        const isStripe = options && options.isStripe;
        const isSiren = options && options.isSiren;
        
        // Special Siren Train Mesh to store reference
        let sirenMesh = null;

        for(let i=0; i<5; i++) {
            const z = zStart - (i * 24);
            const car = new THREE.Group(); car.position.set(x, y + 2.5, z);
            
            // Main Body
            createBlock(3.8, 4.5, 22, col, 0, 0, 0, car);
            
            // Purple Stripe Logic
            if(isStripe) {
                // Horizontal stripe, dark purple, below center
                // Body is 4.5 high. Center y=0 relative to car. Below center approx y=-0.5
                // Full length 22. slightly wider than 3.8 to show
                createBlock(3.9, 0.4, 22, 0x4B0082, 0, -0.5, 0, car);
            }

            // Siren Logic (Only on first car i==0, front)
            if(isSiren && i === 0) {
                // Front roof. Car y=0 is center. Top is y=2.25.
                // Front is z=+11.
                // Siren mesh
                const siren = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.6, 0.8),
                    new THREE.MeshLambertMaterial({ color: 0xFF0000, emissive: 0x000000 })
                );
                siren.position.set(0, 2.6, 8); // Top, near front
                car.add(siren);
                sirenMesh = siren; // Keep ref logic
            }
            
            createBlock(3.9, 1.5, 20, 0x222222, 0, 0.5, 0, car); 
            createBlock(0.2, 3, 2, 0x000000, 2, -0.5, 5, car); 
            parent.add(car);
        }
        return sirenMesh;
    }

    // Helper to get skin color
    function getRandomSkinColor() {
        // SKIN COLOR LOGIC
        let skinCol = 0xFFCCAA; // Default
        const whiteChance = 0.58 + (Math.random() * (0.81 - 0.58)); // 58% to 81% chance
        if(Math.random() < whiteChance) {
            skinCol = Math.random() > 0.5 ? 0xFFCCAA : 0xF5D0B0;
        } else {
            // Brown, Light Brown, Light Black, Dark Black
            const skins = [0xD2A679, 0xB07E55, 0x8D5524, 0x5C3836, 0x3B2319];
            skinCol = skins[Math.floor(Math.random() * skins.length)];
        }
        return skinCol;
    }

    function createGenericShop(x, z, text, greyCol) {
        const s = new THREE.Group(); s.position.set(x, 0, z);
        let shopStaffMember = null;

        if (text === "VAPES") {
            // Walk-in Marquee Style
            
            // 4 Corner Columns
            const colW = 1.5; const colH = 15;
            createBlock(colW, colH, colW, greyCol, -11.5, 7.5, -11.5, s); // Back Left
            createBlock(colW, colH, colW, greyCol, 11.5, 7.5, -11.5, s);  // Back Right
            createBlock(colW, colH, colW, greyCol, -11.5, 7.5, 11.5, s);  // Front Left
            createBlock(colW, colH, colW, greyCol, 11.5, 7.5, 11.5, s);   // Front Right
            
            // Roof
            createBlock(26, 6, 26, greyCol, 0, 13, 0, s);
            
            // --- UPDATED VAPE SHOP COUNTER ---
            const dW = 9.8; 
            const dH = 1.82; 
            const dThick = 1;
            const yPos = dH / 2;
            const brightWhite = 0xFFFFFF; // Use white to let texture shine brightest
            
            // Front bar
            createBlock(dW, dH, dThick, brightWhite, 0, yPos, 2.5, s, marbleTexture);
            // Back bar
            createBlock(dW, dH, dThick, brightWhite, 0, yPos, -2.5, s, marbleTexture);
            // Left bar
            createBlock(dThick, dH, 4, brightWhite, -4.4, yPos, 0, s, marbleTexture); // Offset X to half of 9.8 approx (4.9 minus padding)
            // Right bar
            createBlock(dThick, dH, 4, brightWhite, 4.4, yPos, 0, s, marbleTexture);
            
            // ADD OBSTACLE FOR COLLISION
            obstacles.push({x: x, z: z, r: 8.0}); // Radius 8 for slightly safer boundary

            // Shopkeeper INSIDE the counter (Center)
            // UPDATED: Full body person logic
            const staffGrp = new THREE.Group();
            staffGrp.position.set(0, 0, 0); 
            // SPECIAL NAME FOR SHOOTABLE CHECK
            staffGrp.name = "PERSON_ROOT";
            
            // Random Pink/Purple Shirt
            const shirtCols = [0xFFC0CB, 0xFF69B4, 0x800080, 0x9370DB, 0xDA70D6];
            const shirtCol = shirtCols[Math.floor(Math.random() * shirtCols.length)];
            const skinCol = getRandomSkinColor();

            // Legs (Relative to group center 0,0,0)
            // Group will be raised to stand on floor.
            // Legs: x=+/-0.2, y=0.8, z=0
            createBlock(0.25, 1.6, 0.25, 0x111111, -0.2, 0.8, 0, staffGrp); // Left Leg
            createBlock(0.25, 1.6, 0.25, 0x111111, 0.2, 0.8, 0, staffGrp); // Right Leg
            
            // Body (Shirt)
            createBlock(0.9, 1.4, 0.5, shirtCol, 0, 2.2, 0, staffGrp); 
            
            // Arms
            createBlock(0.25, 1.3, 0.25, shirtCol, -0.6, 2.2, 0, staffGrp); // Left Arm
            createBlock(0.25, 1.3, 0.25, shirtCol, 0.6, 2.2, 0, staffGrp); // Right Arm

            // Head
            createBlock(0.5, 0.6, 0.5, skinCol, 0, 3.2, 0, staffGrp); 
            
            // Add to scene (Group sits at y=0 local, so legs touch y=0)
            s.add(staffGrp);
            
            shopStaffMember = {
                mesh: staffGrp,
                basePos: staffGrp.position.clone(),
                timer: 0,
                targetRot: Math.random() * Math.PI * 2,
                interval: 35 + Math.random() * 40, // 35-75 seconds random
                swayTimer: 0,
                isVapeWorker: true,
                isRotating: false,
                rotDuration: 0,
                rotTarget: 0,
                rotTimer: 0
            };
            
        } else {
            // Standard Block Shop 
            createBlock(25, 15, 25, greyCol, 0, 7.5, 0, s); 
        }

        if(shopStaffMember) shopStaff.push(shopStaffMember);

        // SIGN GENERATION
        let bgCol = '#444';
        if(text === "EAT") bgCol = '#006600'; if(text === "WHSmiffs") bgCol = '#003399'; 
        
        const canvas=document.createElement('canvas');canvas.width=256;canvas.height=64;const ctx=canvas.getContext('2d');
        ctx.fillStyle=bgCol;ctx.fillRect(0,0,256,64);ctx.fillStyle='#FFF';ctx.font='bold 30px Arial';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(text,128,32);
        const signTex = new THREE.CanvasTexture(canvas);

        if (text === "VAPES" || text === "Nice:Clothes") {
            // SIGN ON ALL 4 SIDES
            const offsets = [
                { pos: new THREE.Vector3(0, 12, 13.1), rot: 0 },          // Front (Z+)
                { pos: new THREE.Vector3(0, 12, -13.1), rot: Math.PI },   // Back (Z-)
                { pos: new THREE.Vector3(-13.1, 12, 0), rot: -Math.PI/2 },// Left (X-)
                { pos: new THREE.Vector3(13.1, 12, 0), rot: Math.PI/2 }   // Right (X+)
            ];
            
            offsets.forEach(off => {
                const sign = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
                sign.position.copy(off.pos);
                sign.rotation.y = off.rot;
                // For "Nice:Clothes" extra height adjustment if needed, but 12 is fine standard
                s.add(sign);
            });

        } else {
            // Standard Sign Placement (Side Facing)
            const sign = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
            sign.position.set(x>0?-13.1:13.1, 12, 0); 
            sign.rotation.y = x>0?-Math.PI/2:Math.PI/2; 
            s.add(sign); 
            
            // WHSmiffs EXTRA SIGN
            if(text === "WHSmiffs") {
                const sign2 = new THREE.Mesh(new THREE.PlaneGeometry(18, 4), new THREE.MeshBasicMaterial({map: signTex}));
                // Face Positive Z (Towards Sniper)
                // Shop is at 160, 40. Dimensions 25x25. Half dim 12.5.
                // Front Face is Z = +12.5 (local).
                sign2.position.set(0, 12, 12.6); 
                sign2.rotation.y = 0; // Face Z+
                s.add(sign2);
            }
        }
        
        if(text === "Nice:Clothes") {
            const hGroup = new THREE.Group(); hGroup.position.set(0, 15, 0);
            createBlock(10, 1, 1, 0xEEEEEE, 0, 2, 0, hGroup); 
            const l1 = createBlock(6, 1, 1, 0xEEEEEE, -2, 4, 0, hGroup); l1.rotation.z = -0.5;
            const l2 = createBlock(6, 1, 1, 0xEEEEEE, 2, 4, 0, hGroup); l2.rotation.z = 0.5;
            createBlock(1, 2, 1, 0xEEEEEE, 0, 6, 0, hGroup); s.add(hGroup);
        }
        scene.add(s);
    }

    function updateShopStaff(dt) {
        shopStaff.forEach(staff => {
            staff.timer += dt;

            if(staff.isVapeWorker) {
                // SPECIAL LOGIC FOR VAPE WORKER (INDEPENDENT ROTATION)
                // Twist every 25-35s to a NEW angle
                if(staff.isRotating) {
                    staff.rotTimer += dt;
                    // Simple LERP rotation
                    const t = Math.min(1.0, staff.rotTimer / staff.rotDuration);
                    
                    // Interpolate shortest path
                    // Actually simpler here since we just want to look different
                    // Just set rotation to target * t + start * (1-t)
                    // But to avoid complex quaternion math for now, linear Y interp is okay if we normalize range
                    // Or simply: 
                    const diff = staff.rotTarget - staff.mesh.rotation.y;
                    staff.mesh.rotation.y += diff * dt * 2.0; // Smooth approach

                    if(Math.abs(diff) < 0.05) {
                        staff.isRotating = false;
                        staff.timer = 0; // Reset main interval
                    }
                } else {
                    // Check interval
                    if(staff.timer > 25 + Math.random() * 10) { // 25-35s
                        staff.isRotating = true;
                        staff.rotTimer = 0;
                        staff.rotDuration = 1.0 + Math.random(); // 1-2s turn
                        staff.rotTarget = Math.random() * Math.PI * 2; // New random direction
                    }
                }
            } else {
                // STANDARD LOGIC FOR OTHERS
                if (staff.timer > staff.interval) {
                    staff.targetRot = Math.random() * Math.PI * 2;
                    staff.timer = 0;
                    staff.interval = 15 + Math.random() * 10; 
                }
                const diff = staff.targetRot - staff.mesh.rotation.y;
                staff.mesh.rotation.y += diff * dt * 0.5; 
            }
            
            // Sway Logic
            if(staff.basePos) {
                 staff.swayTimer += dt;
                 staff.mesh.position.x = staff.basePos.x + Math.sin(staff.swayTimer * 0.5) * 0.3;
            }
        });
    }

    function drawBoard(lines, isScrolling) {
        boardCtx.fillStyle = '#000000'; boardCtx.fillRect(0,0,1024,256);
        boardCtx.font = 'bold 40px Courier New'; boardCtx.fillStyle = '#FF9900'; boardCtx.textAlign = 'left';
        
        if(isScrolling) {
            // SCROLLING NEWS TICKER
            boardCtx.fillText("NEWS UPDATE:", 20, 50); 
            boardCtx.fillRect(20, 60, 984, 4);
            boardCtx.font = 'bold 60px Courier New';
            
            // Construct ticker content if empty
            if (!tickerContent) {
                const headlines = [
                    "Tottenham Hotspur win the Premier League in style with a 7-2 victory over Chelsea",
                    "Tottenham celebrate first league win for 66 years",
                    "Spurs finally lift the trophy in dramatic final day scenes",
                    "Miracle in North London as Tottenham clinch the title"
                ];
                const rndHead = headlines[Math.floor(Math.random() * headlines.length)];
                
                const football = `BREAKING NEWS: ${rndHead} *** 50% off your first COMB with discount: I LOVE COMBS *** England Awarded "Greyest" Country Award *** `;
                // Add random comb facts - AMENDED to use 4 loops instead of 5
                let extras = "";
                for(let k=0; k<4; k++) {
                    // Add random chance for Nice:Clothes advert
                    if(Math.random() < 0.25) {
                        extras += "Nice:Clothes *All*Ages*4*All*Wages* *** ";
                    }
                    extras += COMB_TRIVIA[Math.floor(Math.random() * COMB_TRIVIA.length)] + " *** COMBS! *** ";
                }
                tickerContent = football + extras;
            }
            
            // Draw text at offset
            boardCtx.fillText(tickerContent, 1024 - newsTickerOffset, 150);
            
            newsTickerOffset += 2.0; // Speed
            if(newsTickerOffset > (tickerContent.length * 40) + 1024) newsTickerOffset = 0; 
            
        } else {
            // STANDARD DEPARTURES
            boardCtx.fillText("DEPARTURES", 20, 50); boardCtx.fillRect(20, 60, 984, 4);
            for(let i=0; i<lines.length; i++) boardCtx.fillText(lines[i], 20, 110 + (i*50));
        }
        
        if(boardTexture) boardTexture.needsUpdate = true;
    }

    function createPerson(role, x, z) {
        const mesh = new THREE.Group(); mesh.position.set(x, 0, z);
        mesh.name = "PERSON_ROOT"; // Tag for raycaster

        const isWorker = role === 'WORKER' || role === 'GUARD' || role === 'ROMANCE_WORKER';
        let shirtCol = 0x333333; let shirtTex = null;
        if(isWorker) shirtCol = C.workerColor;
        else if(role === 'STRIPED') { shirtCol = 0xffffff; shirtTex = stripeTexture; }
        else shirtCol = C.clothes[Math.floor(Math.random()*C.clothes.length)]; 

        createBlock(0.25, 1.6, 0.25, 0x111111, -0.2, 0.8, 0, mesh); createBlock(0.25, 1.6, 0.25, 0x111111, 0.2, 0.8, 0, mesh);
        createBlock(0.9, 1.4, 0.5, shirtCol, 0, 2.2, 0, mesh, shirtTex); 
        createBlock(0.25, 1.3, 0.25, shirtCol, -0.6, 2.2, 0, mesh, shirtTex); createBlock(0.25, 1.3, 0.25, shirtCol, 0.6, 2.2, 0, mesh, shirtTex);
        
        createBlock(0.5, 0.6, 0.5, getRandomSkinColor(), 0, 3.2, 0, mesh); 
        
        // LUGGAGE LOGIC (Applied to approx 30% of all people, unless they are specific roles that might look weird, but let's keep it broad)
        if(Math.random() < 0.30 && !isWorker) {
            const lug = new THREE.Group(); lug.name = "LUGGAGE"; 
            createBlock(0.6, 1.0, 0.4, 0x330000, 0, 0.5, 0, lug); createBlock(0.1, 1.2, 0.1, 0x111111, 0, 0.6, -0.3, lug);
            // Position slightly to the side
            lug.position.set(0.8, 0, 0.5); 
            mesh.add(lug);
        }

        scene.add(mesh); return mesh;
    }
    
    // --- JAMBONI (CLEANER) ---
    function createJamboni() {
        if(jamboni) scene.remove(jamboni.mesh);
        
        const group = new THREE.Group();
        // Initial pos: somewhere in the near-side shops area
        group.position.set((Math.random()-0.5)*100, 0, 40);
        
        // SCALING: 17% smaller => 0.83 scale factor
        const s = 0.83;

        // Main Body (Darker Orange)
        createBlock(6*s, 3*s, 8*s, 0xAA4400, 0, 1.5*s, 0, group);
        
        // SIDE STRIPE (Diagonal)
        // A thin plane on the right side
        const stripe = createBlock(0.2*s, 0.4*s, 7*s, 0xAAAAAA, 3.1*s, 2.0*s, 0, group);
        stripe.rotation.x = 0.15; // Angled down front-to-back
        // Left side stripe
        const stripe2 = createBlock(0.2*s, 0.4*s, 7*s, 0xAAAAAA, -3.1*s, 2.0*s, 0, group);
        stripe2.rotation.x = 0.15;

        // Seat/Engine bump
        createBlock(5*s, 2*s, 3*s, 0x883300, 0, 3.5*s, 2*s, group);
        
        // Wheels
        createBlock(7*s, 1.5*s, 1.5*s, 0x111111, 0, 0.75*s, -2.5*s, group); // Back Axle
        createBlock(7*s, 1.5*s, 1.5*s, 0x111111, 0, 0.75*s, 2.5*s, group); // Front Axle
        
        // Driver
        const driver = new THREE.Group();
        driver.position.set(0, 3*s, 1.5*s);
        // Orange Overalls
        createBlock(0.8*s, 1.2*s, 0.5*s, 0xFF6600, 0, 1.0*s, 0, driver);
        // Grey Stripe
        createBlock(0.2*s, 1.2*s, 0.51*s, 0x888888, 0, 1.0*s, 0, driver);
        // Head (Random Skin)
        createBlock(0.5*s, 0.6*s, 0.5*s, getRandomSkinColor(), 0, 2.0*s, 0, driver);
        // Arms
        createBlock(0.2*s, 0.8*s, 0.2*s, 0xFF6600, -0.6*s, 1.0*s, 0.5*s, driver).rotation.x = -1;
        createBlock(0.2*s, 0.8*s, 0.2*s, 0xFF6600, 0.6*s, 1.0*s, 0.5*s, driver).rotation.x = -1;
        
        group.add(driver);
        scene.add(group);
        
        // Return object with state logic
        return {
            mesh: group,
            angle: Math.random() * Math.PI * 2,
            speed: 0.05,
            turnSpeed: 0,
            timer: 0
        };
    }
    
    function updateJamboni(dt) {
        if(!jamboni) return;
        
        jamboni.timer -= dt;
        
        // State change logic
        if(jamboni.timer <= 0) {
            const r = Math.random();
            if(r < 0.5) {
                // Drive straight
                jamboni.turnSpeed = 0;
                jamboni.timer = 2 + Math.random() * 4;
            } else if (r < 0.8) {
                // Zig Zag / Turn
                jamboni.turnSpeed = (Math.random() - 0.5) * 1.5;
                jamboni.timer = 1 + Math.random() * 2;
            } else {
                // U-Turn attempt
                jamboni.turnSpeed = 2.5; // Sharp turn
                jamboni.timer = 1.5;
            }

            // Path correction bias
            const pos = jamboni.mesh.position;
            if (pos.x > -80 && pos.x < 80) {
                if (Math.random() > 0.33) {
                    jamboni.turnSpeed = (pos.x > 0) ? 0.5 : -0.5;
                }
            }
        }
        
        // Apply rotation
        jamboni.angle += jamboni.turnSpeed * dt;
        jamboni.mesh.rotation.y = jamboni.angle + Math.PI; // Face forward
        
        // Move forward
        const dir = new THREE.Vector3(Math.sin(jamboni.angle), 0, Math.cos(jamboni.angle));
        const newPos = jamboni.mesh.position.clone().add(dir.multiplyScalar(jamboni.speed * 60 * dt));
        
        // Collision check for Jamboni
        let hit = false;
        // Wall boundaries
        if(newPos.x < -180 || newPos.x > 180 || newPos.z < -20 || newPos.z > 90) hit = true;
        // Obstacle collision
        for(let ob of obstacles) {
            if(newPos.distanceTo(new THREE.Vector3(ob.x, 0, ob.z)) < ob.r + 3) hit = true;
        }

        if(hit) {
             jamboni.angle += Math.PI + (Math.random()-0.5);
             jamboni.timer = 2.0;
             jamboni.turnSpeed = 0;
        } else {
            jamboni.mesh.position.copy(newPos);
        }
    }

    function spawnPigeon() {
        const p = new THREE.Group();
        createBlock(0.2, 0.2, 0.4, 0x888888, 0, 0, 0, p); 
        const w1 = createBlock(0.3, 0.05, 0.2, 0xAAAAAA, 0.25, 0, 0, p); const w2 = createBlock(0.3, 0.05, 0.2, 0xAAAAAA, -0.25, 0, 0, p);
        const startX = Math.random() > 0.5 ? -200 : 200;
        p.position.set(startX, 20 + Math.random()*10, 20 + Math.random()*20);
        scene.add(p);
        
        // CHAOTIC LOGIC TRIGGER
        // If gameTime > 75, we have a 50% chance of a chaotic pigeon, OR random high chance around that time
        let isChaotic = false;
        if(gameTime > 75) {
            if(Math.random() < 0.6) isChaotic = true;
        }

        pigeons.push({ 
            mesh: p, 
            wings: [w1, w2], 
            // Chaotic ones move slower on X to stay on screen longer for twisting
            vel: new THREE.Vector3(startX > 0 ? (isChaotic ? -15 : -25) : (isChaotic ? 15 : 25), 0, (Math.random()-0.5)*5),
            isChaotic: isChaotic,
            nextFeather: 0,
            baseY: p.position.y,
            seed: Math.random() * 100 // Random seed for unique chaos path
        });
    }
    
    // NEW TRAIN SPAWNER FUNCTION to reset trains correctly
    function spawnTrains() {
        // Clear old trains
        trains.forEach(t => scene.remove(t.mesh));
        trains = [];

        // Reset Ticker Logic
        firstTrainMoveTime = -1;
        newsDelay = 4.5 + Math.random() * 9.5; // Random delay between 4.5s and 14s

        // choose a slow train index (one per spawn)
        const slowIdx = Math.floor(Math.random() * 6);

        for (let i = 0; i < 6; i++) {
            const x = -100 + (i * 40);
            const trainGroup = new THREE.Group();
            // Create default train
            createTrain(x - 16, -1.0, -60, trainGroup, C.trainColors[Math.floor(Math.random() * C.trainColors.length)]);
            scene.add(trainGroup);

            // Initialize random departure time (was 63-87s). Add +4.5s to delay first departures slightly.
            // New range: 67.5 - 91.5
            const depTime = 67.5 + Math.random() * 24;

            trains.push({
                mesh: trainGroup,
                departTime: depTime,
                speed: 0,
                hasDeparted: false,
                // mark one train as the particularly slow-departing train
                isSlow: (i === slowIdx)
            });
        }
    }

    
    function createFeather(pos) {
        const f = createBlock(0.1, 0.01, 0.1, 0xFFFFFF, pos.x, pos.y, pos.z, null);
        // Special particles for feathers: Slowly falling, drifting
        particles.push({ 
            mesh: f, 
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, -1.5, (Math.random()-0.5)*0.5), // Falling down
            life: 2.5, // 2.5 seconds life
            maxLife: 2.5,
            isFeather: true
        });
    }
    
    // --- ARRIVAL LOGIC HELPERS ---
    
    function initArrivalSequence() {
        // Updated Window: 80s + random (was 110s) - bringing forward by 5s base, but start sooner overall
        arrivalStartTime = 80 + Math.random() * 20; 
        arrivalPhase = 'WAITING';
        arrivalTrainData = [];
        arrivingTrains = [];
        greenTargetAssigned = false;
        greenTargetSpawned = false;
        lateDepartureTriggered = false;
        chainReactionTriggered = false; // Reset chain reaction
        
        // Pick Random Package Color for Act 2
        const types = ['NEON_GREEN', 'WHITE', 'LIGHT_BLUE'];
        currentPackageType = types[Math.floor(Math.random() * types.length)];
        currentPackageColor = PACKAGE_COLORS[currentPackageType];
        
        // Generate train types for 6 platforms
        // One is Sand/Siren, One is Purple Stripe, Rest random standard
        let trainTypes = [
            { type: 'SIREN', color: 0xE6D089 }, 
            { type: 'STRIPE', color: 0xAAAAAA }, 
            { type: 'STD', color: null }, { type: 'STD', color: null }, { type: 'STD', color: null }, { type: 'STD', color: null }
        ];
        
        // Shuffle types
        for(let i=trainTypes.length-1; i>0; i--) {
            const j = Math.floor(Math.random() * (i+1));
            [trainTypes[i], trainTypes[j]] = [trainTypes[j], trainTypes[i]];
        }
        
        // Assign delays (0 to 37 seconds)
        for(let i=0; i<6; i++) {
            arrivalTrainData.push({
                platformIdx: i,
                delay: Math.random() * 37,
                type: trainTypes[i].type,
                color: trainTypes[i].color,
                spawned: false,
                passengerCount: Math.floor(1 + Math.random() * 89),
                passengerTimer: 0,
                passengerTotalTime: 15.0, // Spawn over 15s
                passengersSpawned: 0,
                targetZ: -60 + (Math.random() * 25) // Store random stop point per train (-60 to -35)
            });
        }
    }
    
    function spawnArrivingPassenger(train, isGreenTarget) {
        // Spawn passenger at train door location (roughly center Z of train car, X offset)
        // Train X is -100 + (train.platformIdx * 40) - 13.5 (Updated offset logic)
        // Platform X is -100 + (train.platformIdx * 40)
        
        const platX = -100 + (train.platformIdx * 40);
        const trainX = platX - 13.5; 
        
        // Z random along train length (-60 is front)
        const z = -60 - (Math.random() * 80); 
        
        // Role
        let role = 'CIV';
        if(isGreenTarget) role = 'GREEN_TARGET';
        
        const mesh = createPerson(role, trainX, z);
        
        // Add Package if Target
        if(role === 'GREEN_TARGET') {
            const pkg = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.15), new THREE.MeshBasicMaterial({color: currentPackageColor})); 
            pkg.position.set(0.6, 1.5, 0.3); 
            mesh.add(pkg);
        }
        
        // Also 10% Luggage chance for arrivals (if not target)
        else if(Math.random() < 0.10) {
            const lug = new THREE.Group(); lug.name = "LUGGAGE"; 
            createBlock(0.6, 1.0, 0.4, 0x330000, 0, 0.5, 0, lug); createBlock(0.1, 1.2, 0.1, 0x111111, 0, 0.6, -0.3, lug);
            lug.position.set(0.8, 0, 0.5); 
            mesh.add(lug);
        }
        
        // WAYPOINTS
        const waypoints = [];
        
        // 1. Walk diagonally onto platform (Randomized Width)
        // Platform X is platX. Add random +/- 8 units width usage.
        const walkX = platX + (Math.random() - 0.5) * 16;
        
        waypoints.push(new THREE.Vector3(walkX, 0, z + 5)); // Step out

        // 2. Walk forward towards Concourse Edge using the randomized lane
        waypoints.push(new THREE.Vector3(walkX, 0, -30));
        
        // 3. Concourse Entry (Randomized "Rough Area" instead of single point)
        // Concourse entry around Z = -10 to 0
        // Spread X across width (-100 to 100) to avoid single file
        const entryX = (Math.random() - 0.5) * 200; 
        waypoints.push(new THREE.Vector3(entryX, 0, -5));
        
        // 4. Center Concourse (Randomized)
        // Z = 20 to 50
        const centerX = (Math.random() - 0.5) * 180;
        const centerZ = 20 + Math.random() * 30;
        waypoints.push(new THREE.Vector3(centerX, 0, centerZ));
        
        // 5. Exits are now the Sliding Doors at +/- 225 X
        // Randomly pick left or right exit
        const exitX = Math.random() > 0.5 ? 230 : -230;
        waypoints.push(new THREE.Vector3(exitX, 0, 50));
        
        // 6. Final fade point deeper into the "void"
        waypoints.push(new THREE.Vector3(exitX > 0 ? 250 : -250, 0, 50));

        const civ = {
            mesh: mesh,
            role: role,
            state: 'EXITING', // Special state for update logic
            waypoints: waypoints,
            speed: 0.02 + Math.random() * 0.035, // More varied speeds (was 0.015 variance)
            sway: Math.random() * 100,
            opacity: 1.0,
            hasTriggeredAlert: false // For delayed phone alert
        };
        
        civilians.push(civ);
    }

    // --- LOGIC ---
    
    // NEW: First prepare the world but wait in "READY_CHECK" state
    function prepareGameEnv(mode) {
        gameMode = mode;
        timerRunning = false;
        timerStartTime = 0;
        isInitializing = false; // Reset lock
        
        // RESET CAMERA & VIEW FOR REPLAY
        let camY = 50; 
        if(Math.random() < 0.17) { camY += (Math.random() > 0.5 ? 5 : -5); }
        camera.position.set(0, camY, 130); 
        camera.lookAt(0,0,0); 
        pitch = -0.4; 
        yaw = 0;
        
        // Ensure zoom is OFF
        toggleZoom(true); 

        // Setup UI for pause state
        document.getElementById('menu').style.display = 'none';
        document.getElementById('ready-overlay').style.display = 'flex'; // SHOW OVERLAY
        document.getElementById('fixed-timer-container').style.display = (gameMode === 'TIMED') ? 'block' : 'none';
        document.getElementById('timer-ui').innerText = "00.000";
        document.getElementById('menu-streak-box').style.display = (gameMode === 'STREAK') ? 'block' : 'none';
        document.getElementById('vol-music-container').style.display = SETTING_MUSIC_ON ? 'flex' : 'none';
        document.getElementById('vol-sfx-container').style.display = SETTING_SFX_ON ? 'flex' : 'none';
        
        // Reset Logic
        const phoneOverlay = document.getElementById('phone-overlay');
        phoneOverlay.style.bottom = "-200px";
        phoneOverlay.dataset.phase = "0"; // Reset phase
        
        document.getElementById('blood-screen-container').innerHTML = '';
        document.getElementById('blood-screen-container').style.display = 'none';
        civilians.forEach(c => scene.remove(c.mesh)); civilians = [];
        bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
        bloodPuddles.forEach(b => scene.remove(b.mesh)); bloodPuddles = [];
        pigeons.forEach(p => scene.remove(p.mesh)); pigeons = [];
        confetti.forEach(c => scene.remove(c.mesh)); confetti = [];
        particles.forEach(p => scene.remove(p.mesh)); particles = [];
        looseItems.forEach(i => scene.remove(i.mesh)); looseItems = [];
        arrivingTrains.forEach(t => scene.remove(t.mesh)); arrivingTrains = [];
        slidingDoors.forEach(d => scene.remove(d.grp)); slidingDoors = [];
        
        // Reset trains completely
        spawnTrains();
        
        obstacles = []; // Clear obstacles (rebuilt in buildStation if static, but shops are static)
        
        shopStaff = []; 
        
        // Create Jamboni
        jamboni = createJamboni();
        
        drawBoard(["AWAITING DATA..."]);

        gameState = 'READY_CHECK'; // Wait here
        targetObj = null;
        boardDataGenerated = false;
        trainsDeparted = false;
        newsTickerActive = false;
        tickerContent = "";
        
        // Init Arrival Tracking
        initArrivalSequence();

        targetTown = DESTINATIONS[Math.floor(Math.random() * DESTINATIONS.length)];
        targetPlatform = Math.floor(Math.random() * 6); 
        spawnCrowd();
    }

    // NEW: Click "I'm Ready" to actually start audio and logic
    function confirmReady() {
        document.getElementById('ready-overlay').style.display = 'none';
        
        // IMMEDIATE AUDIO START - Solves Safari Autoplay issues
        // SFX Starts immediately
        const sfx = document.getElementById('sfx-ambience');
        if(sfx) {
            sfx.volume = 0; sfx.pause(); 
            if(SETTING_SFX_ON) { 
                sfx.currentTime = Math.random() * 58; 
                sfx.play().then(() => {
                    fadeInAudio(sfx, SETTING_SFX_VOL, 2000);
                }).catch(e => console.log("SFX play failed:", e)); 
            }
        }

        // Music Starts after 2.7s delay
        // Check for Persistence (AM Mode continuation)
        if(isAudioPersisting) {
            isAudioPersisting = false; // Clear flag, music is already running
            // Do not call playMusic() here, as it stops current track
        } else {
            if(SETTING_MUSIC_ON) {
                setTimeout(() => {
                    playMusic();
                }, 2700);
            } else if(activeMusicAudio) { 
                activeMusicAudio.pause(); activeMusicAudio = null; 
            }
        }
        
        // Start Logic
        gameState = 'MINGLE';
        gameTime = 0;
        bleedTimer = 0;
        bloodSpawned = false;
        nextPigeonTime = 5 + Math.random() * 5;
    }

    function abortMission() {
        STATS.abort++; saveSettings(); reloadWithFade();
    }

    function spawnCrowd() {
        // Workers
        for(let i=0; i<5; i++) {
            const mesh = createPerson('WORKER', (Math.random()-0.5)*200, -30 + Math.random()*10);
            civilians.push({mesh:mesh, role:'WORKER', state:'IDLE', waypoints:[]});
        }
        
        // Romance Decoy (The Special Hi-Vis)
        const romanceMesh = createPerson('ROMANCE_WORKER', (Math.random()-0.5)*180, -30);
        civilians.push({mesh:romanceMesh, role:'ROMANCE_WORKER', state:'IDLE', waypoints:[], romanceTimer: 0, romanceStage: 'WAIT', romanceLoops: 0, originalPos: romanceMesh.position.clone()});

        const guardMesh = createPerson('GUARD', (Math.random()-0.5)*200, -50);
        civilians.push({mesh:guardMesh, role:'GUARD', state:'WALKING', waypoints:[new THREE.Vector3(100,0,-50), new THREE.Vector3(-100,0,-50)], speed:0.02});
        
        // Increased Static Count by 4% (approx +1 or +2)
        const staticCount = Math.floor((5 + Math.random() * 22) * 1.04); 
        for(let i=0; i<staticCount; i++) {
            const sm = createPerson('CIV', (Math.random()-0.5)*250, 20 + Math.random()*60);
            civilians.push({mesh:sm, role:'STATIC', state:'STATIC', waypoints:[], speed:0, sway:Math.random()*100, origin: sm.position.clone() });
        }

        // NEW GROUP: Platform Edge Wanderers (1-4)
        const edgeCount = 1 + Math.floor(Math.random() * 4);
        for(let i=0; i<edgeCount; i++) {
             // Position Z around -40 to -50 (close to rails), X spread
             const em = createPerson('CIV', (Math.random()-0.5)*280, -35 - Math.random()*15);
             civilians.push({mesh:em, role:'STATIC', state:'STATIC', waypoints:[], speed:0, sway:Math.random()*100, origin: em.position.clone() });
        }

        const civCount = parseInt(SETTING_CROWD);
        const packageCount = parseInt(SETTING_PACKAGES);
        const flowerCount = Math.floor(Math.random() * 4) + 1;
        const flowerIndices = [];
        for(let i=0; i<flowerCount; i++) flowerIndices.push(Math.floor(Math.random() * civCount));
        for(let i=0; i<civCount; i++) {
            const x = (Math.random()-0.5)*280; const z = 20 + Math.random()*80;
            let role = 'CIV'; let hasPackage = false; let isDecoy = false;
            if(i < packageCount) {
                hasPackage = true;
                if(i === 0) role = 'TARGET'; else { role = 'DECOY'; isDecoy = true; }
            } else if(i >= packageCount && i < packageCount + 8) role = 'STRIPED'; 
            const mesh = createPerson(role, x, z);
            let pkg;
            if(hasPackage) {
                pkg = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.1), new THREE.MeshBasicMaterial({color: C.packageColor}));
                pkg.position.set(0.6, 1.5, 0.3); mesh.add(pkg);
            }
            if(flowerIndices.includes(i) && !hasPackage) {
                const bouquet = new THREE.Group();
                const wrap = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 8), new THREE.MeshLambertMaterial({color: 0xFFFFFF}));
                wrap.rotation.x = Math.PI; bouquet.add(wrap);
                const fCols = [0xFF0000, 0xFFFF00, 0x9900FF]; 
                for(let f=0; f<5; f++) {
                    const fMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1), new THREE.MeshBasicMaterial({color: fCols[Math.floor(Math.random()*3)]}));
                    fMesh.position.set((Math.random()-0.5)*0.2, 0.2+(Math.random()*0.1), (Math.random()-0.5)*0.2); bouquet.add(fMesh);
                }
                bouquet.position.set(0.7, 1.6, 0.5); bouquet.rotation.x = -0.5; bouquet.rotation.z = -0.2; bouquet.scale.set(2.5, 2.5, 2.5); mesh.add(bouquet);
            }
            const civ = { mesh: mesh, role: role, pkg: pkg, isDecoy: isDecoy, state: 'IDLE', waypoints: [], speed: 0.04 + Math.random()*0.02, sway: Math.random()*100 };
            if(role === 'TARGET') targetObj = civ;
            civilians.push(civ);
        }
    }

    function triggerRush() {
        gameState = 'RUSH';
        civilians.forEach(c => {
            if(c.role === 'WORKER' || c.role === 'GUARD' || c.role === 'STATIC') {
                if(c.role === 'WORKER') { c.state = 'WALKING'; c.speed = 0.02; c.waypoints = [new THREE.Vector3((Math.random()-0.5)*200, 0, -40 - Math.random()*40)]; }
                return;
            }
            
            // ROMANCE DECOY TRIGGER
            if(c.role === 'ROMANCE_WORKER') {
                c.state = 'ROMANCE_SEQUENCE';
                c.romanceStage = 'DELAY';
                c.romanceTimer = 0;
                c.delayDuration = 1.8 + Math.random() * 1.6; // 1.8 - 3.4s
                return;
            }

            c.state = 'WALKING'; c.speed *= 2.0;
            let pid = -1; let isShop = false;
            if(c.role === 'TARGET') { pid = targetPlatform; } 
            else if(c.role === 'DECOY') {
                const r = Math.random();
                if(r < 0.33) pid = (targetPlatform + 1) % 6; else if (r < 0.66) { isShop = true; c.shopSide = 'LEFT'; } else { isShop = true; c.shopSide = 'RIGHT'; }
            } else { pid = Math.floor(Math.random()*6); }
            if(isShop) {
                const sX = c.shopSide === 'LEFT' ? -160 : 160; c.waypoints = [ new THREE.Vector3(sX, 0, 0) ];
            } else {
                const pX = -100 + (pid * 40); const randOffset = (Math.random()-0.5) * 10;
                c.waypoints = [ new THREE.Vector3(pX + randOffset, 0, -20), new THREE.Vector3(pX + randOffset, 0, -60 - Math.random()*60), new THREE.Vector3(pX - 12, 0, -60 - Math.random()*60) ];
            }
        });
    }

    function updateLogic(dt) {
        gameTime += dt;
        if(gameTime > nextPigeonTime) { spawnPigeon(); nextPigeonTime = gameTime + 10 + Math.random()*15; }
        
        // --- PHONE OVERLAY LOGIC WITH EASTER EGG ---
        const overlay = document.getElementById('phone-overlay');
        const text = document.getElementById('phone-text');
        const phase = parseInt(overlay.dataset.phase || "0");
        
        // Phase 1: Show Target Info (Around 14s)
        if(phase === 0 && gameTime > 14) {
            text.innerText = "TARGET TO: " + targetTown;
            overlay.style.bottom = "20px";
            overlay.dataset.phase = "1";
        }
        
        // Phase 2: Show Base Query (After 2 minutes / 121s)
        if(phase === 1 && gameTime > 121) {
            text.innerText = "REPORT TO BASE - ETA?";
            overlay.dataset.phase = "2";
        }
        
        // Phase 3: Fade Away (After 2m30s / 151s)
        if(phase === 2 && gameTime > 151) {
            overlay.style.bottom = "-200px";
            overlay.dataset.phase = "3";
        }

        updateDoors(dt);
        
        // BUG FIX: Ensure board only generates ONCE to prevent freeze/loop
        if(gameTime > 17 && !boardDataGenerated) {
             boardDataGenerated = true;
             
             if(gameMode === 'TIMED' && !timerRunning) { timerRunning = true; timerStartTime = performance.now(); }
             let boardRows = [];
             let availableDestinations = DESTINATIONS.filter(d => d !== targetTown); let otherIdx = 0;
             let platformData = []; 
             for(let i=0; i<6; i++) { if(i === targetPlatform) platformData[i] = targetTown; else platformData[i] = availableDestinations[otherIdx++ % availableDestinations.length]; }
             let displayOrder = [0,1,2,3,4,5];
             for (let i = displayOrder.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [displayOrder[i], displayOrder[j]] = [displayOrder[j], displayOrder[i]]; }
             for(let i=0; i<6; i++) {
                 let pId = displayOrder[i]; let dest = platformData[pId]; let line = `14:0${i}  ${dest.padEnd(10, ' ')} PLAT ${pId+1}`; boardRows.push(line);
             }
             if(Math.random() < 0.25) { const idx = Math.floor(Math.random() * 6); const northDest = NORTHERN[Math.floor(Math.random()*NORTHERN.length)]; boardRows[idx] = `14:0${idx}  ${northDest.padEnd(10, ' ')} PLAT 9b`; }
             drawBoard(boardRows);
        }
        
        if(gameTime > 24 && gameState === 'MINGLE') triggerRush();

        // TRAIN DEPARTURE EVENT - CHECK EVERY FRAME
        
        trains.forEach(t => {
            if(gameTime > t.departTime && !t.hasDeparted) {
                
                // When FIRST train moves, mark time
                if(firstTrainMoveTime === -1) {
                    firstTrainMoveTime = gameTime;
                    trainsDeparted = true;
                }
                
                // Train movement + acceleration (respect slow train flag)
                if (!t.hasDeparted) {
                    // SLOWER ACCELERATION (-20%)
                    const accel = t.isSlow ? 0.45 : 3.8; 
                    t.speed += dt * accel;
                    
                    // SLOWER MAX SPEED (-20%)
                    const moveMul = t.isSlow ? 1.6 : 8.0;
                    t.mesh.position.z -= t.speed * dt * moveMul; 

                    if (t.mesh.position.z < -250) {
                        t.mesh.traverse(child => {
                            if (child.isMesh && child.material) {
                                child.material.transparent = true;
                                let opacity = 1.0 - (Math.abs(t.mesh.position.z + 250) / 150);
                                child.material.opacity = Math.max(0, opacity);
                            }
                        });
                    }

                    if (t.mesh.position.z < -500) {
                        t.hasDeparted = true;
                        scene.remove(t.mesh);
                    }
                }
            }
        });

        // NEWS TICKER LOGIC: Only activate AFTER first train has moved + random delay
        if (firstTrainMoveTime > 0 && !newsTickerActive) {
            if (gameTime > (firstTrainMoveTime + newsDelay)) {
                newsTickerActive = true;
            }
        }
        
                // --- SECOND ACT: ARRIVAL SEQUENCE ---
        if(gameTime > arrivalStartTime) {
            // Check through scheduled arrivals
            arrivalTrainData.forEach((data) => {
                const triggerTime = arrivalStartTime + data.delay;
                
                // 1. Spawn Train Object offscreen
                if(gameTime > triggerTime && !data.spawned) {
                    data.spawned = true;
                    const x = -100 + (data.platformIdx * 40);
                    const trainGrp = new THREE.Group();
                    
                    // CLOSER PARKING: 
                    // Previously offset was -16. Now updated logic uses -13.5 in createTrain and spawnArrivingPassenger
                    // createTrain expects platform offset.
                    // IMPORTANT: zStart must be 0 here so that trainGrp.position.z correctly represents the front of the train in world space.
                    const sirenMesh = createTrain(x - 13.5, -1.0, 0, trainGrp, data.color, {
                        isStripe: (data.type === 'STRIPE'),
                        isSiren: (data.type === 'SIREN')
                    });
                    
                    // NEW PHYSICS: Spawn closer.
                    // If target Z is ~-30, spawn ~-110.
                    // Store randomized target
                    trainGrp.position.z = data.targetZ - 80; // Start 80 units away (visible but back)
                    
                    scene.add(trainGrp);
                    arrivingTrains.push({
                        mesh: trainGrp,
                        data: data,
                        atStation: false,
                        speed: 40.0, // Initial high approach speed
                        sirenMesh: sirenMesh, // Reference for flashing
                        stationTimer: 0 // Timer for door delay
                    });
                }
            });
            
            // 2. Move Arrival Trains
            let allArrived = true;
            let anyArrived = false;
            arrivingTrains.forEach(t => {
                // Flash Siren Logic
                if(t.data.type === 'SIREN' && t.sirenMesh) {
                    // Flash interval based on gameTime
                    const val = Math.sin(gameTime * 20); // Fast flash
                    if(val > 0) t.sirenMesh.material.emissive.setHex(0xFF0000);
                    else t.sirenMesh.material.emissive.setHex(0x000000);
                }

                if(!t.atStation) {
                    allArrived = false;
                    
                    // REVERSE DEPARTURE PHYSICS with LATE BRAKING
                    const dist = t.data.targetZ - t.mesh.position.z;
                    
                    if(dist < 0.2) {
                        t.mesh.position.z = t.data.targetZ;
                        t.speed = 0;
                        t.atStation = true;
                    } else {
                        // Late Deceleration Logic
                        // Maintain high speed until dist < 30
                        let targetSpeed = 0;
                        if(dist > 30) targetSpeed = 35.0; // Cruise fast
                        else if (dist > 5) targetSpeed = 15.0; // Hard brake
                        else targetSpeed = 2.0; // Roll last bit

                        // Lerp actual speed to desired (responsiveness)
                        t.speed += (targetSpeed - t.speed) * 3.0 * dt;
                        
                        t.mesh.position.z += t.speed * dt;
                        
                        // Simple Fade In based on dist from start
                        // If it started at targetZ - 80...
                        // Just ensure opacity is 1.0 (spawned close enough to be solid or fading quickly)
                        t.mesh.traverse(child => {
                             if (child.isMesh && child.material) {
                                 // Fade in over first 10 units of travel
                                 const travel = (t.mesh.position.z - (t.data.targetZ - 80));
                                 let opacity = Math.min(1.0, travel / 20.0);
                                 // Or just maximize it since user wants them "arriving quickly"
                                 child.material.transparent = true;
                                 child.material.opacity = Math.max(opacity, 0.1);
                             }
                        });
                    }
                } else {
                    anyArrived = true;
                    // 3. Spawn Passengers logic
                    // ADDED DOOR DELAY: Wait 15s after stopping
                    t.stationTimer += dt;
                    
                    if(t.stationTimer > 15.0) {
                        t.data.passengerTimer += dt;
                        const expected = Math.floor((t.data.passengerTimer / t.data.passengerTotalTime) * t.data.passengerCount);
                        const toSpawn = Math.min(expected - t.data.passengersSpawned, t.data.passengerCount - t.data.passengersSpawned);
                        
                        if(toSpawn > 0) {
                            for(let k=0; k<toSpawn; k++) {
                                // DETERMINE IF THIS IS THE GREEN TARGET
                                let isGreen = false;
                                if(!greenTargetAssigned) {
                                    // Simple chance per spawn to trigger, must ensure it happens eventually though
                                    // Let's just do random chance, but force it if last passenger
                                    const remaining = t.data.passengerCount - t.data.passengersSpawned - k;
                                    if(Math.random() < 0.05 || (arrivalPhase === 'ARRIVING' && remaining === 1)) {
                                        isGreen = true;
                                        greenTargetAssigned = true;
                                        greenTargetSpawned = true;
                                    }
                                }
                                spawnArrivingPassenger(t.data, isGreen);
                                t.data.passengersSpawned++;
                            }
                        }
                    }
                }
            });
            
            if(allArrived && arrivingTrains.length === 6) {
                if(!lateDepartureTriggered) {
                     lateDepartureTriggered = true;
                     // Set departure 38-46s from now
                     lateDepartureTime = gameTime + 38 + Math.random() * 8;
                }
            }
            
            // 4. Late Departure Logic
            if(lateDepartureTriggered && gameTime > lateDepartureTime) {
                // Chain Reaction Trigger
                if (!chainReactionTriggered) {
                    chainReactionTriggered = true;
                    // Find 2 more random trains that are sitting there
                    const sitting = arrivingTrains.filter(t => t.atStation && !t.isLeaving);
                    // Shuffle
                    for (let i = sitting.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [sitting[i], sitting[j]] = [sitting[j], sitting[i]];
                    }
                    
                    // Pick up to 2
                    const extraDepartures = sitting.slice(0, 2);
                    extraDepartures.forEach(t => {
                        const delay = 5 + Math.random() * 42; // 5-47 seconds later
                        t.scheduledDeparture = gameTime + delay;
                    });
                }
                
                // Pick random arrived train to leave (The Trigger Train)
                const sitting = arrivingTrains.filter(t => t.atStation && !t.isLeaving && !t.scheduledDeparture);
                if(sitting.length > 0) {
                     // Check if any already leaving to avoid double trigger if desired, but code allows one main trigger
                     const leaving = arrivingTrains.find(t => t.isLeaving && !t.scheduledDeparture);
                     if(!leaving) {
                         const t = sitting[Math.floor(Math.random()*sitting.length)];
                         t.isLeaving = true;
                     }
                }
                
                // Move leaving trains (Main + Scheduled Extras)
                arrivingTrains.forEach(t => {
                    if (t.scheduledDeparture && gameTime > t.scheduledDeparture) {
                        t.isLeaving = true;
                    }
                    
                    if(t.isLeaving) {
                        t.mesh.position.z -= 4.0 * dt; // Very slow departure
                    }
                });
            }
        }
    }

    function createParticle(x, y, z, col, speed) {
        const p = createBlock(0.3, 0.3, 0.3, col, x, y, z, null);
        particles.push({ mesh: p, vel: new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed, (Math.random()-0.5)*speed), life: 1.0 });
    }

    function spawnFireworks() {
        for(let i=0; i<5; i++) {
            setTimeout(() => {
                const cx = (Math.random()-0.5)*200; const cy = 50 + Math.random()*50; const cz = -50 + (Math.random()-0.5)*100;
                const col = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF][Math.floor(Math.random()*5)];
                for(let j=0; j<30; j++) createParticle(cx, cy, cz, col, 2.0);
            }, i*500);
        }
    }

    function updateLooseItems(dt) {
    for (let i = looseItems.length - 1; i >= 0; i--) {
        const item = looseItems[i];
        if (item.life > 0) {
            // Move the item
            item.mesh.position.add(item.vel.clone().multiplyScalar(dt * 60)); // scale by dt*60 to match other movement
            item.mesh.rotation.x += item.rotVel.x;
            item.mesh.rotation.z += item.rotVel.z;

            // Basic drag & gravity imitation
            item.vel.multiplyScalar(0.96);
            item.vel.y -= 9.8 * dt * 0.02; // slight gravity so it drops a little faster

            // Physics Fix: Keep on floor (adjusted for better visibility)
            if (item.mesh.position.y < 0.25) { 
                item.mesh.position.y = 0.25; 
                item.vel.y = 0; 
                // Increased friction on ground to prevent skating/spin glitches
                item.vel.x *= 0.8;
                item.vel.z *= 0.8;
                item.rotVel.multiplyScalar(0.5);
            }

            // COLLISION: luggage hits a single civilian
            if (!item.hasHit) {
                for (let c = 0; c < civilians.length; c++) {
                    const civ = civilians[c];
                    if (!civ || !civ.mesh) continue;
                    // ignore the original owner falling etc — we only check for OTHER civilians
                    // distance threshold tuned to match visual scale (approx 1.0 units)
                    const dist = item.mesh.position.distanceTo(civ.mesh.position);
                    if (dist < 1.0) {
                        // Mark this item as having hit someone, so it won't hit multiple
                        item.hasHit = true;

                        // Knock the civilian over (one-time)
                        try {
                            // Give the victim a 'down' rotation & small upward pop so it's visually distinct
                            civ.mesh.rotation.x = -Math.PI / 2;
                            // Slight lift/jerk if still above ground
                            civ.mesh.position.y = Math.max(0.02, civ.mesh.position.y - 0.05);

                            // Spawn a blood puddle under them (reuse spawnBlood logic)
                            spawnBlood(civ);

                            // If there is a victimRef used elsewhere, set it for bleed animation path if appropriate
                            victimRef = civ;

                            // Make the civ state explicit to avoid further AI movement
                            civ.state = 'DOWN';
                        } catch (e) {
                            console.warn("Luggage hit handling error:", e);
                        }
                    }
                }
            }
            
            // NOTE: life decrements, but we set it very high initially now
            item.life -= dt;
        } else {
            // Clean up expired item
            if (item.mesh) {
                scene.remove(item.mesh);
                try { if (item.mesh.geometry) item.mesh.geometry.dispose(); if (item.mesh.material) item.mesh.material.dispose(); } catch (e) {}
            }
            looseItems.splice(i, 1);
        }
    }
}


    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        
        // Always draw matrix, but it handles speed inside the function
        drawMatrix();

        if(gameState === 'MENU' || gameState === 'ENDED') { 
            return; 
        }

        if(timerRunning) {
            const now = performance.now(); const elapsed = (now - timerStartTime) / 1000;
            document.getElementById('timer-ui').innerText = elapsed.toFixed(3);
        }
        
        // BOARD ANIMATION LOOP
        if(newsTickerActive) {
            drawBoard([], true);
        }

        if(gameState === 'BLEEDING') {
            bleedTimer += dt;
            if(victimRef && victimRef.mesh) {
                if(victimRef.role === 'TARGET' || victimRef.role === 'COURIER' || victimRef.role === 'GREEN_TARGET') {
                    if(victimRef.mesh.rotation.x > -Math.PI/2) { victimRef.mesh.rotation.x -= dt * 5.0; victimRef.mesh.position.y = Math.max(0.2, victimRef.mesh.position.y - dt); } 
                    else if(bleedTimer > 1.0 && victimRef.mesh.position.y < 15) { victimRef.mesh.position.y += dt * 2.0; victimRef.mesh.rotation.y = 0; }
                } else {
                    if(victimRef.mesh.rotation.x > -Math.PI/2) { victimRef.mesh.rotation.x -= dt * 5.0; victimRef.mesh.position.y = Math.max(0.2, victimRef.mesh.position.y - dt); }
                }
            }
            updateLooseItems(dt);
            if(bleedTimer > 0.3 && !bloodSpawned) { spawnBlood(victimRef); bloodSpawned = true; }
            if(bloodPuddles.length > 0) { const p = bloodPuddles[bloodPuddles.length-1]; if(p.scale < 1.5) { p.scale += dt * 2; p.mesh.scale.setScalar(p.scale); } }
            if(bleedTimer > 4.5) {
                if(resultIsWin) {
                    if(gameMode === 'TIMED' && isHighscore(finalTime)) {
                        gameState = 'INPUT_SCORE'; document.getElementById('high-score-modal').style.display = 'flex';
                        document.getElementById('new-record-time').innerText = finalTime.toFixed(3) + "s";
                        document.getElementById('hs-input').value = ""; document.getElementById('hs-input').focus();
                    } else showEndScreen();
                } else { gameState = 'SCREEN_EFFECT'; bleedTimer = 0; triggerScreenBlood(); }
            }
            renderer.render(scene, camera); return;
        }
        
        if(gameState === 'INPUT_SCORE' || gameState === 'READY_CHECK') {
            // While in ready check, allow simple idle animations but NO game time progress
            civilians.forEach(c => { if(c.role === 'STATIC') c.mesh.rotation.y = Math.sin(Date.now()*0.001 + c.sway) * 0.5; });
            renderer.render(scene, camera);
            return;
        }

        if(gameState === 'SCREEN_EFFECT') {
            bleedTimer += dt; if(bleedTimer > 2.0) showEndScreen(); renderer.render(scene, camera); return;
        }

        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i]; 
            p.mesh.position.add(p.vel.clone().multiplyScalar(dt)); // Scale velocity by dt for all particles now
            
            if(p.isFeather) {
                 // Feathers float down gently with sway
                 p.mesh.position.x += Math.sin(gameTime * 3 + p.life) * 0.05;
                 p.mesh.position.z += Math.cos(gameTime * 2 + p.life) * 0.05;
                 p.mesh.rotation.x += dt;
                 p.mesh.rotation.y += dt;
                 // Fade out logic (scale)
                 const scale = (p.life / p.maxLife); // 1 to 0
                 p.mesh.scale.setScalar(scale);
            } else if (p.isVape) {
                 // Vape smoke: float up + drag + fade/shrink
                 p.vel.y += dt * 0.5; // Acceleration up
                 p.vel.x *= 0.95; // Drag
                 p.vel.z *= 0.95; 
                 p.mesh.scale.setScalar(p.life * 0.5); 
            } else {
                 // Standard fireworks scaling
                 p.mesh.scale.setScalar(p.life);
            }

            p.life -= dt; 
            if(p.life <= 0) { 
                scene.remove(p.mesh); 
                // BUG FIX: Dispose geometry to prevent memory leak/freeze over time
                if(p.mesh.geometry) p.mesh.geometry.dispose();
                if(p.mesh.material) p.mesh.material.dispose();
                particles.splice(i,1); 
            }
        }
        confetti.forEach(c => { c.mesh.position.y -= c.speed; c.mesh.rotation.x += 0.1; });
        if(gameState === 'ENDED') return;

        updateLogic(dt);
        updateJamboni(dt); // Update the cleaner
        updateShopStaff(dt); // Update shopkeepers
        
        const aimSpeed = isZoomed ? 0.2 * dt : 1.0 * dt;
        if(keyState['w'] || keyState['arrowup']) pitch += aimSpeed; if(keyState['s'] || keyState['arrowdown']) pitch -= aimSpeed;
        if(keyState['a'] || keyState['arrowleft']) yaw += aimSpeed; if(keyState['d'] || keyState['arrowright']) yaw -= aimSpeed;
        pitch = Math.max(-1.2, Math.min(0.2, pitch)); camera.rotation.x = pitch; camera.rotation.y = yaw;
        
        // --- LOOP CIVILIANS (Modified for Fade Out & Phone Trigger) ---
        for(let i=civilians.length-1; i>=0; i--) {
            const c = civilians[i];
            
            // FADE OUT LOGIC FOR EXITING PASSENGERS
            if(c.state === 'EXITING' && c.waypoints.length === 0) {
                // At final waypoint, fade out
                c.opacity -= dt * 1.0;
                if(c.opacity <= 0) {
                    scene.remove(c.mesh);
                    civilians.splice(i,1);
                    continue;
                } else {
                    // Traverse children to set opacity
                    c.mesh.traverse(child => {
                        if(child.isMesh) {
                            child.material.transparent = true;
                            child.material.opacity = c.opacity;
                        }
                    });
                }
            }
            
            // ALERT TRIGGER LOGIC FOR GREEN TARGET
            if(c.role === 'GREEN_TARGET' && !c.hasTriggeredAlert) {
                // Check position Z
                if(c.mesh.position.z > -20) {
                     c.hasTriggeredAlert = true;
                     // DELAY ALERT 1.5s
                     setTimeout(() => {
                         // Only if game still active
                         if(gameState !== 'ENDED' && gameState !== 'BLEEDING') {
                            const overlay = document.getElementById('phone-overlay');
                            const body = document.getElementById('phone-text');
                            overlay.style.bottom = "20px";
                            overlay.dataset.phase = "99"; 
                            
                            document.querySelector('.intel-header').innerText = "PRIORITY ALERT";
                            document.querySelector('.intel-header').style.color = "#FFCC00"; // Revert to standard Amber
                            
                            // Human readable package color
                            let colName = "NEON GREEN";
                            if(currentPackageType === 'WHITE') colName = "WHITE";
                            if(currentPackageType === 'LIGHT_BLUE') colName = "LIGHT BLUE";
                            
                            body.innerText = "NEW TARGET: "+colName+" PACKAGE HOLDER. SHOOT TO KILL.";
                            body.style.color = "#fff"; // Revert to white
                         }
                     }, 1500);
                }
            }
            
            // TARGET LOST CHECK (GREEN TARGET ESCAPED)
            if(c.role === 'GREEN_TARGET' && Math.abs(c.mesh.position.x) > 220) {
                if(gameState !== 'ENDED' && gameState !== 'BLEEDING') {
                    const overlay = document.getElementById('phone-overlay');
                    const body = document.getElementById('phone-text');
                    overlay.style.bottom = "20px";
                    
                    document.querySelector('.intel-header').innerText = "MISSION FAILED";
                    document.querySelector('.intel-header').style.color = "#FF0000"; 
                    body.innerText = "LOST THEM. GET BACK TO BASE ASAP.";
                    body.style.color = "#FF0000";
                    
                    // Trigger Fail State immediately or allow player to read?
                    // Let's trigger loss after 3 seconds so they can read it.
                    if(!c.hasLostTriggered) {
                        c.hasLostTriggered = true;
                        setTimeout(() => {
                            if(gameState !== 'ENDED') {
                                resultIsWin = false;
                                resultReason = "TARGET ESCAPED. MISSION COMPROMISED.";
                                victimSurvivalStatus = "AT LARGE"; 
                                showEndScreen();
                            }
                        }, 3500);
                    }
                }
            }
            
            // ROMANCE DECOY STATE MACHINE
            if (c.role === 'ROMANCE_WORKER' && c.state === 'ROMANCE_SEQUENCE') {
                c.romanceTimer += dt;
                
                if (c.romanceStage === 'DELAY') {
                    // Milled about for 1.8-3.4s before moving
                    if (c.romanceTimer > c.delayDuration) {
                        c.romanceStage = 'WALK_TO_SHOP';
                        // Vape shop at x=100, z=80. Desk is inside. Stand in front.
                        c.waypoints = [new THREE.Vector3(100, 0, 70)];
                        c.speed = 0.04 + (Math.random() - 0.5) * 0.01; // Vary speed slightly
                    }
                } else if (c.romanceStage === 'WALK_TO_SHOP') {
                    // Movement handled by generic logic below
                    if (c.waypoints.length === 0) {
                        // Arrived
                        c.romanceStage = 'FLIRTING';
                        c.romanceTimer = 0;
                        c.romanceAction = 'TWIST';
                        c.romanceActionTimer = 0;
                        c.romanceLoops = 0;
                    }
                } else if (c.romanceStage === 'FLIRTING') {
                    c.romanceActionTimer += dt;
                    
                    if (c.romanceAction === 'TWIST') {
                        // Twisting side to side for 3-5s
                        c.mesh.rotation.y = Math.sin(c.romanceActionTimer * 3.0) * 0.5 + Math.PI; // Face shop (Z+)
                        
                        const dur = 3 + Math.random() * 2;
                        if (c.romanceActionTimer > dur) {
                            c.romanceAction = 'STILL';
                            c.romanceActionTimer = 0;
                            c.mesh.rotation.y = Math.PI; // Face shop
                        }
                    } else if (c.romanceAction === 'STILL') {
                        // Standing still for 12s
                        if (c.romanceActionTimer > 12.0) {
                            c.romanceAction = 'TWIST';
                            c.romanceActionTimer = 0;
                            c.romanceLoops++;
                            if (c.romanceLoops >= 3) {
                                // Done flirting, return halfway back
                                c.romanceStage = 'RETURNING';
                                
                                // Calculate halfway point
                                const current = c.mesh.position.clone();
                                const origin = c.originalPos;
                                const halfway = new THREE.Vector3().lerpVectors(current, origin, 0.5);
                                c.waypoints = [halfway];
                            }
                        }
                    }
                } else if (c.romanceStage === 'RETURNING') {
                    if (c.waypoints.length === 0) {
                        c.romanceStage = 'IDLE_TWIST';
                        c.romanceTimer = 0;
                        // Angle towards shop (approx)
                        const dir = new THREE.Vector3(100, 0, 70).sub(c.mesh.position).normalize();
                        c.mesh.lookAt(c.mesh.position.clone().add(dir));
                        c.idleTwistInterval = 20 + Math.random() * 20; // 20-40s
                    }
                } else if (c.romanceStage === 'IDLE_TWIST') {
                    // Twist every 20-40s
                    c.romanceTimer += dt;
                    if (c.romanceTimer > c.idleTwistInterval) {
                        c.mesh.rotation.y += Math.sin(dt * 2.0) * 0.05; // Gentle twitch
                        // Reset timer after small duration
                        if (c.romanceTimer > c.idleTwistInterval + 2.0) {
                            c.romanceTimer = 0;
                            c.idleTwistInterval = 20 + Math.random() * 20;
                        }
                    }
                }
            }


            if(c.role === 'STATIC') {
                c.mesh.rotation.y = Math.sin(gameTime + c.sway) * 0.5;
                if(c.state === 'STATIC' && Math.random() < 0.005) {
                     c.state = 'WANDERING'; const angle = Math.random() * Math.PI * 2; const dist = 5 + Math.random()*5;
                     c.waypoints = [new THREE.Vector3(c.origin.x + Math.cos(angle)*dist, 0, c.origin.z + Math.sin(angle)*dist)]; c.speed = 0.02;
                }
            }
            if(c.state === 'IDLE' && c.role !== 'WORKER' && c.role !== 'ROMANCE_WORKER' && Math.random() < 0.01) {
                 c.state = 'WALKING'; c.waypoints = [new THREE.Vector3((Math.random()-0.5)*250, 0, 20 + Math.random()*80)];
            }
            
            // GENERAL MOVEMENT LOGIC (Applies to all walking states including ROMANCE logic)
            if((c.state === 'WALKING' || c.state === 'WANDERING' || c.state === 'ROMANCE_SEQUENCE' || c.state === 'EXITING') && c.waypoints.length > 0) {
                // If in romance sequence but waiting/flirting/pining, skip movement
                if (c.role === 'ROMANCE_WORKER' && (c.romanceStage === 'DELAY' || c.romanceStage === 'FLIRTING' || c.romanceStage === 'IDLE_TWIST')) continue;

                const target = c.waypoints[0];
                const dir = new THREE.Vector3().subVectors(target, c.mesh.position);
                if(statuePos && c.mesh.position.distanceTo(statuePos) < 8) dir.add(c.mesh.position.clone().sub(statuePos).normalize().multiplyScalar(0.5));
                
                // Obstacle Avoidance (Collision Check)
                let collision = false;
                for(let ob of obstacles) {
                     let dist = c.mesh.position.distanceTo(new THREE.Vector3(ob.x, 0, ob.z));
                     if(dist < ob.r) {
                         collision = true;
                         // HARD COLLISION FIX: Push to edge of radius immediately
                         let pushDir = c.mesh.position.clone().sub(new THREE.Vector3(ob.x, 0, ob.z)).normalize();
                         // Ensure we don't get NaN if exactly on top (rare but possible)
                         if (pushDir.lengthSq() === 0) pushDir.set(1, 0, 0);
                         
                         let newPos = new THREE.Vector3(ob.x, 0, ob.z).add(pushDir.multiplyScalar(ob.r + 0.5));
                         c.mesh.position.x = newPos.x;
                         c.mesh.position.z = newPos.z;
                     }
                }

                if(dir.length() < 1.0 && !collision) {
                    c.waypoints.shift();
                    if(c.waypoints.length === 0) {
                        if(c.role === 'GUARD') c.waypoints = [new THREE.Vector3(c.mesh.position.x > 0 ? -100 : 100, 0, -50)];
                        else if(gameState === 'RUSH' && c.role !== 'WORKER' && c.role !== 'ROMANCE_WORKER' && c.role !== 'STATIC') { c.state = 'BOARDED'; scene.remove(c.mesh); } 
                        else if(c.role === 'STATIC') { c.state = 'STATIC'; } else if (c.role !== 'ROMANCE_WORKER' && c.state !== 'EXITING') c.state = 'IDLE';
                    }
                } else {
                    dir.normalize(); 
                    const moveVec = dir.multiplyScalar(c.speed * 60 * dt);
                    c.mesh.position.add(moveVec); 
                    c.mesh.lookAt(c.mesh.position.clone().add(dir));
                    const legL = c.mesh.children[0]; const legR = c.mesh.children[1];
                    legL.rotation.x = Math.sin(gameTime * 15 + c.sway) * 0.6; legR.rotation.x = -Math.sin(gameTime * 15 + c.sway) * 0.6;
                }
            }
        }

        for(let i=pigeons.length-1; i>=0; i--) {
            const p = pigeons[i]; 
            
            // Chaotic Movement Logic
            let currentVel = p.vel.clone();
            
            if(p.isChaotic) {
                // Apply chaotic wave functions based on time and seed
                // Use a faster time scale for "twitchy" chaotic movement
                // Twist and turn over "concourse-ish area" (Z > -30)
                if (p.mesh.position.z > -30) {
                     const chaosT = gameTime * 3.0 + p.seed;
                     currentVel.y += Math.sin(chaosT * 2.0) * 8; // Vertical wobble
                     currentVel.z += Math.cos(chaosT * 1.5) * 15; // Horizontal sway
                     
                     // Rotation banking
                     p.mesh.rotation.z = Math.sin(chaosT) * 0.8; 
                     p.mesh.rotation.x = Math.cos(chaosT * 0.5) * 0.3;
                     
                     // Drop Feathers
                     if(gameTime > p.nextFeather) {
                         // Random small burst of 2-3 feathers
                         const count = 2 + Math.floor(Math.random()*2);
                         for(let f=0; f<count; f++) {
                             // Slight random offset for feather spawn
                             const fPos = p.mesh.position.clone();
                             fPos.x += (Math.random()-0.5);
                             fPos.y -= 0.2;
                             fPos.z += (Math.random()-0.5);
                             createFeather(fPos);
                         }
                         // Random delay before next drop (0.3s to 0.8s)
                         p.nextFeather = gameTime + 0.3 + Math.random() * 0.5;
                     }
                }
            }

            p.mesh.position.add(currentVel.multiplyScalar(dt));
            
            // Despawn
            if(Math.abs(p.mesh.position.x) > 300) { scene.remove(p.mesh); pigeons.splice(i,1); }
        }
        
        bullets.forEach((b,i) => { b.age+=dt; b.mesh.material.opacity-=dt*3; if(b.age>0.3){scene.remove(b.mesh);bullets.splice(i,1);} });
        const fov = isZoomed ? 10 : 60; camera.fov += (fov - camera.fov) * 0.15; camera.updateProjectionMatrix();
        renderer.render(scene, camera);
    }

    function fire() {
        try {
            camera.position.y += 0.5; setTimeout(()=>camera.position.y-=0.5, 80);
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            const ray = raycaster.ray; const start = camera.position.clone().add(new THREE.Vector3(0,-1,0)); const end = ray.at(300, new THREE.Vector3());
            const geo = new THREE.CylinderGeometry(0.05,0.05,start.distanceTo(end),4); geo.rotateX(-Math.PI/2); geo.translate(0,0,start.distanceTo(end)/2);
            const tracer = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0xFFFF00, transparent:true, opacity:0.8}));
            tracer.position.copy(start); tracer.lookAt(end); scene.add(tracer); bullets.push({mesh:tracer, age:0});

            // SMART TARGETING FIX:
            let firstCivHit = null;
            let targetHitDist = -1;

            for(let hit of intersects) {
                let obj = hit.object; 
                // TRAVERSE UP TO ROOT OBJECT
                // Stop at Scene, or specific roots like "PERSON_ROOT"
                let safeguard = 0; 
                while(obj.parent && obj.parent.type !== 'Scene' && obj.name !== 'PERSON_ROOT' && safeguard < 100) { 
                    obj = obj.parent; 
                    safeguard++; 
                }
                
                // CHECK IF OBJECT IS A CIVILIAN OR SHOP STAFF
                let civ = civilians.find(c => c.mesh === obj); 
                
                // IF NOT IN CIVILIAN LIST, CHECK SHOP STAFF
                if(!civ) {
                    const staff = shopStaff.find(s => s.mesh === obj);
                    if(staff) civ = { mesh: staff.mesh, role: 'STATIC' }; // Treat staff as static civ for hit logic
                }

                if(civ) {
                    if(!firstCivHit) firstCivHit = { civ: civ, dist: hit.distance };
                    if(civ === targetObj) targetHitDist = hit.distance;
                }
            }

            // Decision Logic:
            if(targetHitDist !== -1 && firstCivHit) {
                if(targetHitDist <= firstCivHit.dist + 2.5) {
                    processHit(targetObj);
                    return;
                }
            }

            if(firstCivHit) {
                processHit(firstCivHit.civ);
            }

        } catch(e) { console.error("Fire Error:", e); }
    }

    function processHit(civ) {
        document.getElementById('scope-overlay').style.display = 'none';
        if(timerRunning) { timerRunning = false; finalTime = (performance.now() - timerStartTime) / 1000; }
        
        // WIN CONDITIONS: MAIN TARGET OR GREEN TARGET
        if(civ === targetObj) { 
            resultIsWin = true; KILL_STREAK++; STATS.target++; 
        } else if(civ.role === 'GREEN_TARGET') {
            resultIsWin = true; KILL_STREAK++; STATS.target++;
            // Specific win flavor for green target
            resultReason = "SECONDARY TARGET ELIMINATED."; 
        } else {
            resultIsWin = false; KILL_STREAK = 0; victimRef = civ;
            if(civ.role === 'DECOY') { resultReason = "WRONG TARGET. DECOY."; STATS.decoy++; }
            else if(civ.role === 'STRIPED') { resultReason = "CIVILIAN KILLED. INNOCENT."; STATS.civ++; }
            else if(civ.role === 'STATIC') { resultReason = "BYSTANDER CASUALTY."; STATS.civ++; }
            else if(civ.role === 'GUARD') { resultReason = "OFFICER DOWN. DISASTER."; STATS.civ++; }
            else if(civ.role === 'ROMANCE_WORKER') { resultReason = "WORKER KILLED. INNOCENT."; STATS.civ++; }
            else { resultReason = "COLLATERAL DAMAGE."; STATS.civ++; }
            
            // HOSPITALISED LOGIC
            // CHANGED: 57% chance of hospitalised, 43% chance deceased
            if (Math.random() < 0.57) {
                victimSurvivalStatus = "HOSPITALISED";
            } else {
                victimSurvivalStatus = "DECEASED";
            }

            // GENERATE BIO FOR FAILURE
            const bio = generateBio();
            document.getElementById('bio-name').innerText = bio.name;
            document.getElementById('bio-dob').innerText = bio.dob;
            document.getElementById('bio-ssn').innerText = bio.ssn;
            document.getElementById('bio-blood').innerText = bio.blood;
            document.getElementById('bio-nation').innerText = bio.nationality;
            document.getElementById('bio-movie').innerText = bio.movie;
            document.getElementById('bio-music').innerText = bio.album;
            document.getElementById('bio-id-num').innerText = Math.floor(1000 + Math.random()*9000) + "-X";
            
            // ALWAYS USE MALE SVG (AS PER REQUEST)
            document.getElementById('bio-pic').innerHTML = SVG_MALE;
        }
        saveSettings();
        if(civ && civ.mesh) {
            const luggage = civ.mesh.getObjectByName("LUGGAGE");
            if(luggage) {
                const worldPos = new THREE.Vector3(); luggage.getWorldPosition(worldPos);
                const worldQuat = new THREE.Quaternion(); luggage.getWorldQuaternion(worldQuat);
                civ.mesh.remove(luggage); scene.add(luggage);
                luggage.position.copy(worldPos); luggage.quaternion.copy(worldQuat);
                const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(civ.mesh.quaternion).normalize();
                
                // INCREASED VELOCITY (by ~8% -> 5.0 * 1.08 = 5.4)
                const speed = (civ.speed || 0.04) * 5.4; 
                looseItems.push({ 
                    mesh: luggage, 
                    vel: forward.multiplyScalar(speed).add(new THREE.Vector3((Math.random()-0.5)*0.2, 0, (Math.random()-0.5)*0.2)), 
                    rotVel: new THREE.Vector3((Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1), 
                    life: 20.0 // Long life so it survives killcam
                });
            }
            civ.mesh.rotation.x = 0; 
        }
        gameState = 'BLEEDING'; bleedTimer = 0; bloodSpawned = false;
    }

    function isHighscore(time) {
        if(LEADERBOARD.length < 5) return true;
        const worst = Math.max(...LEADERBOARD.map(e => e.time)); return time < worst;
    }

    function submitScore() {
        const input = document.getElementById('hs-input');
        const initials = input.value.toUpperCase().substring(0,3) || "UNK";
        LEADERBOARD.push({name: initials, time: finalTime});
        LEADERBOARD.sort((a,b) => a.time - b.time);
        if(LEADERBOARD.length > 5) LEADERBOARD = LEADERBOARD.slice(0,5);
        saveSettings();
        document.getElementById('high-score-modal').style.display = 'none';
        reloadWithFade(); 
    }

    function spawnBlood(civ) {
        if(!civ || !civ.mesh) return;
        const b = new THREE.Mesh(new THREE.CircleGeometry(0.6,16), new THREE.MeshBasicMaterial({color:0xaa0000, depthTest:false, transparent:false}));
        b.renderOrder = 999; b.rotation.x = -Math.PI/2; 
        b.position.set(civ.mesh.position.x, 0.02, civ.mesh.position.z); scene.add(b);
        bloodPuddles.push({mesh:b, scale:0.1}); 
    }

    function triggerScreenBlood() {
        const cont = document.getElementById('blood-screen-container');
        cont.innerHTML = ''; cont.style.display = 'block';
        for(let i=0; i<60; i++) {
            const d = document.createElement('div'); d.className = 'drip'; d.style.left = (Math.random()*100)+'%'; 
            d.style.height = (50+Math.random()*200)+'px'; d.style.transition = 'top '+(1+Math.random()*2)+'s';
            cont.appendChild(d); setTimeout(()=>d.style.top = '-20px', 100);
        }
    }

    function showEndScreen() {
        gameState = 'ENDED';
        document.getElementById('menu').style.display = 'flex';
        document.getElementById('start-dossier').style.display = 'none';
        document.getElementById('end-dossier').style.display = 'block';
        const endDossier = document.getElementById('end-dossier');
        endDossier.className = resultIsWin ? 'dossier win-theme' : 'dossier lose-theme';
        const stamp = document.getElementById('end-stamp');
        const title = document.getElementById('outcome-title');
        const desc = document.getElementById('outcome-desc');
        const award = document.getElementById('award-text');
        const bioOverlay = document.getElementById('bio-overlay');
        const resHeaders = document.getElementById('result-headers');

        // ANIMATION RESET
        stamp.classList.remove('slammed'); // Reset animation
        stamp.style.opacity = '0'; // Ensure hidden initially
        
        // Reset Read More
        const masked = document.getElementById('bio-masked-area');
        const btn = document.getElementById('bio-read-more');
        masked.classList.remove('open');
        btn.style.display = 'block';
        
        // --- RESET REPLAY BUTTON STATE ---
        const replayBtn = document.getElementById('replay-btn');
        if(replayBtn) {
            replayBtn.innerHTML = "REPLAY WITH SAME SETTINGS";
            replayBtn.classList.remove('clicked');
        }
        
        // Trigger Stamp Slam after slight delay
        setTimeout(() => {
            stamp.classList.add('slammed');
        }, 800);

        if(resultIsWin) {
            bioOverlay.style.display = 'none';
            resHeaders.style.marginBottom = '20px';
            for(let i=0; i<100; i++) {
                const c = createBlock(0.5, 0.5, 0, [0xff0000,0x00ff00,0xffff00][Math.floor(Math.random()*3)], (Math.random()-0.5)*50, 40+Math.random()*20, -50);
                confetti.push({mesh:c, speed:Math.random()*0.5});
            }
            spawnFireworks();
            const rndTitle = WIN_TITLES[Math.floor(Math.random() * WIN_TITLES.length)];
            stamp.innerText = "SUCCESS"; 
            stamp.style.color = "#00AA00"; stamp.style.borderColor = "#00AA00";
            title.innerText = rndTitle; 
            if(gameMode === 'TIMED') {
                desc.innerText = "TARGET DOWN. TIME: " + finalTime.toFixed(3) + "s";
                desc.style.color = "#ccc"; // Keep grey for Timed mode stats
                award.innerText = "";
                renderLeaderboard(); 
            } else {
                if(victimRef && victimRef.role === 'GREEN_TARGET') {
                    desc.innerText = "SECONDARY TARGET ELIMINATED. BONUS SECURED.";
                } else {
                    desc.innerText = "TARGET NEUTRALIZED. THE CROWN SLEEPS SAFELY.";
                }
                // UPDATED COLOR TO DARK GREY/BROWN
                desc.style.color = "#4b3621"; 
                award.innerText = generateCodeName();
            }
        } else {
            // SHOW GUILT TRIP
            bioOverlay.style.display = 'block';
            resHeaders.style.marginBottom = '5px';
            stamp.innerText = "FAILED"; 
            stamp.style.color = "#C00"; stamp.style.borderColor = "#C00";
            title.innerText = "DISAVOWED"; 
            desc.innerText = resultReason;
            desc.style.color = "#333"; 

            award.innerText = "";

            // UPDATE BIO STAMP STATUS (HOSPITALISED VS DECEASED)
            const bioStamp = document.querySelector('.bio-stamp');
            bioStamp.innerText = victimSurvivalStatus;
            
            if (victimSurvivalStatus === "HOSPITALISED") {
                bioStamp.style.color = "#C00";         // Now Red
                bioStamp.style.borderColor = "#C00";    // Now Red
            } else {
                bioStamp.style.color = "#C00";
                bioStamp.style.borderColor = "#C00";
            }
        }
        document.getElementById('streak-display').innerText = KILL_STREAK;
        renderStats();
    }

    function toggleZoom(forceOff) {
        if(forceOff) isZoomed = false; else isZoomed = !isZoomed;
        document.getElementById('scope-overlay').style.display = isZoomed ? 'block' : 'none';
        const ch = document.getElementById('crosshair');
        if(isZoomed) ch.classList.add('zoomed'); else ch.classList.remove('zoomed');
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if(matCanvas) {
            matCanvas.width = window.innerWidth;
            matCanvas.height = window.innerHeight;
            initMatrix();
        }
    }

    init();
</script>
</body>
</html>
